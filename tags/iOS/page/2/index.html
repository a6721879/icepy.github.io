<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: iOS | icepy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在生活中奔跑">
<meta property="og:type" content="website">
<meta property="og:title" content="icepy">
<meta property="og:url" content="http://lcepy.github.io/tags/iOS/page/2/">
<meta property="og:site_name" content="icepy">
<meta property="og:description" content="在生活中奔跑">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icepy">
<meta name="twitter:description" content="在生活中奔跑">

  
    <link rel="alternative" href="/atom.xml" title="icepy" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://7qncz5.com1.z0.glb.clouddn.com/img/me.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">icepy</a></h1>
		</hgroup>

		
		<p class="header-subtitle">曾记否，到中流击水，浪遏飞舟！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/lcepy" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="/xiangwenwe@foxmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JavaScript/" style="font-size: 18.00px;">JavaScript</a><a href="/tags/django/" style="font-size: 14.00px;">django</a><a href="/tags/iOS/" style="font-size: 20.00px;">iOS</a><a href="/tags/nodejs/" style="font-size: 12.00px;">nodejs</a><a href="/tags/python/" style="font-size: 10.00px;">python</a><a href="/tags/生活/" style="font-size: 16.00px;">生活</a><a href="/tags/简历/" style="font-size: 10.00px;">简历</a><a href="/tags/经验之谈/" style="font-size: 12.00px;">经验之谈</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">忆往昔峥嵘岁月稠</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">icepy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7qncz5.com1.z0.glb.clouddn.com/img/me.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">icepy</h1>
			</hgroup>
			
			<p class="header-subtitle">曾记否，到中流击水，浪遏飞舟！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/lcepy" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/xiangwenwe@foxmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-CoreData的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/05/CoreData的使用/" class="article-date">
  	<time datetime="2015-05-05T02:31:04.000Z" itemprop="datePublished">5月 5 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/CoreData的使用/">CoreData的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CoreData是Cocoa中处理数据，绑定数据的一个框架，如果不靠谱数据的平台一致性（iOS，Android），完全可以使用它替代SQLite。虽然，iOS也有一个C实现的SQLite库，但是语法层面比较琐碎，而且使用的是C函数。如果要使用，大家可以选择使用一个开源的库来替代<a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">Obje-C版</a>和<a href="https://github.com/FahimF/SQLiteDB" target="_blank" rel="external">Swift版</a></p>
<p>从代码层面上来看，要创建一个CoreData实例，需要四个步骤</p>
<ul>
<li>创建数据库文件的物理地址</li>
<li>创建模型托管对象</li>
<li>创建持久化存储调度器</li>
<li>创建上下文</li>
</ul>
<p>正常情况下，上述四个步骤，我们只使用一次，建议惰性加载它</p>
<pre><code>-(NSManagedObjectContext *)context
{
    <span class="keyword">if</span> (!_context) {
        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
        <span class="comment">//创建db url</span>
        <span class="built_in">NSString</span> *dbPath = [<span class="keyword">self</span><span class="variable">.baseDoc</span> stringByAppendingPathComponent:<span class="string">@"manong.db"</span>];
        <span class="built_in">NSURL</span> *dbUrl = [<span class="built_in">NSURL</span> fileURLWithPath:dbPath];
        <span class="comment">//创建模型托管对象</span>
        NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:<span class="literal">nil</span>];
        <span class="comment">//创建持久化存储调度器</span>
        NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
        [store addPersistentStoreWithType:NSSQLiteStoreType configuration:<span class="literal">nil</span> URL:dbUrl options:<span class="literal">nil</span> error:&amp;error];
        <span class="comment">//创建上下文</span>
        _context = [[NSManagedObjectContext alloc] init];
        [_context setPersistentStoreCoordinator:store];
    }
    <span class="keyword">return</span> _context;
}
</code></pre><p>下面给出一张关系图</p>
<p><img src="http://websources.qiniudn.com/iOS/CoreData类关系图.png" alt="CoreData类关系图"></p>
<p>从上述的图中，其实可以看到一些有关系的模块</p>
<ul>
<li>Managed Object Model 用于描述数据模型，这里包括实体，属性，请求等</li>
<li>Managed Object Context 参与对数据对象进行各项操作的上下文</li>
<li>Managed Object 数据对象（用户使用的对象与上下文有关联）</li>
<li>Persistent Store 相当于数据库文件的管理器，处理底层对数据库文件的读取与写入</li>
</ul>
<p><strong>基本上创建一个Managed Object文件不需要自己去手动创建，而且建议Xcode帮助我们创建的model文件不要修改</strong></p>
<p>如果非要自己创建的话，那么继承NSManagedObject类吧</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="preprocessor">#import <span class="title">&lt;CoreData/CoreData.h&gt;</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">ManongTag</span> : <span class="title">NSManagedObject</span></span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSNumber</span> * contentCount;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSString</span> * tagKey;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSString</span> * tagName;

<span class="keyword">@end</span>
</code></pre><h1 id="下面给出一张实际的操作图，如何使用CoreData。">下面给出一张实际的操作图，如何使用CoreData。</h1>
<p><img src="http://websources.qiniudn.com/iOS/CoreData操作图形化.jpg" alt="CoreData操作图形化"> </p>
<ul>
<li>首先add Entity添加一个实体</li>
<li>然后在Attributes中添加相应的属性，在Type中选择相应的数据类型</li>
<li>Pelationships可以对实体进行关联，比如ManongTitle实体中关联了一个ManongContent实体</li>
<li>&lt;橘黄色箭头&gt;可以设置多关联，在使用的时候它会是一个NSSet集合</li>
<li>Style可以查看设计图</li>
</ul>
<p>如果想新增一条数据，需要三个步骤才能实现，第一先创建一个实体描述，第二创建一个ManagedObject对象，第三给上下文的save方法发送消息。</p>
<pre><code>NSEntityDescription *mnTag = [NSEntityDescription entityForName:<span class="string">@"ManongTag"</span> inManagedObjectContext:<span class="keyword">self</span><span class="variable">.context</span>];
ManongTag *manongTag = [[ManongTag alloc] initWithEntity:mnTag insertIntoManagedObjectContext:<span class="keyword">self</span><span class="variable">.context</span>];
manongTag<span class="variable">.tagKey</span> = tagKey;
manongTag<span class="variable">.tagName</span> = tagNmae;
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
<span class="built_in">BOOL</span> success;
[<span class="keyword">self</span><span class="variable">.context</span> save:&amp;error];
success = error ? <span class="literal">NO</span> : <span class="literal">YES</span>;
</code></pre><p>如果想在实体中查询数据，一般情况下两个步骤，如果是条件查询最少三个步骤，第一创建一个查询请求，第二创建一个谓词对象，第三给上下文的executeFetchRequest方法发送消息。</p>
<pre><code><span class="comment">//查询所有的数据</span>
<span class="constant">NSFetchRequest *request</span> = [[NSFetchRequest alloc] initWithEntityName:@<span class="string">"ManongDigest"</span>];
<span class="constant">NSArray *arr</span> = [self.context executeFetchRequest:request error:&amp;error];

<span class="comment">//条件查询</span>
<span class="constant">NSFetchRequest *request</span> = [[NSFetchRequest alloc] initWithEntityName:@“ManongDigest”];
<span class="constant">NSPredicate *dicate</span> = [NSPredicate predicateWithFormat:@<span class="string">"%K BEGINSWITH[c] %@"</span>,@<span class="string">"tagName"</span>,@<span class="string">"a"</span>];
<span class="constant">NSArray *arr</span> = [self.context executeFetchRequest:request error:&amp;error];
</code></pre><p>如果想更新某一条数据，正常情况下三个步骤，第一创建一个查询请求，第二修改MangedObject对象的属性，第三给上下文的save方法发送消息。</p>
<pre><code>NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:<span class="string">@"ManongDigest"</span>];
<span class="built_in">NSArray</span> *arr = [<span class="keyword">self</span><span class="variable">.context</span> executeFetchRequest:request error:&amp;error];
<span class="keyword">for</span>(ManongDigest *digest <span class="keyword">in</span> arr)
{
    digest<span class="variable">.tagName</span> = <span class="string">@"lcepy"</span>;
}
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
[<span class="keyword">self</span><span class="variable">.context</span> save:&amp;error];
<span class="keyword">if</span> (error) {
    <span class="keyword">return</span> <span class="literal">NO</span>;
}<span class="keyword">else</span>{
    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>如果想删除某一条数据</p>
<pre><code>NSFetchRequest *<span class="built_in">request</span> = [[NSFetchRequest alloc] initWithEntityName:@<span class="string">"ManongDigest"</span>];
NSArray *arr = [self.context executeFetchRequest:<span class="built_in">request</span> <span class="keyword">error</span>:&amp;<span class="keyword">error</span>];
<span class="keyword">if</span>(arr.count){
    ManongDigest *digest = (ManongDigest *)arr[<span class="number">0</span>];
    [self.context deleteObject:digest];
}
</code></pre><p>上述四种操作方式是最常用的，当然CoreData 的API肯定不止这四种，但是使用的逻辑思维基本上是，查询－处理－使用上下文或者创建实体－处理－使用上下文。</p>
<p>这个框架算比较复杂的一个，学习起来曲线也比较大，需要耐心。</p>
<p>参考资料</p>
<ul>
<li><a href="http://www.objc.io/issue-4/" target="_blank" rel="external">objc-CoreData</a></li>
<li><a href="http://objccn.io/issue-4-2/" target="_blank" rel="external">一个完整的 Core Data 应用</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreData_ObjC/index.html" target="_blank" rel="external">Core Data API</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/" target="_blank" rel="external">NSPredicate API</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-NSArray" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/03/NSArray/" class="article-date">
  	<time datetime="2015-05-03T07:42:06.000Z" itemprop="datePublished">5月 3 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/03/NSArray/">NSArray</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基础扎实才能使编程更加的得心应手，今天要写一些学习NSArray以及NSMutableArray的东西。</p>
<p>创建一个数组其实跟创建NSString一样OC也提供了三种方式，语法糖，实例化，类方法。</p>
<pre><code><span class="comment">//创建语法糖</span>
<span class="built_in">NSArray</span> *arry = @[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>,<span class="string">@"4"</span>];
<span class="comment">//手动实例创建</span>
<span class="built_in">NSArray</span> *arry1 = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];
<span class="comment">//类方法创建</span>
<span class="built_in">NSArray</span> *arry2 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];
</code></pre><p>查找一个元素在数组中是否存在</p>
<pre><code><span class="comment">//查找元素是否存在，在数组中</span>
<span class="constant">BOOL isTrue</span> = [arry containsObject:@<span class="string">"1"</span>];
</code></pre><p>获取数组的长度</p>
<pre><code><span class="comment">//数组的长度</span>
<span class="type">NSUInteger</span> <span class="built_in">count</span> = arry.<span class="built_in">count</span>;
<span class="type">NSLog</span>(@<span class="string">"%zd"</span>,<span class="built_in">count</span>);
</code></pre><p>获取第一个元素和获取最后一个元素</p>
<pre><code><span class="comment">//获取第一个元素</span>
<span class="keyword">id</span> first = arry<span class="variable">.firstObject</span>;
<span class="comment">//获取最后一个元素</span>
<span class="keyword">id</span> last = arry<span class="variable">.lastObject</span>;
</code></pre><p>查找元素在数组中的位置，还可以指定一个range来确定查找的范围</p>
<pre><code><span class="comment">//查找元素在数组中的位置</span>
<span class="built_in">NSInteger</span> index = [arry indexOfObject:<span class="string">@"1"</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>,index);

<span class="comment">//查找元素的位置，可以指定一个range</span>
<span class="built_in">NSRange</span> arrRange = NSMakeRange(<span class="number">1</span>, <span class="number">2</span>);
<span class="built_in">NSInteger</span> rangeIndex = [arry indexOfObject:<span class="string">@"3"</span> inRange:arrRange];
<span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>,rangeIndex);
</code></pre><p>指定一个下标来获取元素</p>
<pre><code><span class="comment">//指定一个下标获取元素</span>
<span class="keyword">id</span> element = [arry objectAtIndex:<span class="number">1</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,element);
</code></pre><p>添加一个元素<strong>注意 NSArray是不可变的，所以添加的元素不是旧数组，而是创建了一个包含旧数组的新数组</strong>，还可以添加一个数组</p>
<pre><code><span class="comment">//添加一个元素，返回一个新的数组</span>
<span class="constant">NSArray *lcepy</span> = [arry arrayByAddingObject:@<span class="string">"lcepy"</span>];
<span class="comment">//添加一个数组，返回一个新的数组</span>
<span class="constant">NSArray *newLcepy</span> = [arry arrayByAddingObjectsFromArray:@[@<span class="string">"lcepy"</span>,@<span class="string">"github.io"</span>]];
</code></pre><p>格式化一个数组</p>
<pre><code><span class="comment">//通过一个分隔字符串来组建一个拼接字符串</span>
<span class="built_in">NSString</span> *ress =  [newLcepy componentsJoinedByString:<span class="string">@"."</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ress);
</code></pre><p>除了for循环，for in循环外的其它几种常用的遍历方式</p>
<pre><code><span class="comment">//NSEnumerator是一个抽象类，可以使用它的nextObject来遍历元素，通常和while一起使用</span>
NSEnumerator *enumer =  [newLcepy objectEnumerator];
<span class="built_in">BOOL</span> isEnumer = <span class="literal">YES</span>;
<span class="keyword">while</span> (isEnumer) {
    <span class="keyword">id</span> enumerValue = [enumer nextObject];
    <span class="keyword">if</span> (!enumerValue) {
        isEnumer = <span class="literal">NO</span>;
    }
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,enumerValue);
}

[arrays enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop) {
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,obj);
    <span class="keyword">if</span> (idx &gt; <span class="number">3</span>) {
        *stop = <span class="literal">YES</span>;
    }
}];
</code></pre><p>假设如果数组中的元素都想向某个方法发送消息，那么可以这么使用，这样的方式，比如在想移除所有子视图这样的场景中非常好用</p>
<pre><code><span class="comment">//假设有一个数组中的元素都想向某个方法发送消息，那么可以使用makeObjectsPerformSelector类定义了</span>
[newLcepy makeObjectsPerformSelector:@selector(<span class="built_in">length</span>)];
</code></pre><p>给数组排序的几种方式</p>
<pre><code><span class="comment">//排序</span>
<span class="built_in">NSArray</span> *arrays = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">0</span>,@<span class="number">8</span>,@<span class="number">3</span>,@<span class="number">9</span>,@<span class="number">5</span>];

<span class="comment">//正</span>
<span class="built_in">NSArray</span> *minMax = [arrays sortedArrayUsingComparator:^NSComparisonResult(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) {
    <span class="keyword">return</span> obj1 &gt; obj2;
}];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,minMax);
<span class="comment">//倒</span>
<span class="built_in">NSArray</span> *maxMin = [arrays sortedArrayUsingComparator:^NSComparisonResult(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) {
    <span class="keyword">return</span> obj1 &lt; obj2;
}];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,maxMin);

<span class="comment">//    [arrays sortedArrayWithOptions:&lt;#(NSSortOptions)#&gt; usingComparator:&lt;#^NSComparisonResult(id obj1, id obj2)cmptr#&gt;]</span>

<span class="comment">//    [arrays sortedArrayUsingFunction:&lt;#(NSInteger (*)(__strong id, __strong id, void *))#&gt; context:&lt;#(void *)#&gt;]</span>

SEL execu = <span class="keyword">@selector</span>(compare:);
<span class="built_in">NSArray</span> *newArr = [arrays sortedArrayUsingSelector:execu];
<span class="built_in">NSLog</span>(<span class="string">@"s%@"</span>,newArr);
</code></pre><p>数组还可以进行筛选，NSPredicate这个类在使用Core Data时会经常用到</p>
<pre><code>[arrays filteredArrayUsingPredicate:&lt;#(NSPredicate *)#&gt;]
</code></pre><h3 id="NSMutableArray">NSMutableArray</h3>
<p>创建NSMutableArray只有两种方式，alloc和类方法，这是一个可变的数组，可以增删改滴，也可以排序，NSArray存在的方法，NSMutableArray全部具备，只是它多了可以添加，删除，修改，替换的方法，这里不一一写例子了，可以自己实际操作一下。</p>
<pre><code><span class="pp">- <span class="params">(void)</span>addObject:<span class="params">(id)</span>anObject;
- <span class="params">(void)</span>insertObject:<span class="params">(id)</span>anObject atIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>index;
- <span class="params">(void)</span>removeLastObject;
- <span class="params">(void)</span>removeObjectAtIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>index;
- <span class="params">(void)</span>replaceObjectAtIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>index withObject:<span class="params">(id)</span>anObject;
- <span class="params">(void)</span>addObjectsFromArray:<span class="params">(<span class="variable">NSArray</span> *)</span>otherArray;
- <span class="params">(void)</span>exchangeObjectAtIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>idx1 withObjectAtIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>idx2;
- <span class="params">(void)</span>removeAllObjects;
- <span class="params">(void)</span>removeObject:<span class="params">(id)</span>anObject inRange:<span class="params">(<span class="variable">NSRange</span>)</span>range;
- <span class="params">(void)</span>removeObject:<span class="params">(id)</span>anObject;
- <span class="params">(void)</span>removeObjectIdenticalTo:<span class="params">(id)</span>anObject inRange:<span class="params">(<span class="variable">NSRange</span>)</span>range;
- <span class="params">(void)</span>removeObjectIdenticalTo:<span class="params">(id)</span>anObject;
- <span class="params">(void)</span>removeObjectsFromIndices:<span class="params">(<span class="variable">NSUInteger</span> *)</span>indices numIndices:<span class="params">(<span class="variable">NSUInteger</span>)</span>cnt NS_DEPRECATED<span class="params">(<span class="number">10</span>_0, <span class="number">10</span>_6, <span class="number">2</span>_0, <span class="number">4</span>_0)</span>;
- <span class="params">(void)</span>removeObjectsInArray:<span class="params">(<span class="variable">NSArray</span> *)</span>otherArray;
- <span class="params">(void)</span>removeObjectsInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range;
- <span class="params">(void)</span>replaceObjectsInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range withObjectsFromArray:<span class="params">(<span class="variable">NSArray</span> *)</span>otherArray range:<span class="params">(<span class="variable">NSRange</span>)</span>otherRange;
- <span class="params">(void)</span>replaceObjectsInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range withObjectsFromArray:<span class="params">(<span class="variable">NSArray</span> *)</span>otherArray;
- <span class="params">(void)</span>setArray:<span class="params">(<span class="variable">NSArray</span> *)</span>otherArray;
- <span class="params">(void)</span>sortUsingFunction:<span class="params">(<span class="variable">NSInteger</span> (*)</span><span class="params">(id, id, void *)</span>)compare context:<span class="params">(void *)</span>context;
- <span class="params">(void)</span>sortUsingSelector:<span class="params">(<span class="variable">SEL</span>)</span>comparator;
- <span class="params">(void)</span>insertObjects:<span class="params">(<span class="variable">NSArray</span> *)</span>objects atIndexes:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>indexes;
- <span class="params">(void)</span>removeObjectsAtIndexes:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>indexes;
- <span class="params">(void)</span>replaceObjectsAtIndexes:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>indexes withObjects:<span class="params">(<span class="variable">NSArray</span> *)</span>objects;

- <span class="params">(void)</span>setObject:<span class="params">(id)</span>obj atIndexedSubscript:<span class="params">(<span class="variable">NSUInteger</span>)</span>idx NS_AVAILABLE<span class="params">(<span class="number">10</span>_8, <span class="number">6</span>_0)</span>;

- <span class="params">(void)</span>sortUsingComparator:<span class="params">(<span class="variable">NSComparator</span>)</span>cmptr NS_AVAILABLE<span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span>;
- <span class="params">(void)</span>sortWithOptions:<span class="params">(<span class="variable">NSSortOptions</span>)</span>opts usingComparator:<span class="params">(<span class="variable">NSComparator</span>)</span>cmptr NS_AVAILABLE<span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span>;</span>
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-好用的WebKit-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/01/好用的WebKit-framework/" class="article-date">
  	<time datetime="2015-05-01T06:25:36.000Z" itemprop="datePublished">5月 1 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/01/好用的WebKit-framework/">好用的WebKit.framework</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>WebKit是iOS8推出的一个用于替代UIWebView的框架，解决了很多UIWebView的问题，比如释放内存，各种稀奇古怪的bug，而且还内置了手势的处理，一句话：好用。</p>
<p>注意：<strong>2015年4月更新的苹果审核文档中明确标识，必须要用WebKit替换UIWebView，不然审核拒绝。</strong></p>
<p>在使用WebKit框架的过程中，自己也遇到了一些问题，有些解决了，有些还未解决。</p>
<ul>
<li>WebKit目前还未能在storyboard中直接使用，需要用代码的方式创建，手动添加约束</li>
<li>对于某些页面如果设置了overflow-x，这可能引起scrollView的contentSize的变化，进一步影响WKWebView的内置手势，swipe返回失效</li>
<li>目前还未找到怎么处理NSURLCache的问题，也就是页面的缓存机制，看样子好像要自己实现</li>
</ul>
<p>如何创建一个WKWebView？首先要在link中引入WebKit.framework，然后使用代码的方式：</p>
<pre><code>-(<span class="constant">WKWebView</span> *)<span class="constant">WKWebPageView</span>
{
    <span class="keyword">if</span> (!_WKWebPageView) {
        _WKWebPageView = [[<span class="constant">WKWebView</span> alloc] <span class="symbol">initWithFrame:</span><span class="keyword">self</span>.view.bounds];
        _WKWebPageView.navigationDelegate = <span class="keyword">self</span>;
    }
    <span class="keyword">return</span> _WKWebPageView;
}
</code></pre><p>WKWebView主要需要实现两个协议WKNavigationDelegate和WKUIDelegate，前一个用于一个页面的加载状态，包括第一次响应成功，加载中，加载完成，加载错误等，后面一个我个人感觉有点意思，主要用于改变UI界面，比如客户端JavaScript使用了一个alert，这个协议可以捕获到，然后使用原生的控件来替代。</p>
<p>WebKit框架还提供了一个任务配置类WKWebViewConfiguration，跟NSURLSessionConfiguration的使用方式类似,可以重新初始化WKWebView的一些配置。</p>
<p>WKNavigationDelegate协议，我主要使用了三个来处理我的应用，加载中，加载完成，加载错误的处理：</p>
<pre><code><span class="pp">-<span class="params">(void)</span>webView:<span class="params">(<span class="variable">WKWebView</span> *)</span>webView didStartProvisionalNavigation:<span class="params">(<span class="variable">WKNavigation</span> *)</span>navigation
{

}

-<span class="params">(void)</span>webView:<span class="params">(<span class="variable">WKWebView</span> *)</span>webView didFinishNavigation:<span class="params">(<span class="variable">WKNavigation</span> *)</span>navigation
{

}

-<span class="params">(void)</span>webView:<span class="params">(<span class="variable">WKWebView</span> *)</span>webView didFailProvisionalNavigation:<span class="params">(<span class="variable">WKNavigation</span> *)</span>navigation withError:<span class="params">(<span class="variable">NSError</span> *)</span>error
{

}</span>
</code></pre><p>另外一些属性我用KVO来监听：</p>
<pre><code>[<span class="keyword">self</span>.<span class="constant">WKWebPageView</span> <span class="symbol">addObserver:</span><span class="keyword">self</span> <span class="symbol">forKeyPath:</span>@<span class="string">"estimatedProgress"</span> <span class="symbol">options:</span><span class="constant">NSKeyValueObservingOptionNew</span> <span class="symbol">context:</span><span class="keyword">nil</span>];
[<span class="keyword">self</span>.<span class="constant">WKWebPageView</span> <span class="symbol">addObserver:</span><span class="keyword">self</span> <span class="symbol">forKeyPath:</span>@<span class="string">"title"</span> <span class="symbol">options:</span><span class="constant">NSKeyValueObservingOptionNew</span> <span class="symbol">context:</span><span class="keyword">nil</span>];
[<span class="keyword">self</span>.<span class="constant">WKWebPageView</span> <span class="symbol">addObserver:</span><span class="keyword">self</span> <span class="symbol">forKeyPath:</span>@<span class="string">"URL"</span> <span class="symbol">options:</span><span class="constant">NSKeyValueObservingOptionNew</span> <span class="symbol">context:</span><span class="keyword">nil</span>];
[<span class="keyword">self</span>.<span class="constant">WKWebPageView</span> <span class="symbol">addObserver:</span><span class="keyword">self</span> <span class="symbol">forKeyPath:</span>@<span class="string">"canGoBack"</span> <span class="symbol">options:</span><span class="constant">NSKeyValueObservingOptionNew</span> <span class="symbol">context:</span><span class="keyword">nil</span>];
</code></pre><p>它们分别是，页面的加载进度，页面的标题，页面的URL，页面是否回退过</p>
<p>WKWebView默认是没有开启内置手势的，可以通过allowsBackForwardNavigationGestures来设置</p>
<p>与JavaScript的交互，我目前主要使用[self.WKWebPageView evaluateJavaScript:&lt;#(NSString <em>)#&gt; completionHandler:&lt;#^(id, NSError </em>)completionHandler#&gt;]来动态改变页面加载完成之后的css样式，还有WKUserScript <em>script = [[WKUserScript alloc] initWithSource:&lt;#(NSString </em>)#&gt; injectionTime:&lt;#(WKUserScriptInjectionTime)#&gt; forMainFrameOnly:&lt;#(BOOL)#&gt;]来创建脚本，它可以明确指定加载前后注入的方式。</p>
<p><strong>注明：上述的两种创建脚本的方式都是单方向的</strong></p>
<p>如果我们想互相调用，那么就要实现WKScriptMessageHandler协议了，具体的使用方式可以参考下面给出的的参考资料。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">WKWebView-NSHipster</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKScriptMessageHandler_Ref/index.html" target="_blank" rel="external">WKScriptMessageHandler</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKWebView_Ref/index.html" target="_blank" rel="external">WKWebView</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKWebViewConfiguration_Ref/index.html" target="_blank" rel="external">WKWebViewConfiguration</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKUIDelegate_Ref/index.html" target="_blank" rel="external">WKUIDelegate</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKNavigationDelegate_Ref/index.html" target="_blank" rel="external">WKNavigationDelegate</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-iOS的网络编程NSURL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/22/iOS的网络编程NSURL/" class="article-date">
  	<time datetime="2015-04-22T04:37:14.000Z" itemprop="datePublished">4月 22 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/22/iOS的网络编程NSURL/">iOS的网络编程NSURL</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果只是说iOS中的URL系统，它的东西还不算比较多。但是，如果想用好它，可能还需要具备一些其他方面的知识，特别是多任务编程，比如GCD，NSOperation，NSOperationQueue，NSURLSession等等，而且苹果公司在后期还推了一个叫NSURLComponents的东西，这也是需要去学习的。</p>
<p>一个简单的URL是这样发送出去的：</p>
<pre><code><span class="built_in">NSString</span> *path = <span class="string">@"http://lcepy.github.io"</span>;
<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:path];
<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];
NSURLResponse *response = <span class="literal">nil</span>;
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
[<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
</code></pre><p>基本上如果要构造一个request需要先构造一个NSURL对象，然后通过NSURLConnection发送出去。NSURLRequest是一个不可变的对象，默认发送的是GET的请求，如果想要发送POST请求，可以用它可变的NSMutableURLRequest来支持POST请求，包括超时时间等等。</p>
<p>关于NSURLConnection有三种方式可以发送请求，前面同步版本我们已经看过了，下面是异步和使用协议的方式：</p>
<pre><code>[NSURLConnection sendAsynchronousRequest:request queue:nil completionHandler:^(NSURLResponse <span class="keyword">*</span>response, NSData <span class="keyword">*</span>data, NSError <span class="keyword">*</span>connectionError) {

}];
</code></pre><p>协议：</p>
<pre><code><span class="comment">//实现NSURLConnectionDataDelegate协议</span>

<span class="built_in">NSURLConnection</span> *connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];
[connection start];

<span class="comment">//常用的需要实现下面四种方法</span>

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error
{
    <span class="comment">//请求超时，错误的时候</span>
}

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(NSURLResponse *)response
{
    <span class="comment">//服务器第一次响应一个response的时候</span>
}

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(NSData *)data
{
    <span class="comment">//传输数据</span>
}

-(<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection
{
    <span class="comment">//完成的时候</span>
}
</code></pre><p>对于某些任务，比如下载图片，文件等等大数据的时候，可以使用一个临时会话来启动一个请求，也就是构造一个NSURLSession。</p>
<pre><code>NSURLSessionConfiguration <span class="keyword">*</span>configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
NSURLSession <span class="keyword">*</span>session = [NSURLSession sessionWithConfiguration:configuration];
NSURLSessionDataTask <span class="keyword">*</span>task = [session dataTaskWithRequest:request completionHandler:^(NSData <span class="keyword">*</span>data, NSURLResponse <span class="keyword">*</span>response, NSError <span class="keyword">*</span>error) {

    //请求的结果
}];
[task resume];
</code></pre><p>临时会话的好处是每一个都不是在主线程执行，写的代码量比较少，适合简单的任务。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="http://nshipster.cn/nsurl/" target="_blank" rel="external">NSURL/NSURLComponents</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLRequest_Class/" target="_blank" rel="external">NSURLRequest</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURL_Class/index.html" target="_blank" rel="external">NSURL</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/index.html" target="_blank" rel="external">NSURLConnection</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="external">NSURLSession</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLResponse_Class/index.html" target="_blank" rel="external">NSURLResponse</a></li>
<li><a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">从 NSURLConnection 到 NSURLSession</a></li>
<li><a href="http://ubluesky.com/archives/55" target="_blank" rel="external">NSURL详解</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-NSString" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/18/NSString/" class="article-date">
  	<time datetime="2015-04-18T15:05:37.000Z" itemprop="datePublished">4月 18 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/18/NSString/">NSString</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>NSString是我学习的第一个类，它是iOS中专门处理字符串的一个类，包括有从文件读取，从网络读取，标准C的转换，格式化，大小写转换，查询，写入文件等，当然它也有一个对应的Mutable。</p>
<p><strong>优化指南：尽早开启ARC，以下都是ARC版</strong></p>
<p>要使用NSString有三种方式，第一种语法糖方式，第二种alloc方式，第三种使用类方法方式。</p>
<pre><code><span class="built_in">NSString</span> *str = <span class="string">@""</span>;
<span class="built_in">NSString</span> *str1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>,<span class="string">@"hello"</span>];
<span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,<span class="string">@"hello"</span>];
</code></pre><p>开发中用语法糖或者类方法的方式比较多</p>
<h3 id="NSString常用">NSString常用</h3>
<p>查询前缀，后缀</p>
<pre><code><span class="constant">NSString *str</span> = @<span class="string">"http://lcepy.github.io"</span>;
<span class="constant">BOOL isF</span> = [str hasPrefix:@<span class="string">"http"</span>];
<span class="constant">BOOL isL</span> = [str hasSuffix:@<span class="string">"io"</span>];
</code></pre><p>创建格式化字符串</p>
<pre><code><span class="built_in">NSString</span> *formatter = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://%@"</span>,<span class="string">@"lcepy.github.io"</span>];
<span class="built_in">NSString</span> *formatter1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"http://%@"</span>,<span class="string">@"lcepy.github.io"</span>];
</code></pre><p>从网络读取以及响应，当然很少有人会这么干PS :会block主线程</p>
<pre><code><span class="built_in">NSURL</span> *urlS = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://lcepy.github.io"</span>];
<span class="built_in">NSString</span> *urlStr = [<span class="built_in">NSString</span> stringWithContentsOfURL:urlS encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
<span class="built_in">NSString</span> *urlStr1 = [[<span class="built_in">NSString</span> alloc] initWithContentsOfURL:urlS encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
[urlStr writeToURL:urlS atomically:<span class="literal">YES</span> encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
</code></pre><p>从本地文件中读取以及写入</p>
<pre><code><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"lcepy"</span> ofType:<span class="string">@"html"</span>];
<span class="built_in">NSString</span> *fileStr = [<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
<span class="built_in">NSString</span> *fileStr1 = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:path encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
[fileStr writeToFile:str atomically:<span class="literal">YES</span> encoding:NSUTF8StringEncoding error:<span class="literal">nil</span>];
</code></pre><p>字符串的比较，因为OC是C语言的超集，所以字符串有两种比较方式，指针一样，还有指针一样内容一样的比较，而==一般都不建议使用，它比较的是引用，NSString有它的比较方法。</p>
<pre><code>isEqualToString

<span class="type">NSString</span> *astring01 = @<span class="string">"This is a String!"</span>;
<span class="type">NSString</span> *astring02 = @<span class="string">"This is a String!"</span>;
<span class="type">BOOL</span> <span class="literal">result</span> = [astring01 compare:astring02] == <span class="type">NSOrderedSame</span>;    //<span class="type">NSOrderedSame</span>判断两者内容是否相同
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,<span class="literal">result</span>);
<span class="type">BOOL</span> result1 = [astring01 compare:astring02] == <span class="type">NSOrderedAscending</span>;    //<span class="type">NSOrderedAscending</span>判断两对象值的大小(按字母顺序进行比较，astring02大于astring01为真)
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,result1);
<span class="type">BOOL</span> result2 = [astring01 compare:astring02] == <span class="type">NSOrderedDescending</span>;    //<span class="type">NSOrderedDescending</span>判断两对象值的大小(按字母顺序进行比较，astring02小于astring01为真)
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,result2);
</code></pre><p>大小写以及首字母大写</p>
<pre><code><span class="built_in">NSString</span> *io = <span class="string">@"hello"</span>;
<span class="built_in">NSString</span> *IO = <span class="string">@"HELLO"</span>;
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[io uppercaseString]);
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[IO lowercaseString]);
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[io capitalizedString]);
</code></pre><p>查询截取PS—&gt;<strong>我觉得NSString使用最频繁的一处，查询截取是在开发中无法避免的事项，它非常有用</strong>其实，在使用查询这一系列的方式时，它和NSRange有紧密相连的关系。NSRange是一个结构体，用来描述起始位置，以及计数。</p>
<pre><code><span class="built_in">NSString</span> *str = <span class="string">@"http://lcepy.github.io"</span>;
<span class="built_in">NSRange</span> httpRange =  [str rangeOfString:<span class="string">@"http"</span>]; <span class="comment">//返回一个range结构体</span>
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,NSStringFromRange(httpRange));


<span class="built_in">NSRange</span> ioRange = [str rangeOfString:<span class="string">@"io"</span>];
<span class="built_in">NSString</span> *subs = [str substringWithRange:NSMakeRange(ioRange<span class="variable">.location</span>, ioRange<span class="variable">.length</span>-<span class="number">1</span>)]; <span class="comment">//从指定位置开始截取字符串</span>
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,subs);

<span class="comment">//从字符串开头一直截取到指定位置</span>
<span class="built_in">NSString</span> *indexStr = [str substringToIndex:<span class="number">4</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,indexStr);

<span class="comment">//从指定位置开始截取到最后的字符串（包括）</span>
<span class="built_in">NSString</span> *lastStr = [str substringFromIndex:<span class="number">4</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,lastStr);
</code></pre><p>扩展路径以及获取扩展文件名</p>
<pre><code><span class="built_in">NSString</span> *doc = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, <span class="literal">YES</span>)[<span class="number">0</span>];
<span class="built_in">NSString</span> *filePath = [doc stringByAppendingPathComponent:<span class="string">@"PhotoCache"</span>];
<span class="built_in">NSString</span> *file = <span class="string">@"~/lcepy.io"</span>;
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[file pathExtension]);
</code></pre><h3 id="NSMutableString常用">NSMutableString常用</h3>
<p>注意PS—&gt;<strong>NSString可以使用的方法，Mutable版全部具备，Mutable版的方法，NSString不一定有</strong></p>
<p>在字符串最后插入或者格式化插入字符串</p>
<pre><code>NSMutableString *str1 = [NSMutableString stringWithStrin<span class="variable">g:</span>@<span class="string">"http://lcepy.github.io"</span>];
[str1 appendStrin<span class="variable">g:</span>@<span class="string">"#login"</span>];
[str1 appendForma<span class="variable">t:</span>@<span class="string">"%@"</span>,@<span class="string">"#login"</span>];
NSLog(@<span class="string">"%@"</span>,str1);
</code></pre><p>在指定的位置插入字符串</p>
<pre><code><span class="attr_selector">[str1 insertString:@"?id=fjdkfjkgfgi384jkg" atIndex:str1.length]</span>;
<span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"%@"</span>,str1);</span>
</code></pre><p>在指定的范围内替换</p>
<pre><code><span class="built_in">NSRange</span> login = [str1 rangeOfString:<span class="string">@"#login"</span>];
[str1 replaceCharactersInRange:login withString:<span class="string">@"#logou"</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);
</code></pre><p>延伸阅读：</p>
<ul>
<li><a href="http://blog.devtang.com/blog/2012/02/14/nsstring-java-like-wrapper/" target="_blank" rel="external">给NSString添加java风格：（感觉有点意思）</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html" target="_blank" rel="external">NSString</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/tags/iOS/">&laquo; Prev</a><a class="page-number" href="/tags/iOS/">1</a><span class="page-number current">2</span><a class="page-number" href="/tags/iOS/page/3/">3</a><a class="page-number" href="/tags/iOS/page/4/">4</a><a class="page-number" href="/tags/iOS/page/5/">5</a><a class="extend next" rel="next" href="/tags/iOS/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 icepy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/mobile.js" type="text/javascript"></script>

<script src="/js/main.js" type="text/javascript"></script>






<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>