<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>农业-行者</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS JavaScript Swift Objective-C 前端 HTML5">
<meta property="og:type" content="website">
<meta property="og:title" content="农业-行者">
<meta property="og:url" content="http://lcepy.github.io/page/4/index.html">
<meta property="og:site_name" content="农业-行者">
<meta property="og:description" content="iOS JavaScript Swift Objective-C 前端 HTML5">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="农业-行者">
<meta name="twitter:description" content="iOS JavaScript Swift Objective-C 前端 HTML5">
  
    <link rel="alternative" href="/atom.xml" title="农业-行者" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7qncz5.com1.z0.glb.clouddn.com/blog/mockingbird.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">icepy</a></h1>
		</hgroup>

		
		<p class="header-subtitle">曾记否，到中流击水，浪遏飞舟！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/icepy" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2455876310" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JavaScript/" style="font-size: 18px;">JavaScript</a> <a href="/tags/django/" style="font-size: 14px;">django</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/nodejs/" style="font-size: 12px;">nodejs</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/生活/" style="font-size: 16px;">生活</a> <a href="/tags/简历/" style="font-size: 10px;">简历</a> <a href="/tags/经验之谈/" style="font-size: 12px;">经验之谈</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">怅寥廓，问苍茫大地，谁主沉浮？</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">icepy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7qncz5.com1.z0.glb.clouddn.com/blog/mockingbird.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">icepy</h1>
			</hgroup>
			
			<p class="header-subtitle">曾记否，到中流击水，浪遏飞舟！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/icepy" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2455876310" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-好用的WebKit-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/01/好用的WebKit-framework/" class="article-date">
  	<time datetime="2015-05-01T06:25:36.000Z" itemprop="datePublished">2015-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/01/好用的WebKit-framework/">好用的WebKit.framework</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>WebKit是iOS8推出的一个用于替代UIWebView的框架，解决了很多UIWebView的问题，比如释放内存，各种稀奇古怪的bug，而且还内置了手势的处理，一句话：好用。</p>
<p>注意：<strong>2015年4月更新的苹果审核文档中明确标识，必须要用WebKit替换UIWebView，不然审核拒绝。</strong></p>
<p>在使用WebKit框架的过程中，自己也遇到了一些问题，有些解决了，有些还未解决。</p>
<ul>
<li>WebKit目前还未能在storyboard中直接使用，需要用代码的方式创建，手动添加约束</li>
<li>对于某些页面如果设置了overflow-x，这可能引起scrollView的contentSize的变化，进一步影响WKWebView的内置手势，swipe返回失效</li>
<li>目前还未找到怎么处理NSURLCache的问题，也就是页面的缓存机制，看样子好像要自己实现</li>
</ul>
<p>如何创建一个WKWebView？首先要在link中引入WebKit.framework，然后使用代码的方式：</p>
<pre><code>-(<span class="constant">WKWebView</span> *)<span class="constant">WKWebPageView</span>
{
    <span class="keyword">if</span> (!_WKWebPageView) {
        _WKWebPageView = [[<span class="constant">WKWebView</span> alloc] <span class="symbol">initWithFrame:</span><span class="keyword">self</span>.view.bounds];
        _WKWebPageView.navigationDelegate = <span class="keyword">self</span>;
    }
    <span class="keyword">return</span> _WKWebPageView;
}
</code></pre><p>WKWebView主要需要实现两个协议WKNavigationDelegate和WKUIDelegate，前一个用于一个页面的加载状态，包括第一次响应成功，加载中，加载完成，加载错误等，后面一个我个人感觉有点意思，主要用于改变UI界面，比如客户端JavaScript使用了一个alert，这个协议可以捕获到，然后使用原生的控件来替代。</p>
<p>WebKit框架还提供了一个任务配置类WKWebViewConfiguration，跟NSURLSessionConfiguration的使用方式类似,可以重新初始化WKWebView的一些配置。</p>
<p>WKNavigationDelegate协议，我主要使用了三个来处理我的应用，加载中，加载完成，加载错误的处理：</p>
<pre><code><span class="tag">-</span>(void)<span class="tag">webView</span>:(WKWebView *)<span class="tag">webView</span> <span class="tag">didStartProvisionalNavigation</span>:(WKNavigation *)<span class="tag">navigation</span>
{

}

<span class="tag">-</span>(void)<span class="tag">webView</span>:(WKWebView *)<span class="tag">webView</span> <span class="tag">didFinishNavigation</span>:(WKNavigation *)<span class="tag">navigation</span>
{

}

<span class="tag">-</span>(void)<span class="tag">webView</span>:(WKWebView *)<span class="tag">webView</span> <span class="tag">didFailProvisionalNavigation</span>:(WKNavigation *)<span class="tag">navigation</span> <span class="tag">withError</span>:(NSError *)<span class="tag">error</span>
{

}
</code></pre><p>另外一些属性我用KVO来监听：</p>
<pre><code>[self.WKWebPageView <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"estimatedProgress"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
[self.WKWebPageView <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"title"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
[self.WKWebPageView <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"URL"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
[self.WKWebPageView <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"canGoBack"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];
</code></pre><p>它们分别是，页面的加载进度，页面的标题，页面的URL，页面是否回退过</p>
<p>WKWebView默认是没有开启内置手势的，可以通过allowsBackForwardNavigationGestures来设置</p>
<p>与JavaScript的交互，我目前主要使用[self.WKWebPageView evaluateJavaScript:&lt;#(NSString <em>)#&gt; completionHandler:&lt;#^(id, NSError </em>)completionHandler#&gt;]来动态改变页面加载完成之后的css样式，还有WKUserScript <em>script = [[WKUserScript alloc] initWithSource:&lt;#(NSString </em>)#&gt; injectionTime:&lt;#(WKUserScriptInjectionTime)#&gt; forMainFrameOnly:&lt;#(BOOL)#&gt;]来创建脚本，它可以明确指定加载前后注入的方式。</p>
<p><strong>注明：上述的两种创建脚本的方式都是单方向的</strong></p>
<p>如果我们想互相调用，那么就要实现WKScriptMessageHandler协议了，具体的使用方式可以参考下面给出的的参考资料。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">WKWebView-NSHipster</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKScriptMessageHandler_Ref/index.html" target="_blank" rel="external">WKScriptMessageHandler</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/WebKit/Reference/WKWebView_Ref/index.html" target="_blank" rel="external">WKWebView</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKWebViewConfiguration_Ref/index.html" target="_blank" rel="external">WKWebViewConfiguration</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKUIDelegate_Ref/index.html" target="_blank" rel="external">WKUIDelegate</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKNavigationDelegate_Ref/index.html" target="_blank" rel="external">WKNavigationDelegate</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS的网络编程NSURL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/22/iOS的网络编程NSURL/" class="article-date">
  	<time datetime="2015-04-22T04:37:14.000Z" itemprop="datePublished">2015-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/22/iOS的网络编程NSURL/">iOS的网络编程NSURL</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果只是说iOS中的URL系统，它的东西还不算比较多。但是，如果想用好它，可能还需要具备一些其他方面的知识，特别是多任务编程，比如GCD，NSOperation，NSOperationQueue，NSURLSession等等，而且苹果公司在后期还推了一个叫NSURLComponents的东西，这也是需要去学习的。</p>
<p>一个简单的URL是这样发送出去的：</p>
<pre><code><span class="built_in">NSString</span> *path = <span class="string">@"http://lcepy.github.io"</span>;
<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:path];
<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];
<span class="built_in">NSURLResponse</span> *response = <span class="literal">nil</span>;
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
[<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
</code></pre><p>基本上如果要构造一个request需要先构造一个NSURL对象，然后通过NSURLConnection发送出去。NSURLRequest是一个不可变的对象，默认发送的是GET的请求，如果想要发送POST请求，可以用它可变的NSMutableURLRequest来支持POST请求，包括超时时间等等。</p>
<p>关于NSURLConnection有三种方式可以发送请求，前面同步版本我们已经看过了，下面是异步和使用协议的方式：</p>
<pre><code>[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) {

}];
</code></pre><p>协议：</p>
<pre><code><span class="comment">//实现NSURLConnectionDataDelegate协议</span>

<span class="built_in">NSURLConnection</span> *connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];
[connection start];

<span class="comment">//常用的需要实现下面四种方法</span>

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error
{
    <span class="comment">//请求超时，错误的时候</span>
}

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response
{
    <span class="comment">//服务器第一次响应一个response的时候</span>
}

-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data
{
    <span class="comment">//传输数据</span>
}

-(<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection
{
    <span class="comment">//完成的时候</span>
}
</code></pre><p>对于某些任务，比如下载图片，文件等等大数据的时候，可以使用一个临时会话来启动一个请求，也就是构造一个NSURLSession。</p>
<pre><code><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];
<span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];
<span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) {

    <span class="comment">//请求的结果</span>
}];
[task resume];
</code></pre><p>临时会话的好处是每一个都不是在主线程执行，写的代码量比较少，适合简单的任务。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="http://nshipster.cn/nsurl/" target="_blank" rel="external">NSURL/NSURLComponents</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLRequest_Class/" target="_blank" rel="external">NSURLRequest</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURL_Class/index.html" target="_blank" rel="external">NSURL</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/index.html" target="_blank" rel="external">NSURLConnection</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="external">NSURLSession</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLResponse_Class/index.html" target="_blank" rel="external">NSURLResponse</a></li>
<li><a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">从 NSURLConnection 到 NSURLSession</a></li>
<li><a href="http://ubluesky.com/archives/55" target="_blank" rel="external">NSURL详解</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NSString" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/18/NSString/" class="article-date">
  	<time datetime="2015-04-18T15:05:37.000Z" itemprop="datePublished">2015-04-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/18/NSString/">NSString</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>NSString是我学习的第一个类，它是iOS中专门处理字符串的一个类，包括有从文件读取，从网络读取，标准C的转换，格式化，大小写转换，查询，写入文件等，当然它也有一个对应的Mutable。</p>
<p><strong>优化指南：尽早开启ARC，以下都是ARC版</strong></p>
<p>要使用NSString有三种方式，第一种语法糖方式，第二种alloc方式，第三种使用类方法方式。</p>
<pre><code><span class="built_in">NSString</span> *str = <span class="string">@""</span>;
<span class="built_in">NSString</span> *str1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>,<span class="string">@"hello"</span>];
<span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,<span class="string">@"hello"</span>];
</code></pre><p>开发中用语法糖或者类方法的方式比较多</p>
<h3 id="NSString常用">NSString常用</h3><p>查询前缀，后缀</p>
<pre><code>NSString *<span class="keyword">str</span> = @<span class="string">"http://lcepy.github.io"</span>;
BOOL isF = [<span class="keyword">str</span> hasPrefix:@<span class="string">"http"</span>];
BOOL isL = [<span class="keyword">str</span> hasSuffix:@<span class="string">"io"</span>];
</code></pre><p>创建格式化字符串</p>
<pre><code><span class="built_in">NSString</span> *formatter = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://%@"</span>,<span class="string">@"lcepy.github.io"</span>];
<span class="built_in">NSString</span> *formatter1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"http://%@"</span>,<span class="string">@"lcepy.github.io"</span>];
</code></pre><p>从网络读取以及响应，当然很少有人会这么干PS :会block主线程</p>
<pre><code><span class="built_in">NSURL</span> *urlS = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://lcepy.github.io"</span>];
<span class="built_in">NSString</span> *urlStr = [<span class="built_in">NSString</span> stringWithContentsOfURL:urlS encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
<span class="built_in">NSString</span> *urlStr1 = [[<span class="built_in">NSString</span> alloc] initWithContentsOfURL:urlS encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
[urlStr writeToURL:urlS atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
</code></pre><p>从本地文件中读取以及写入</p>
<pre><code><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"lcepy"</span> ofType:<span class="string">@"html"</span>];
<span class="built_in">NSString</span> *fileStr = [<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
<span class="built_in">NSString</span> *fileStr1 = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
[fileStr writeToFile:str atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];
</code></pre><p>字符串的比较，因为OC是C语言的超集，所以字符串有两种比较方式，指针一样，还有指针一样内容一样的比较，而==一般都不建议使用，它比较的是引用，NSString有它的比较方法。</p>
<pre><code>isEqualToString

<span class="type">NSString</span> *astring01 = @<span class="string">"This is a String!"</span>;
<span class="type">NSString</span> *astring02 = @<span class="string">"This is a String!"</span>;
<span class="type">BOOL</span> <span class="literal">result</span> = [astring01 compare:astring02] == <span class="type">NSOrderedSame</span>;    //<span class="type">NSOrderedSame</span>判断两者内容是否相同
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,<span class="literal">result</span>);
<span class="type">BOOL</span> result1 = [astring01 compare:astring02] == <span class="type">NSOrderedAscending</span>;    //<span class="type">NSOrderedAscending</span>判断两对象值的大小(按字母顺序进行比较，astring02大于astring01为真)
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,result1);
<span class="type">BOOL</span> result2 = [astring01 compare:astring02] == <span class="type">NSOrderedDescending</span>;    //<span class="type">NSOrderedDescending</span>判断两对象值的大小(按字母顺序进行比较，astring02小于astring01为真)
<span class="type">NSLog</span>(@<span class="string">"result:%d"</span>,result2);
</code></pre><p>大小写以及首字母大写</p>
<pre><code><span class="built_in">NSString</span> *io = <span class="string">@"hello"</span>;
<span class="built_in">NSString</span> *IO = <span class="string">@"HELLO"</span>;
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[io uppercaseString]);
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[IO lowercaseString]);
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[io capitalizedString]);
</code></pre><p>查询截取PS—&gt;<strong>我觉得NSString使用最频繁的一处，查询截取是在开发中无法避免的事项，它非常有用</strong>其实，在使用查询这一系列的方式时，它和NSRange有紧密相连的关系。NSRange是一个结构体，用来描述起始位置，以及计数。</p>
<pre><code><span class="built_in">NSString</span> *str = <span class="string">@"http://lcepy.github.io"</span>;
<span class="built_in">NSRange</span> httpRange =  [str rangeOfString:<span class="string">@"http"</span>]; <span class="comment">//返回一个range结构体</span>
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromRange</span>(httpRange));


<span class="built_in">NSRange</span> ioRange = [str rangeOfString:<span class="string">@"io"</span>];
<span class="built_in">NSString</span> *subs = [str substringWithRange:<span class="built_in">NSMakeRange</span>(ioRange<span class="variable">.location</span>, ioRange<span class="variable">.length</span>-<span class="number">1</span>)]; <span class="comment">//从指定位置开始截取字符串</span>
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,subs);

<span class="comment">//从字符串开头一直截取到指定位置</span>
<span class="built_in">NSString</span> *indexStr = [str substringToIndex:<span class="number">4</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,indexStr);

<span class="comment">//从指定位置开始截取到最后的字符串（包括）</span>
<span class="built_in">NSString</span> *lastStr = [str substringFromIndex:<span class="number">4</span>];
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,lastStr);
</code></pre><p>扩展路径以及获取扩展文件名</p>
<pre><code><span class="built_in">NSString</span> *doc = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)[<span class="number">0</span>];
<span class="built_in">NSString</span> *filePath = [doc stringByAppendingPathComponent:<span class="string">@"PhotoCache"</span>];
<span class="built_in">NSString</span> *file = <span class="string">@"~/lcepy.io"</span>;
<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[file pathExtension]);
</code></pre><h3 id="NSMutableString常用">NSMutableString常用</h3><p>注意PS—&gt;<strong>NSString可以使用的方法，Mutable版全部具备，Mutable版的方法，NSString不一定有</strong></p>
<p>在字符串最后插入或者格式化插入字符串</p>
<pre><code>NSMutableString *str1 = [NSMutableString <span class="string">stringWithString:</span>@<span class="string">"http://lcepy.github.io"</span>];
[str1 <span class="string">appendString:</span>@<span class="string">"#login"</span>];
[str1 <span class="string">appendFormat:</span>@<span class="string">"%@"</span>,@<span class="string">"#login"</span>];
NSLog(@<span class="string">"%@"</span>,str1);
</code></pre><p>在指定的位置插入字符串</p>
<pre><code><span class="list">[<span class="keyword">str1</span> insertString:@<span class="string">"?id=fjdkfjkgfgi384jkg"</span> atIndex:str1.length]<span class="comment">;</span>
NSLog<span class="list">(<span class="keyword">@</span><span class="string">"%@"</span>,str1)</span><span class="comment">;</span></span>
</code></pre><p>在指定的范围内替换</p>
<pre><code>NSRange login = [str1 <span class="string">rangeOfString:</span>@<span class="string">"#login"</span>];
[str1 <span class="string">replaceCharactersInRange:</span>login <span class="string">withString:</span>@<span class="string">"#logou"</span>];
NSLog(@<span class="string">"%@"</span>,str1);
</code></pre><p>延伸阅读：</p>
<ul>
<li><a href="http://blog.devtang.com/blog/2012/02/14/nsstring-java-like-wrapper/" target="_blank" rel="external">给NSString添加java风格：（感觉有点意思）</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html" target="_blank" rel="external">NSString</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-NSURLProtocol" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/13/NSURLProtocol/" class="article-date">
  	<time datetime="2015-04-13T03:38:06.000Z" itemprop="datePublished">2015-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/13/NSURLProtocol/">NSURLProtocol</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读资料：</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtocol_Class/index.html" target="_blank" rel="external">Apple Foundation NSURLProtocol</a></li>
<li><a href="http://nshipster.cn/nsurlprotocol/" target="_blank" rel="external">http://nshipster.cn/nsurlprotocol/</a></li>
</ul>
<p>正如NSHipster在上篇文章所写的一样，iOS离不开网络，那么这就需要网络编程。cocoa提供了一系列的API来操作网络，比如NSURL，NSURLRequest，NSURLSession等等，以及处理网络的GCD，NSOperation多任务处理。</p>
<p>那么NSURLProtocol，它有什么用呢？官方给它的解释是，可以重新定义已经加载的URL的行为或者定义一个新的URL。换句话来说，就是这个类可以监管应用的网络活动，只要是通过URL来进行的。</p>
<p>NSURLProtocol是一个抽象类，也就是说它需要一个子类继承它才可以正常工作，关于怎么使用可以阅读NSHipster的文章，把子类注册到NSURLProtocol中。</p>
<pre><code>+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">consolelog</span>:<span class="value">(UITextView *)debugText
{
    debug = debugText</span></span>;
    <span class="attr_selector">[NSURLProtocol registerClass:self]</span>;
}
</code></pre><h3 id="案例需求，监管应用的URL加载系统，并且支持web_client_console_log">案例需求，监管应用的URL加载系统，并且支持web client console log</h3><p>案例可以在Github中查看<a href="https://github.com/lcepy/MFLog" target="_blank" rel="external">MFLog</a></p>
<pre><code>+ <span class="comment">(BOOL)</span>registerClass:<span class="comment">(Class)</span>protocolClass
</code></pre><p>把子类注册到NSURLProtocol中</p>
<pre><code>+ (<span class="keyword">void</span>)unregisterClass:(<span class="keyword">Class</span>)protocolClass
</code></pre><p>把子类从NSURLProtocol中移除</p>
<p>NSURLProtocol提供了一系列的方法来操作一个URL Data，先看其一，一个静态方法。</p>
<pre><code>+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request
</code></pre><p>canInitWithRequest <strong>注意，这些是覆盖父类NSURLProtocol的静态方法</strong>是系统询问，是否处理该请求URL，如果返回NO，不处理。如果返回YES，子类进一步控制。</p>
<pre><code>+ <span class="list">(<span class="keyword">NSURLRequest</span> <span class="variable">*)canonicalRequestForRequest:(NSURLRequest *</span>)</span>request
</code></pre><p>返回请求的原始request</p>
<pre><code>- <span class="list">(<span class="keyword">void</span>)</span>startLoading
</code></pre><p>加载此次请求，可以通过self.request获取当前URL的request对象</p>
<pre><code>- <span class="list">(<span class="keyword">void</span>)</span>stopLoading
</code></pre><p>此次请求完成时，可以在这个方法中处理</p>
<p>每一个NSURLProtocol都有一个client属性，这个属性是NSURLProtocolClient。另外，还可以实现NSConnectionDataDelegate协议，把NSURLProtocol与NSURLConnection链接起来，这样就可以在statLoading调用之后，系统将回调NSConnectionDataDelegate中定义的各种方法，这个在自定义时非常有用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-纪录开发第一个iOS客户端遇见的坑" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/28/纪录开发第一个iOS客户端遇见的坑/" class="article-date">
  	<time datetime="2015-03-28T06:51:34.000Z" itemprop="datePublished">2015-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/28/纪录开发第一个iOS客户端遇见的坑/">纪录开发第一个iOS客户端遇见的坑</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>来到新公司做的第一个产品就是iOS客户端，我负责的是基于LeanCloud SDK开发的售后服务IM系统，也就是一个聊天的模块。第一次比较纯粹的在工作中，写Objective-c，遇到了一些坑，解决之后才发现原来是这么回事，而且还复习了它的基础语法知识。</p>
<p><strong>block的问题</strong></p>
<p>引用资料：</p>
<ul>
<li><a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C Block的实现</a></li>
<li><a href="http://www.cnbluebox.com/?p=255" target="_blank" rel="external">Block防止循环引用</a></li>
</ul>
<p>本来我想使用Block来解决通信的问题，后来我发现语法以及对Block的理解有些忘记了。基础不扎实，带来了严重的后果。Block使用^来声明，用;来结束一个完整的Block，缺一不可。</p>
<pre><code><span class="keyword">void</span> (^ blockde)(<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> *test1,<span class="built_in">NSString</span> *test2){
    <span class="built_in">NSString</span> *log = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@,%@"</span>,test1,test2];
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,log);
};
</code></pre><p>Block的语法有些难度，特别是灵活运用的时候，但是记住一点，先声明返回值，然后两个括号用来描述这个Block的签名，以及参数类型，如果是OC对象，需要写上指针符号。如果没有签名，可以什么也不写。<strong>有一个情况例外，利用typedef定义的block必须写上签名</strong></p>
<p>我想在动态方法中提供一个Block来处理一些事情，定义它有两种写法。</p>
<p>第一种写法是利用typedef定义一个别名，描述还是第一项声明返回值参数，第二项别名签名，第三项传入的参数类型。</p>
<pre><code><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(^handlerBlock)(<span class="built_in">NSDictionary</span> * dic,<span class="built_in">NSArray</span> * arr);

-(<span class="keyword">void</span>)sendMessageText:(handlerBlock)block
{
    block();
}
</code></pre><p>第二种写法是直接写在动态方法中，方法的参数形式一般都是()名字，所以block的声明就要写在一个圆括号中，这种写法可以省略block的签名。</p>
<pre><code>-<span class="params">(void)</span>setSource:<span class="params">(NSString *)</span> source andBlock:<span class="params">(void<span class="params">(^)</span><span class="params">(NSString *treme)</span>)</span> block
{
    block<span class="params">()</span>;
}
</code></pre><p>因为公司的项目都是ARC的，所以copy就省略了，其他方面主要是需要避免循环引用的问题，比如使用__weak关键字给self对象。</p>
<p><strong>导入第三方库的问题</strong></p>
<p>这个IM模块是基于第三方SDK实现的，所以需要导入第三方库，在这里也踩了下坑。LeanCloud依赖了其他五个框架，需要手动的添加到Link Binary With Libraries中，必须得承认学艺不精的后果是这个编译的错，琢磨了很久，而且还需要把openssl的include的路径添加到Head中。</p>
<p>关于Xcode的使用，一定要把cocoaChina的那个Xcode系列阅读完。</p>
<p><strong>开发者证书的问题</strong></p>
<p>根据以往的经验想真机调试，那就必须的添加开发者证书，于是按照老旧的流程，去<a href="https://developer.apple.com/account/ios/certificate/certificateList.action" target="_blank" rel="external">https://developer.apple.com/account/ios/certificate/certificateList.action</a> 下载证书，然后添加设备UID，接着添加Profile一路Next。</p>
<p>现在这些步骤真的不需要了，在Xcode中登录自己的Apple ID，然后在项目的Team选项中选择正确的签名，Xcode自动下载，自动匹配设备UID，一切自动化，当然首先要把设备连接好。</p>
<p>它不是坑，而是因为自己不知道，在安装证书时发现了现在有这么方便的流程。    </p>
<p><strong>访问相册或者摄像头返回给web端</strong>    </p>
<p>引用资料：</p>
<ul>
<li><a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="external">GCD</a></li>
</ul>
<p>在拿到图片image对象后，怎么处理，是一个非常头疼的问题。LeanCloud的AVIMImageMessage类需要的是一个filePath而不是UIImage或者NSData对象，iOS应用是没有权限访问应用沙盒之外的东西的。首先想到的解决办法是把这个UIImage写入到应用内的Documents目录下的Photos目录，然后把这个地址发送给AVIMImageMessage对象。考虑到文件IO操作，还会对应用界面卡顿，所以把这个任务委托给了GCD去调度。</p>
<p>在使用dispatch_async之前，还需要处理一个问题，那就是UI展示的问题。大坑在这里，我们的UI是web的。所以对于图片，调用UIImageJPEGRepresentation去压缩体积，然后再转成base64，把这个base64发送给客户端。</p>
<p>为什么说这里是坑呢？因为它是一个IM系统，操作会非常的频繁，最关键的是展示是在web中，它的交互流程很坑。</p>
<p><strong>文件处理</strong></p>
<ul>
<li><a href="http://nshipster.cn/nsfilemanager/" target="_blank" rel="external">NSFileManager</a></li>
</ul>
<p>针对每一个用户都应该在应用沙盒内有它对应的一个缓存文件，它必须写入在Documents目录下，当人在获取之前，可以先判断一下，文件是否存在。</p>
<p><strong>使用ionic添加插件时的巨坑</strong></p>
<p>在升级了ionic为1.3.18之后，它的plugin编译时需要手动添加，据说这个版本他们去掉了自动添加的模块，于是写在配置文件中的插件，需要在platform add ios后，再ionic plugin add im手动添加到编译环境中，每一个都需要重复上述的动作，最后ionic build ios。</p>
<p>希望下一个版本，ionic能把这个补上吧。</p>
<p><strong>debug模式|重构IM|Date处理</strong></p>
<p>debug workflow 如果选择了汇编debug，进入的是直接查看内存地址的debug模式，这种模式某些情况下有用。本来使用web来写IM我们发现它的性能实在是不能忍受，于是用OC把它重构了。</p>
<p>使用NSDate来处理时间的时候，还需要NSDateFormatter来格式化，而且拿到的毫秒还需要除以1000，因为OC只处理秒单位。</p>
<p><strong>代码布局聊天界面的cell</strong></p>
<p>利用CGFloat mainScreenWidth = [UIScreen mainScreen].bounds.size.width来获取屏幕的宽度，然后计算自定义的cell，统计出来一个高度，在-(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath 返回给TableView。</p>
<pre><code>-(<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    MissIMFrame *missIMFrame = [<span class="keyword">self</span><span class="variable">.modelManager</span><span class="variable">.dataSource</span> objectAtIndex:indexPath<span class="variable">.row</span>];
    <span class="keyword">return</span> missIMFrame<span class="variable">.cellHeight</span>;
}
</code></pre><p><strong>解析历史纪录</strong></p>
<p>第三方的leanCloud拉取的历史纪录全部是字符串，还要进一步的处理，转成JSON，这个地方主要是使用了NSJSONSerialization来处理，判断解析的错误，如果错误了，说明它是一个真正的文本，如果是正确的，那么说明它是一个可以转化为字典的字符串，然后再进一步处理。</p>
<p><strong>滚动上拉加载历史纪录</strong></p>
<p>实现scrollView的三个协议</p>
<pre><code>-(<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView
{
    <span class="comment">//手指触摸屏幕，准备滚动的那一刻</span>
    <span class="built_in">NSLog</span>(<span class="string">@"手指滑动开始－－－－－的那一瞬间"</span>);
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(scrollView<span class="variable">.contentOffset</span>));
}

-(<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset
{
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(scrollView<span class="variable">.contentOffset</span>));
}

-(<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate
{
    <span class="comment">//手指离开屏幕，放下的那一刻</span>
    <span class="built_in">NSLog</span>(<span class="string">@"刷动到顶部，放下的时候"</span>);
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(scrollView<span class="variable">.contentOffset</span>));
    <span class="keyword">if</span> (scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span> &lt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span><span class="variable">.historyTimeId</span> &gt; <span class="number">0</span>) {
        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isScroll</span>) {
            <span class="keyword">self</span><span class="variable">.application</span><span class="variable">.networkActivityIndicatorVisible</span> = <span class="literal">YES</span>;
            [<span class="keyword">self</span><span class="variable">.mainUI</span><span class="variable">.MissIMActivity</span> startAnimating];
            <span class="keyword">self</span><span class="variable">.isScroll</span> = <span class="literal">NO</span>;
            [<span class="keyword">self</span> fetchHistoryMessage:<span class="keyword">self</span><span class="variable">.conversationId</span> timeId:<span class="keyword">self</span><span class="variable">.historyTimeId</span>];
        }
    }
}
</code></pre><p><strong>UIApplication</strong></p>
<p>在info.plist文件中设置Application dose not run is background 设置为YES，就可以在应用退出的时候进行存盘了</p>
<p><strong>Category添加自定义属性</strong></p>
<p>分类只能在运行时，利用它的机制，动态的添加属性，使用@dynamic关键字，和两个函数objc_setAssociatedObject，objc_getAssociatedObject。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 icepy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?16dce8818578643d2c8f0ed9bc5696ec";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>