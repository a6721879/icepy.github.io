<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[lcepy]]></title>
  <subtitle><![CDATA[曾记否，到中流击水，浪遏飞舟!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://lcepy.github.io/"/>
  <updated>2015-01-28T11:42:39.879Z</updated>
  <id>http://lcepy.github.io/</id>
  
  <author>
    <name><![CDATA[lcepy]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[复习JavaScript六之事件]]></title>
    <link href="http://lcepy.github.io/2015/01/27/%E5%A4%8D%E4%B9%A0JavaScript%E5%85%AD%E4%B9%8B%E4%BA%8B%E4%BB%B6/"/>
    <id>http://lcepy.github.io/2015/01/27/复习JavaScript六之事件/</id>
    <published>2015-01-27T10:08:04.000Z</published>
    <updated>2015-01-28T11:42:03.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>IE浏览器的事件不是复习的重点</p>
</blockquote>
<p>事件是JavaScript与HTML进行交互的一个纽带，理解事件可以更好的处理Web应用程序，现在的浏览器中主要支持两种事件流：</p>
<ul>
<li>事件冒泡</li>
<li>事件捕获</li>
<li>DOM事件流</li>
</ul>
<p>事件冒泡则是指事件开始时由具体的元素接收，然后逐级向上传播。比如：</p>
<pre><code><span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span>&gt;</span>
            <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>给p标签监听一个事件，它的流向是p,div,body,html,document，其实细心看来这种流的走向会存在一个问题，给div也监听一个事件，当用户点击P的时候是会触发两次的，好在event对象中有可以阻止事件冒泡的方法。</p>
<p>事件捕获则是指事件由最上级接收，逐级向下传播到具体的元素上，了解了冒泡之后这个就非常好理解了，正是一个相反的步骤。</p>
<p>而DOM事件流又正好是冒泡与捕获的结合体，它分为三个阶段：事件捕获，目标事件，事件冒泡，如果在纸上画出来，它的走向就是一个圆形。</p>
<blockquote>
<p>对于事件处理程序，写在HTML标签中的，另外一种是直接写一个function的，比如doc.onclick = function(){}，一般来说这些浏览器支持，但是基本上不会使用了。因为前者是跟HTML耦合的，不利代码维护，而且虽然HTML加载了但是Js文件还未加载，用户点击后，是直接报错的。后者虽然也可以删除，比如doc.onclick = null，对于对代码有强迫症的同学，基本上不会使用到它。</p>
</blockquote>
<p>那么，我们该怎么给一个元素添加上事件处理程序呢？</p>
<h3 id="DOM2级事件处理程序">DOM2级事件处理程序</h3>
<ul>
<li>addEventLister</li>
<li>removeEventLister</li>
</ul>
<p>所有的DOM节点都具备这两个方法，它接收三个参数：</p>
<ul>
<li>要处理的事件名称，比如click（这里跟上述两个以及IE注册事件都不同，不需要on）</li>
<li>需要事件进行处理的函数</li>
<li>一个布尔值，表示（true，在捕获阶段调用事件处理函数）（false，在冒泡阶段调用事件处理函数）</li>
</ul>
<blockquote>
<p>一般情况下第三个参数都填false</p>
</blockquote>
<p>IE浏览器对应的两个方法，attachEvent，detachEvent，它们只有冒泡，事件名要加上on。</p>
<h3 id="事件对象">事件对象</h3>
<p>在注册完事件处理程序后，事件的一个比较重要的对象必须要理解，<strong>event事件对象</strong>。</p>
<p>一般来说，这个对象中包含着所有与当前元素所监听的事件有关的信息，比如元素监听的事件类型，元素本身等等。</p>
<p><strong>比较重要的属性和方法（只读）</strong></p>
<ul>
<li>currentTarget 真正监听事件的那个元素</li>
<li>target 事件的目标元素</li>
<li>type 事件的类型</li>
<li>perventDefault()  取消事件的默认行为</li>
<li>stopPropagation()  取消事件的捕获或者冒泡</li>
<li>bubbles 事件是否冒泡</li>
<li>eventPhase 事件处理程序的三个阶段，1捕获2处于目标3冒泡</li>
</ul>
<p><strong>比较重要的属性和方法（读写）</strong></p>
<ul>
<li>clientX 鼠标在窗口中的水平位置</li>
<li>clientY 鼠标在窗口中的垂直位置</li>
</ul>
<h3 id="事件类型">事件类型</h3>
<blockquote>
<p>PC端主要是针对鼠标，移动端则是触摸，手势相关的处理</p>
</blockquote>
<p>如果在PC端上发生一次click事件，实际上它是发生了三次事件，mousedown当鼠标按下的时候，mouseup当用户放开的时候，click两个加起来就发生了一次click事件。相对于移动，PC上的鼠标事件非常的丰富，例如mouseover当鼠标首次移入一个元素边界时触发，mouseout当鼠标移出元素时触发，这个移出，到子元素上也会触发这个事件，mousemove当鼠标在元素内移动时重复触发。</p>
<p>总体来说对于文档加载，表单控件，窗口大小改变等事件，比如获取焦点，在失去或者获取焦点是值改变等移动上都是一样的，focus（获得焦点）blur（失去焦点）。</p>
<p>在做一些视差滚动的效果时scroll事件是非常好用，移动上在css中提供了一个类似的属性。</p>
<p>唯一的区别是移动端上没有键盘事件。</p>
<h3 id="移动事件">移动事件</h3>
<ul>
<li>touchstart 当手指触摸到屏幕时触发</li>
<li>touchmove 当手指在屏幕上连续滑动时触发</li>
<li>touchend 当手指从屏幕上移开时触发</li>
<li>touchcancel 当系统停止跟踪触摸时触发（这个事件没有确定的触发时间）</li>
</ul>
<p>它们都是冒泡的，也可以取消</p>
<p><strong>三个跟踪触摸事件的属性</strong></p>
<ul>
<li>touches 当前跟踪触摸操作的touch数组，在touchend事件中为空</li>
<li>targetTouchs 特定事件目标的touch数组</li>
<li>ChangedTouches 上次触摸时发生了什么改变的touch数组</li>
</ul>
<p><strong>移动event事件对象</strong></p>
<p>PC上存在的，在移动上也存在，描述上有差异，比如</p>
<ul>
<li>target 触摸的DOM节点目标</li>
<li>pageX 触摸目标在页面中的X坐标</li>
<li>pageY 触摸目标在页面中的Y坐标</li>
</ul>
<p><strong>一些手势</strong></p>
<ul>
<li>gesturestart 当一个手指按在屏幕上另外一个手指又触摸屏幕时触发</li>
<li>gesturechange 依赖前者当其中的一个手指发生改变时触发</li>
<li>gestureend 当任何一个手指离开时触发</li>
</ul>
<p><strong>移动手势干货三部曲</strong></p>
<p><a href="http://www.cnblogs.com/pifoo/archive/2011/05/23/webkit-touch-event-1.html" target="_blank" rel="external">对于Touch的处理</a></p>
<p><a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-2.html" target="_blank" rel="external">处理简单手势</a></p>
<p><a href="http://www.cnblogs.com/pifoo/archive/2011/05/22/webkit-touch-event-3.html" target="_blank" rel="external">处理复杂手势</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>IE浏览器的事件不是复习的重点</p>
</blockquote>
<p>事件是JavaScript与HTML进行交互的一个纽带，理解事件可以更好的处理Web应用程序，现在的浏览器中主要支持两种事件流：</p>
<ul>
<li>事件冒泡</li>]]>
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript五之面向对象的程序设计]]></title>
    <link href="http://lcepy.github.io/2015/01/26/%E5%A4%8D%E4%B9%A0JavaScript%E4%BA%94%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://lcepy.github.io/2015/01/26/复习JavaScript五之面向对象的程序设计/</id>
    <published>2015-01-26T06:52:39.000Z</published>
    <updated>2015-01-27T10:04:38.000Z</updated>
    <content type="html"><![CDATA[<p>面向对象的语言有一个非常明显的标志：类，通过类来创建任意多个具有相同属性和方法的对象，可惜的是Js里没有这样的概念。</p>
<p>但是Js有一个特性：一切皆是对象。</p>
<p>聪明的开发者通过这些特性进行摸索，于是迂回发明了一些程序设计，以便更好的组织代码结构。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>主要是用来解决有多个相同属性和方法的对象的问题，可以用函数来封装特定的接口来实现</p>
<pre><code><span class="keyword">var</span> computer = <span class="function"><span class="keyword">function</span><span class="params">(name,version)</span></span>{
    <span class="keyword">return</span> {
        <span class="string">'name'</span>:name,
        <span class="string">'version'</span>:version,
        <span class="string">'showMessage'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            alert(<span class="keyword">this</span>.name);
        }
    }
}
<span class="keyword">var</span> test = computer(<span class="string">'apple'</span>,<span class="string">'11.1'</span>);
test.showMessage();
</code></pre><h3 id="构造函数模式">构造函数模式</h3>
<p>我们知道像原生的构造函数，比如Object，Array等，它们是在运行时自动出现在执行环境中的。因此，为了模仿它，这里也可以通过一个普通的函数，并且new出一个对象，这样就成为了自定义的构造函数，也可以为他们添加自定义的属性和方法。</p>
<p>但是这样的构造函数有一个缺陷，就是每个方法都会在每个实例上创建一次，因为每次创建都需要分配内存空间，但是有时候这样的特性还是有用的，主要是要控制它们，在不使用的时候释放内存。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name,version)</span></span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.version = version;
    <span class="keyword">this</span>.showMessage = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="keyword">this</span>.name);
    }
}

<span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>,<span class="number">2014</span>);
<span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>,<span class="number">2010</span>);
apple.showMessage();
dell.showMessage();
</code></pre><p>像apple，dell是通过Computer实例化出来的不同的对象，但是它们的constructor都是指向Computer的。这里也可以使用instanceof来对（对象）进行检测。</p>
<p>在书写上构造函数跟其他函数是没有什么区别的，主要的区别还是在使用上，构造函数需要使用new操作符。</p>
<p>其实这样的书写，已经跟类没有什么区别了，表面上来看，而构造函数我个人更倾向于一个类的某个静态方法。</p>
<h3 id="原型模式">原型模式</h3>
<p>说到原型模式就不得不提一提关于指针的问题，因为每一个函数都有一个prototype属性，而这个属性是一个指针，指向一个对象。</p>
<p><strong>C语言描述指针，这个在iOS开发中非常重要</strong></p>
<p>比如我先定义一个int类型的指针变量和一个普通的int类型数据，然后给指针变量赋值。</p>
<pre><code><span class="keyword">int</span> *<span class="keyword">p</span>;
<span class="keyword">int</span> <span class="keyword">pp</span> = <span class="number">123</span>;
<span class="keyword">p</span> = &amp;<span class="keyword">pp</span>;
*<span class="keyword">p</span> = <span class="number">999</span>;
<span class="built_in">printf</span>(<span class="string">'%d'</span>,<span class="keyword">pp</span>);
</code></pre><p>*是一个特殊符号用于标明它是一个指针变量。</p>
<p>&amp;是地址符</p>
<p>分析这个就要说到栈内存和堆内存了，比如*p在栈内存中分配了一个地址假设是ff22x0，它还没有空间。而pp存在一个地址ff23x0，并且分配了一个空间存储着123，这个地址是指向这个空间的。</p>
<p>p = &amp;pp 这样的赋值操作，也就是把ff23x0取出来，并且给p分配一个空间把ff23x0存储进去，并且ff22x0指向这个空间。</p>
<p>*p = 999 从这里就可以看出来p操作的是地址，而这个地址不就是ff23x0么，于是pp成了999。</p>
<p>所谓的指针也就是存储着地址的变量。</p>
<p>回到原型上，如果每一个函数中的 prototype属性都是一个指针，实际上它只是一个地址引用着一个空间，而这个空间正是我们写的xxx.prototype.xxx = function(){}这样的代码在运行时分配的空间。那么可见，使用原型的好处是空间只分配一次，大家都是共享的，因为它是指针。</p>
<p>先看一个例子</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.name = name;
}
Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    alert(name);
}

<span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>);
<span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>);
Computer.prototype.isPrototypeOf(apple);
</code></pre><p>在解释这个原型链之前，还要明白Js的一个特性，就是如果自身不存在，它会沿着原型往上查找。它的原理稍微有些绕，Computer自身的prototype是指向它自身的原型对象的，而每一个函数又有一个constructor指向它自身，prototype.constructor又指向它自身。于是Computer的两个实例apple，dell内部有一个<strong>proto</strong>属性是指向Computer.prototype的，最后的结果是它们可以使用showMessage方法。</p>
<p>当然它们还有一个搜索原则，比如在调用showMessage的时候，引擎先问apple自身有showMessage吗？“没有”，继续搜索，apple的原型有吗，“有”，调用。所以从这里可以看出，this.showMessage是会覆盖prototype.showMessage的。</p>
<p>另外还可以使用isPrototypeOf来检测一个对象是否在另一个对象的原型链上，上述的代码返回的是true。</p>
<pre><code>apple.hasOwnProperty(<span class="string">'name'</span>)

apple.hasOwnProperty(<span class="string">'showMessage'</span>)
</code></pre><p>使用hasOwnProperty来检测到底是对象属性还是原型属性，使用this创建的属性是一个对象属性。<br><a id="more"></a></p>
<p>从上面可以看出来原型链的好处，但是它也不是万能的，正因为指针的存在，对于某些引用类型来说这个就非常不好了，我需要保持原对象属性值是每一个对象特有的，而不是共享的，于是把之前的构造函数与原型组合起来，也就解决了这样的问题。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.name = name;
}
Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="keyword">this</span>.name);
}

<span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>);
apple.showMessage();
</code></pre><p>这样的结果是在对象中都会创建一份属于自己的属性，而方法则是共享的。</p>
<p><strong>动态原型模式</strong></p>
<p>有时候遇到某些问题需要动态添加原型，但是实例中是不能添加的，所以绕来一下，在初始化构造函数中添加。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.showMessage !== <span class="string">'function'</span>){
        Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{

        }
    }
}
</code></pre><p>只要初始化了一次，以后就不用修改了。</p>
<h3 id="寄生构造函数模式">寄生构造函数模式</h3>
<p>这种模式的原理就是在一个函数中封装需要创建对象的代码，然后返回它。</p>
<pre><code><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">return</span> {
        <span class="string">'name'</span>:name
    }
}
<span class="keyword">var</span> g = <span class="keyword">new</span> test(<span class="string">'apple'</span>);
<span class="keyword">var</span> f = de(<span class="string">'dell'</span>);
</code></pre><p>看起来它跟工厂模式还是很像的，</p>
<h3 id="稳妥模式">稳妥模式</h3>
<p>这种模式主要是在解决需要安全的环境中使用，一般来说一个类如果不提供getter，setter方法，是不允许直接访问和修改的。</p>
<pre><code><span class="keyword">var</span> computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">var</span> _name = name;
    <span class="keyword">return</span> {
        <span class="string">'getter'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> _name;
        },
        <span class="string">'setter'</span>:<span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
            _name = name;
        }
    }
}
</code></pre><p>这样的方式可以保证属性或者说是数据的安全性，不允许直接随便修改，如果不提供setter方法的话，压根就不允许。</p>
<h3 id="继承">继承</h3>
<p>谈到面向对象，那么就不能不谈谈继承的问题了，而在Js中主要是将原型作为实现继承的主要思路。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="comment">//this.name = name;</span>
}
Computer.prototype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="string">'computer'</span>)
}

<span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{

}
Apple.prototype = <span class="keyword">new</span> Computer();
Apple.prototype.hide = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}
Apple.prototype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="string">'apple'</span>)
}
<span class="keyword">var</span> apple = <span class="keyword">new</span> Apple();
apple.show();
alert(apple <span class="keyword">instanceof</span> Computer);
</code></pre><p>使用这样的方式，实际上是从Computer的实例中先借它的prototype中所有的方法，但是这里会存在几个问题。</p>
<ul>
<li>如果Computer中需要传入参数，比如name，借的时候我根本不知道要传入什么参数。</li>
<li>在Apple中如果要继续给原型添加方法，那么就不能使用字面量的形式了，它会覆盖掉</li>
<li>如果要重写父类中的方法必须要在借prototype之后</li>
<li>那么如何确定原型和实例的关系？貌似用instanceof和isPrototypeOf都会返回true</li>
</ul>
<p><strong>解决问题一如何传入参数</strong></p>
<p>我们知道Js中有两个方法可以改变函数的上下文，apply和call，实际上类就是函数，这里既借属性也借prototype，不就可以解决这样的问题了么。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="comment">//this.name = name;</span>
}
Computer.prototype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="string">'computer'</span>)
}

<span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    Computer.call(<span class="keyword">this</span>,name);
}
Apple.prototype = <span class="keyword">new</span> Computer();

<span class="keyword">var</span> apple = <span class="keyword">new</span> Apple(<span class="string">'apple'</span>);
alert(apple <span class="keyword">instanceof</span> Apple);
alert(apple <span class="keyword">instanceof</span> Computer);
</code></pre><p>在运行时先借prototype，然后再借子类的this，但是这个也有个问题，那就是会调用两次父类。</p>
<p><strong>继承的技巧</strong></p>
<p>还有一种继承是生成一个临时对象，然后临时对象借需要继承的父类的prototype。</p>
<pre><code><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}
    F.prototype = o;
    <span class="keyword">return</span> <span class="keyword">new</span> F();
}

<span class="keyword">var</span> <span class="keyword">parent</span> = {
    <span class="string">'name'</span>:[<span class="string">'lcepy'</span>]
}

<span class="keyword">var</span> game = extend(<span class="keyword">parent</span>);
game.name.push(<span class="string">'wow'</span>);

<span class="keyword">var</span> _game = extend(<span class="keyword">parent</span>);
_game.name.push(<span class="string">'view'</span>);
</code></pre><p>使用这样的方式有个很大的缺陷，那就是不要借属性之类的数据，因为它们是共享的，这是一个浅拷贝，还是因为指针的原因。不过要是继承方法，这种方式很方便。</p>
<p>还有一种方式跟上述类似，主要是封装了一层函数，用来返回对象。</p>
<h3 id="寄生组合继承">寄生组合继承</h3>
<p>这样的方式主要解决的问题是调用两次父类的问题，避免额外的借来的属性或方法。想想看第一次Computer.call(this)，借来了this上的属性或方法，第二次Apple.prototype = new Computer()，又借来了this上的属性或方法，这里的初衷是想借原型，没办法这个是实例，所以该借的不该借的都借来了。那么要避免这样的问题，就要解决继承属性的继承属性，继承原型的继承原型，也不乱借。</p>
<pre><code><span class="keyword">var</span> extendPrototype = <span class="function"><span class="keyword">function</span><span class="params">(sub,supers)</span></span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}
    F.prototype = supers.prototype;
    <span class="keyword">var</span> _f = <span class="keyword">new</span> F();
    _f.constructor = sub;
    sub.prototype = _f;
}
<span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.name = name;
}
Computer.prototype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="keyword">this</span>.name);
}

<span class="keyword">var</span> Apple = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    Computer.call(<span class="keyword">this</span>,name);
}
extendPrototype(Apple,Computer);

<span class="keyword">var</span> apple = <span class="keyword">new</span> Apple(<span class="string">'apple'</span>);
apple.show();
</code></pre><p>第一步把supers的原型赋值给F，第二步创建F的实例，第三步把_f实例的constructor属性修改成子类，第四步把_f实例赋值给子类的prototype。</p>
<p>这样的话就是不该借的也不会继承了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象的语言有一个非常明显的标志：类，通过类来创建任意多个具有相同属性和方法的对象，可惜的是Js里没有这样的概念。</p>
<p>但是Js有一个特性：一切皆是对象。</p>
<p>聪明的开发者通过这些特性进行摸索，于是迂回发明了一些程序设计，以便更好的组织代码结构。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>主要是用来解决有多个相同属性和方法的对象的问题，可以用函数来封装特定的接口来实现</p>
<pre><code><span class="keyword">var</span> computer = <span class="function"><span class="keyword">function</span><span class="params">(name,version)</span></span>{
    <span class="keyword">return</span> {
        <span class="string">'name'</span>:name,
        <span class="string">'version'</span>:version,
        <span class="string">'showMessage'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            alert(<span class="keyword">this</span>.name);
        }
    }
}
<span class="keyword">var</span> test = computer(<span class="string">'apple'</span>,<span class="string">'11.1'</span>);
test.showMessage();
</code></pre><h3 id="构造函数模式">构造函数模式</h3>
<p>我们知道像原生的构造函数，比如Object，Array等，它们是在运行时自动出现在执行环境中的。因此，为了模仿它，这里也可以通过一个普通的函数，并且new出一个对象，这样就成为了自定义的构造函数，也可以为他们添加自定义的属性和方法。</p>
<p>但是这样的构造函数有一个缺陷，就是每个方法都会在每个实例上创建一次，因为每次创建都需要分配内存空间，但是有时候这样的特性还是有用的，主要是要控制它们，在不使用的时候释放内存。</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name,version)</span></span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.version = version;
    <span class="keyword">this</span>.showMessage = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="keyword">this</span>.name);
    }
}

<span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>,<span class="number">2014</span>);
<span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>,<span class="number">2010</span>);
apple.showMessage();
dell.showMessage();
</code></pre><p>像apple，dell是通过Computer实例化出来的不同的对象，但是它们的constructor都是指向Computer的。这里也可以使用instanceof来对（对象）进行检测。</p>
<p>在书写上构造函数跟其他函数是没有什么区别的，主要的区别还是在使用上，构造函数需要使用new操作符。</p>
<p>其实这样的书写，已经跟类没有什么区别了，表面上来看，而构造函数我个人更倾向于一个类的某个静态方法。</p>
<h3 id="原型模式">原型模式</h3>
<p>说到原型模式就不得不提一提关于指针的问题，因为每一个函数都有一个prototype属性，而这个属性是一个指针，指向一个对象。</p>
<p><strong>C语言描述指针，这个在iOS开发中非常重要</strong></p>
<p>比如我先定义一个int类型的指针变量和一个普通的int类型数据，然后给指针变量赋值。</p>
<pre><code><span class="keyword">int</span> *<span class="keyword">p</span>;
<span class="keyword">int</span> <span class="keyword">pp</span> = <span class="number">123</span>;
<span class="keyword">p</span> = &amp;<span class="keyword">pp</span>;
*<span class="keyword">p</span> = <span class="number">999</span>;
<span class="built_in">printf</span>(<span class="string">'%d'</span>,<span class="keyword">pp</span>);
</code></pre><p>*是一个特殊符号用于标明它是一个指针变量。</p>
<p>&amp;是地址符</p>
<p>分析这个就要说到栈内存和堆内存了，比如*p在栈内存中分配了一个地址假设是ff22x0，它还没有空间。而pp存在一个地址ff23x0，并且分配了一个空间存储着123，这个地址是指向这个空间的。</p>
<p>p = &amp;pp 这样的赋值操作，也就是把ff23x0取出来，并且给p分配一个空间把ff23x0存储进去，并且ff22x0指向这个空间。</p>
<p>*p = 999 从这里就可以看出来p操作的是地址，而这个地址不就是ff23x0么，于是pp成了999。</p>
<p>所谓的指针也就是存储着地址的变量。</p>
<p>回到原型上，如果每一个函数中的 prototype属性都是一个指针，实际上它只是一个地址引用着一个空间，而这个空间正是我们写的xxx.prototype.xxx = function(){}这样的代码在运行时分配的空间。那么可见，使用原型的好处是空间只分配一次，大家都是共享的，因为它是指针。</p>
<p>先看一个例子</p>
<pre><code><span class="keyword">var</span> Computer = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.name = name;
}
Computer.prototype.showMessage = <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{
    alert(name);
}

<span class="keyword">var</span> apple = <span class="keyword">new</span> Computer(<span class="string">'apple'</span>);
<span class="keyword">var</span> dell = <span class="keyword">new</span> Computer(<span class="string">'dell'</span>);
Computer.prototype.isPrototypeOf(apple);
</code></pre><p>在解释这个原型链之前，还要明白Js的一个特性，就是如果自身不存在，它会沿着原型往上查找。它的原理稍微有些绕，Computer自身的prototype是指向它自身的原型对象的，而每一个函数又有一个constructor指向它自身，prototype.constructor又指向它自身。于是Computer的两个实例apple，dell内部有一个<strong>proto</strong>属性是指向Computer.prototype的，最后的结果是它们可以使用showMessage方法。</p>
<p>当然它们还有一个搜索原则，比如在调用showMessage的时候，引擎先问apple自身有showMessage吗？“没有”，继续搜索，apple的原型有吗，“有”，调用。所以从这里可以看出，this.showMessage是会覆盖prototype.showMessage的。</p>
<p>另外还可以使用isPrototypeOf来检测一个对象是否在另一个对象的原型链上，上述的代码返回的是true。</p>
<pre><code>apple.hasOwnProperty(<span class="string">'name'</span>)

apple.hasOwnProperty(<span class="string">'showMessage'</span>)
</code></pre><p>使用hasOwnProperty来检测到底是对象属性还是原型属性，使用this创建的属性是一个对象属性。<br>]]>
    
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript四之Object]]></title>
    <link href="http://lcepy.github.io/2015/01/25/%E5%A4%8D%E4%B9%A0JavaScript%E5%9B%9B%E4%B9%8BObject/"/>
    <id>http://lcepy.github.io/2015/01/25/复习JavaScript四之Object/</id>
    <published>2015-01-25T13:42:07.000Z</published>
    <updated>2015-01-26T06:27:02.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript的所有对象都衍生于Object对象，所有对象都继承了Object.prototype上的方法和属性，虽然它们可能会被覆盖，熟悉它对于编程能起到很大的作用，也能比较深刻的了解JavaScript这门语言。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">可参考的资料-Object</a></p>
<p>创建一个对象可以使用new，也可以使用快速创建的方式：</p>
<pre><code><span class="keyword">var</span> _<span class="class"><span class="keyword">object</span> = </span>{};
</code></pre><p>_object对象中就可以使用Object.prototype中所有的方法和属性，虽然看起来它是空的。说到这里在编程中常常有一个非常有用的需求，如何判断一个对象是空对象。</p>
<p>这是zepto中的判断一个对象是否是空对象，常常使用：</p>
<pre><code>$.isEmptyObject = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
    <span class="keyword">var</span> name
    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) <span class="keyword">return</span> <span class="literal">false</span>
    <span class="keyword">return</span> <span class="literal">true</span>
  }
</code></pre><p>也顺便看了下jQuery原理是一模一样的：</p>
<pre><code>isEmptyObject: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{
    <span class="keyword">var</span> name;
    <span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><p>使用in操作符来实现，它不会遍历到父原型链。</p>
<p>constructor返回一个指向创建了该对象的函数引用，这个东西主要是可以用来识别（类）到底是指向哪里的。</p>
<p>defineProperty直接在一个对象上定义一个新属性，非常适合用于动态构建，传入三个参数［动态添加对象的目标对象，需要定义或被修改的属性名，需要定义的对象］，在第三个参数中可以有些属性来表示是否继承（<strong>proto</strong>），要不要定义get，set方法，enumerable是否可枚举。</p>
<p>defineProperties跟上述defineProperty一样，但是它可以添加多个。</p>
<p>getOwnPropertyNames返回一个由指定对象的所有属性组成的数组</p>
<p>keys返回一个数组包括对象所有的属性（可枚举）</p>
<blockquote>
<p>keys是经常会用到的一个属性，它只能包可枚举的，如果想获取一个对象的所有属性包括不枚举的，那么使用getOwnPropertyNames。</p>
</blockquote>
<p>hasOwnProperty用于判断某个对象是否包含有自身的属性，这个方法常常用于检测对象中的属性是否存在，它只检测自身，对于继承过来的都是false，这一点是非常重要的理解。</p>
<p>isPrototypeOf 用于检测一个对象是否在另一个对象的原型链上，比如有两个对象是互相交互的，常常会使用它来进行检测。</p>
<p>propertyIsEnumerable这个方法也比较重要，返回一个布尔值，检测一个对象的自身属性是否可以枚举</p>
<blockquote>
<p>可枚举的理解，也就是对象的属性可枚举，它的属性值不可以修改，但是在Js中它有自己的定义，引擎内部看不见的该属性的[[Enumerable]]特性为true，那么就是可枚举的。基本上把一个普通对象可以看做是一个枚举类型，比如var color = {‘red’:1}，red是可以修改的，但是red是可枚举的，但是如果是继承过来的属性，propertyIsEnumerable是返回false的，它还有一个特点，就是自身。</p>
</blockquote>
<p>如果要定义不可枚举的属性，那就要使用defineProperty方法了，目前不能用对象直接量或者构造函数定义出来。</p>
<pre><code><span class="keyword">var</span> obj = {name: <span class="string">'jack'</span>, age:<span class="number">23</span>}
Object.defineProperty(obj, <span class="string">'id'</span>, {<span class="keyword">value</span> : <span class="string">'123'</span>, enumerable : <span class="keyword">false</span> });
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript的所有对象都衍生于Object对象，所有对象都继承了Object.prototype上的方法和属性，虽然它们可能会被覆盖，熟悉它对于编程能起到很大的作用，也能比较深刻的了解JavaScript这门语言。</p>
<p><a href="https://d]]>
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript三之BOM]]></title>
    <link href="http://lcepy.github.io/2015/01/24/%E5%A4%8D%E4%B9%A0JavaScript%E4%B8%89%E4%B9%8BBOM/"/>
    <id>http://lcepy.github.io/2015/01/24/复习JavaScript三之BOM/</id>
    <published>2015-01-24T14:14:04.000Z</published>
    <updated>2015-01-25T09:48:38.000Z</updated>
    <content type="html"><![CDATA[<p>BOM提供了很多对象，它的核心是window，表示它是浏览器的一个实例，在ECMAScript中又是Global对象。它提供了很多访问浏览器的功能，这些功能与网页无关，所以缺少事实标准的BOM既有意思又有些坑。复习它，主要是复习几个比较有用的对象，其他可以了解一二。</p>
<h3 id="location">location</h3>
<blockquote>
<p>算起来它是我用的最多的一个对象</p>
</blockquote>
<p>它提供了当前窗口加载的页面有关的信息，也对URL进行了片段分解，既是window的属性，也是document的属性。</p>
<ul>
<li>hash 返回URL的散列（#号后面跟着的零个或多个值）</li>
<li>host 返回服务器名称和端口号</li>
<li>hostname 返回不带端口号的服务器名称</li>
<li>href 返回当前加载页面的完整URL</li>
<li>pathname 返回URL中的目录或文件名</li>
<li>port 返回URL中指定的端口号</li>
<li>protocol 返回页面使用的协议</li>
<li>search 返回URL中的查询字符串，它以问好（?）开头</li>
</ul>
<p>上述的属性基本上都可以直接使用，search除外，它返回的是一个完整的查询字符串，没有办法访问其中的每个查询字符串参数，还需要额外的进行处理。</p>
<p>一般来说根据它的特点，?开头&amp;拼接，key=value的形式来展现，最好是key和value都要decodeURIComponent一下。</p>
<p>在location中除了上述的属性外，还有一些比较有用的方法和技巧，主要是用来控制页面跳转的问题。</p>
<ul>
<li>assign方法接收一个参数，表示立即打开一个新的页面并在历史纪录中生成一条记录，它的效果等同于window.location.href = ‘’或者location.href = ‘’</li>
<li>修改location对象的属性比如href，hash，search等也可以来改变URL</li>
<li>replace方法接收一个参数，既跳转到新的URL上，并且不会在历史纪录中增加一条新的纪录</li>
<li>reload表示重新加载当前页面</li>
</ul>
<a id="more"></a>

<h3 id="处理框架，设置时间，open，窗口位置，窗口大小">处理框架，设置时间，open，窗口位置，窗口大小</h3>
<blockquote>
<p>open现在估计没人会用了</p>
</blockquote>
<p>如果页面中包含框架，则每个框架都有自己的window对象，可以使用frames来获取，比如frames[0]或者frames[‘name’]。这里还要了解的是top，parent，对于这些只要理解的层级关系，每一个指向都是会非常清楚的。</p>
<p>在做某些动画效果的时候，主要是针对PC端，可能会使用到窗口位置，窗口大小的属性来进行计算，比如innerWidth，innerHeight，outerWidth，outerHeight，获取到这些尺寸，一般会与当前div的高宽进行减法来获取精准的位置。</p>
<p>setTimeout和setInterval是进行时间调度的函数，我们知道Js是单线程的，但是可以使用这个在特定的时间范围内执行代码，前面一个setTimeout是在指定的时间内执行（只执行一次），后面的setInterval则是以指定的时间重复执行（N次）</p>
<h3 id="navigator">navigator</h3>
<p>用这个一般是在统计用户浏览器版本，操作系统等场景下才用的上，偶尔有几个会比较实用。</p>
<ul>
<li>cookieEnabled 判断cookie是否开启</li>
<li>userAgent 浏览器用户代理字符串</li>
<li>plugins数组 主要是用来检测浏览器安装的插件</li>
</ul>
<h3 id="screen">screen</h3>
<p>在Js中有几个对象在编程里真用不上，这个就是其中之一。它主要是用来表明客户端的能力，比如显示器的信息，像素，高，宽等。</p>
<h3 id="history">history</h3>
<p>history对象保存着用户上网的历史纪录，但是这个也是非常不常用。主要是用go方法，back方法，forward方法。</p>
<blockquote>
<p>说实话，后面三个navigator,screen,history基本上很废材</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>BOM提供了很多对象，它的核心是window，表示它是浏览器的一个实例，在ECMAScript中又是Global对象。它提供了很多访问浏览器的功能，这些功能与网页无关，所以缺少事实标准的BOM既有意思又有些坑。复习它，主要是复习几个比较有用的对象，其他可以了解一二。</p>
<h3 id="location">location</h3>
<blockquote>
<p>算起来它是我用的最多的一个对象</p>
</blockquote>
<p>它提供了当前窗口加载的页面有关的信息，也对URL进行了片段分解，既是window的属性，也是document的属性。</p>
<ul>
<li>hash 返回URL的散列（#号后面跟着的零个或多个值）</li>
<li>host 返回服务器名称和端口号</li>
<li>hostname 返回不带端口号的服务器名称</li>
<li>href 返回当前加载页面的完整URL</li>
<li>pathname 返回URL中的目录或文件名</li>
<li>port 返回URL中指定的端口号</li>
<li>protocol 返回页面使用的协议</li>
<li>search 返回URL中的查询字符串，它以问好（?）开头</li>
</ul>
<p>上述的属性基本上都可以直接使用，search除外，它返回的是一个完整的查询字符串，没有办法访问其中的每个查询字符串参数，还需要额外的进行处理。</p>
<p>一般来说根据它的特点，?开头&amp;拼接，key=value的形式来展现，最好是key和value都要decodeURIComponent一下。</p>
<p>在location中除了上述的属性外，还有一些比较有用的方法和技巧，主要是用来控制页面跳转的问题。</p>
<ul>
<li>assign方法接收一个参数，表示立即打开一个新的页面并在历史纪录中生成一条记录，它的效果等同于window.location.href = ‘’或者location.href = ‘’</li>
<li>修改location对象的属性比如href，hash，search等也可以来改变URL</li>
<li>replace方法接收一个参数，既跳转到新的URL上，并且不会在历史纪录中增加一条新的纪录</li>
<li>reload表示重新加载当前页面</li>
</ul>
]]>
    
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如果宅*纪念]]></title>
    <link href="http://lcepy.github.io/2015/01/23/%E5%A6%82%E6%9E%9C%E5%AE%85-%E7%BA%AA%E5%BF%B5/"/>
    <id>http://lcepy.github.io/2015/01/23/如果宅-纪念/</id>
    <published>2015-01-23T15:37:26.000Z</published>
    <updated>2015-01-23T18:34:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://websources.qiniudn.com/img/mywow.png" alt="青春独醉"></p>
<p>魔兽世界练到100级之后，我竟然一点再玩的想法也没有了，不知道是对游戏不感兴趣了呢，还是自己老了。细数下来，八个角色，只有一个练到了100级，其他的再也不想登陆了。</p>
<p>今天回到家里看见了四年前买的一本书《如果＊宅》，花了一天的时间把它读完了，我才知道我的魔兽世界跟他们一样，一去不可复返了。</p>
<p>2006年的夏天在安江买电脑报里面送了一张体验卡，第一感觉是“这个游戏真牛逼”，比之前玩的传奇要“牛逼”几个档次，当时还是九城，超级大的一个板块，在介绍一个全新的世界。当然，进入游戏断断续续的玩了段时间，高考了。</p>
<p>2008年重新注册了一个账号，在三区天空之墙安家落户了，玩的是法师。那时候YY刚刚流行起来，走在TBC的末期。没有牛逼的人，但是有个牛逼的公会，貌似我忘记发生了什么，2010年的夏天，我又AFKl了。好像是刷马桶刷了一年半，切蛋蛋切了两年多，哈哈，公会的战士，盗贼人手一把蛋刀，我的法师也有了凤凰。让我印象很深刻的是，半夜了，很多人一起在YY聊天，然后在泰卡罗森林的那个鸦人巢穴打生命，刷布，刷材料，那里是要有飞行坐骑才能到，而且还是刷虚空鳐声望的地方。</p>
<p>说起来TBC是我玩的最久，也是最开心的一个版本，感觉每天都很有精力和激情去做每一件事情，比如刷虚空龙，刷乌鸦，刷材料，在拍卖行倒卖物资，代刷破碎，代刷祖尔法拉克，代刷STSM，现在想起来，我也是蛮拼的了。</p>
<p>2013年熊猫人版本，我又重新建了个角色SS，玩到了90级。后续，就成了刷单机，各种随机团，随机副本，玩了玩很没味道，聊天的人都没有了。</p>
<p>2014年德拉若版本练到了100级，这下更好，出了个要塞系统，彻底单机了。</p>
<p>游戏一路在变，人也是一样，发现自己再也没法融入这个世界的圈子了，27岁。</p>
<p>删除客户端，AFK。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://websources.qiniudn.com/img/mywow.png" alt="青春独醉"></p>
<p>魔兽世界练到100级之后，我竟然一点再玩的想法也没有了，不知道是对游戏不感兴趣了呢，还是自己老了。细数下来，八个角色，只有一个]]>
    </summary>
    
      <category term="生活" scheme="http://lcepy.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript二之跨域]]></title>
    <link href="http://lcepy.github.io/2015/01/23/%E5%A4%8D%E4%B9%A0JavaScript%E4%BA%8C%E4%B9%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>http://lcepy.github.io/2015/01/23/复习JavaScript二之跨域/</id>
    <published>2015-01-23T14:17:20.000Z</published>
    <updated>2015-01-23T18:29:07.000Z</updated>
    <content type="html"><![CDATA[<p>客户端Js出于安全的考虑，不允许跨域调用其他页面的对象，正是因为这样才给Ajax带来了很多不方便的地方。跨域最简单的理解就是因为Js同源策略的存在，比如a.com域名下的Js不能访问b.com下的Js对象。</p>
<ul>
<li>协议端口没法跨，客户端</li>
<li>在跨域上，域仅仅是通过首部来识别，window.location.protocol +window.location.host</li>
</ul>
<h3 id="利用document-domain和iframe来设置">利用document.domain和iframe来设置</h3>
<p>对于主域相同而子域名不同的情况，可以通过document.domain来处理，比如www.163.com/index.html和wow.163.com/wower.html，在这两个文件中分别加入document.domain = “163.com”，然后在index.html页面中创建一个iframe引入wower.html，获取iframe的contentDocument，这样这两个js就可以交互了。</p>
<p>index.html</p>
<pre><code><span class="built_in">document</span>.domain = <span class="string">'163.com'</span>;
<span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);
iframe.src = <span class="string">'http://wow.163.com/wower.html'</span>;
iframe.style.display = <span class="string">'none'</span>; 
<span class="built_in">document</span>.body.appendChild(iframe);
iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;
    <span class="comment">//现在可以通过doc来操作wower.html中的js对象了</span>
}
</code></pre><p>wower.html</p>
<pre><code><span class="built_in">document</span>.domain = <span class="string">'163.com'</span>;
</code></pre><p>使用这样的方式来实现的跨域是有限制的</p>
<ul>
<li>主域名必须是同一个</li>
<li>安全性引发的问题，比如第一个页面出现了安全问题，在后面的页面也会出现</li>
<li>iframe引用过多的话，每一个iframe都必须设置document.domain，比较琐碎</li>
</ul>
<blockquote>
<p>偶尔可以使用一下</p>
</blockquote>
<h3 id="利用window-name">利用window.name</h3>
<p>稍微有些绕，但是数据量比较大，也比较安全</p>
<ul>
<li>wow.163.com/app.html 应用所在的页面</li>
<li>wow.163.com/empty.html 中间代理页面，搞个空的即可，但是必须在主域名下</li>
<li>www.qq.com/data.html 需要交互的数据页面</li>
</ul>
<p>在data.html页面中</p>
<pre><code><span class="attribute">window.name </span>=<span class="string"> 123;</span>
</code></pre><p>app.html页面中创建一个隐藏的iframe，它的scr指向data.html，在onload事件中，把当前iframe的contentWindow.loaction修改成empty.html，当再次onload时就可以通过contentWindow.name来获取到123了。</p>
<blockquote>
<p>偶尔使用</p>
</blockquote>
<h3 id="利用iframe和location-hash">利用iframe和location.hash</h3>
<p>利用这种方式，说实话（不建议），比较绕，而且数据量小，直接暴露在URL上。它的原理主要是这样的，假设wow.163.com/index.html页面，wow.163.com/empty.html（空的，什么内容都没有），需要交换数据的页面在www.qq.com/a.html上。</p>
<p>在wow.163.com/index.html#（＃号就是我们要传递的数据），创建一个隐藏的iframe，hash值可以当参数传递给www.qq.com/a.html#()，在www.qq.com/a.html中可以获取到hash值，根据它进行处理，然后在www.qq.com/a.html页面中创建一个隐藏iframe，把处理的结果当hash值进行传递，给wow.163.com/empty.html#()这样，在同一个域名下，wow.163.com/empty.html中的js可以通过parent.parent.location.hash = self.location.hash来改变hash值，这样就达到了跨域的目的。</p>
<blockquote>
<p>不建议使用，坑爹的思路</p>
</blockquote>
<h3 id="JSONP">JSONP</h3>
<p>这种方式是目前开发时最常用的一种方式，利用动态创建script标签来实现跨域的目的，虽然浏览器有显示Js对象的访问，但是它没有限制Js文件的加载，任何域名下的Js文件都可以加载。</p>
<p>对客户端而言，文件的加载其实就是发送一次GET请求，在服务端实现时，也就是处理这次的GET请求，并且响应，参数可以通过?来带走，俗称一波流。</p>
<p>在客户端上对于script文件加载是否已经完毕的判断，IE是判断script标签的readystatechange属性，而其他浏览器是onload事件。</p>
<blockquote>
<p>突然感觉做移动端不考虑IE的兼容，果然是杠杠的，建议使用</p>
</blockquote>
<h3 id="HTML5_postMessage">HTML5 postMessage</h3>
<p>主要是利用window.postMessage来发送消息，监听window.message来获取消息，判断origin可以判断消息来源，data获取消息内容，soucre来引用发送方的window对象引用。</p>
<p>www.b.com/b.html发送消息给www.a.com/a.html</p>
<pre><code><span class="built_in">window</span>.postMessage(<span class="string">'hello'</span>,<span class="string">'www.a.com/a.html'</span>)
</code></pre><p>www.a.com/a.html获取消息</p>
<pre><code><span class="built_in">window</span>.addEventLister(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>{
    <span class="keyword">if</span>(event.origin === <span class="string">'http://b.com'</span>){
        <span class="comment">//处理</span>
    }
})
</code></pre><p>iframe的发送方式</p>
<pre><code>contentWindow.postMessage(<span class="string">'data'</span>,<span class="string">'b.com'</span>)
</code></pre><blockquote>
<p>话不多说，移动端这种跨域方式也很常用（建议推荐使用）</p>
</blockquote>
<h3 id="HTML5_跨域头_XMLHttpRequest2">HTML5 跨域头 XMLHttpRequest2</h3>
<p>如果是自己产品，又是做移动端可以使用，比上述任何方式都要方便，需要服务端支持响应时也要设置跨域头。</p>
<p>如果服务器响应此头，浏览器会检查此头，它的值表示请求内容所允许的域名，也就是如果是*号，表示所有域都可以访问，如果这里是a.com，表示除了同源外，只允许来自a.com域的访问。</p>
<pre><code>Access-<span class="keyword">Control</span>-Allow-Origin：＊
</code></pre><p>如果需要读取cookie则需要设置它</p>
<pre><code>Access-Control-Allow-Credentials:<span class="literal">true</span>
</code></pre><p>设置允许跨域的请求类型</p>
<pre><code>Access-Control-Allow-Method<span class="variable">s:POST</span>
</code></pre><blockquote>
<p>兼容性问题，某些版本的浏览器需要在open之后，设置xhr.withCredentials ＝ true;话不多说，建议推荐使用</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>客户端Js出于安全的考虑，不允许跨域调用其他页面的对象，正是因为这样才给Ajax带来了很多不方便的地方。跨域最简单的理解就是因为Js同源策略的存在，比如a.com域名下的Js不能访问b.com下的Js对象。</p>
<ul>
<li>协议端口没法跨，客户端</li>
<li]]>
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript一之Ajax]]></title>
    <link href="http://lcepy.github.io/2015/01/23/%E5%A4%8D%E4%B9%A0JavaScript%E4%B8%80%E4%B9%8BAjax/"/>
    <id>http://lcepy.github.io/2015/01/23/复习JavaScript一之Ajax/</id>
    <published>2015-01-23T10:07:54.000Z</published>
    <updated>2015-01-23T14:12:26.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>IE8已上，支持现代XMLHttpRequest</p>
</blockquote>
<p>客户端Js与服务器进行网络交互必备的一个玩意，它不支持跨域，若要跨域还需要进行一些额外的处理。</p>
<pre><code><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
</code></pre><p>在使用xhr对象时，要调用的第一个方法是open()，它接受三个参数［发送请求的类型，请求的URL，描述是否同步还是异步的布尔值］false同步，true异步。</p>
<p>关于Ajax同步异步的个人理解：</p>
<ul>
<li>同步，是用数据块的方式来传输的，在Js执行的表现上，当执行到这个Ajax请求时会等待它与服务器交互成功之后才能执行下面一行的代码，也就是阻塞。</li>
<li>异步，是用字节来传输的，它不等待是否成功，会执行之后的代码</li>
</ul>
<p>结束时需要调用xhr.send()，如果没有发送数据的主体，必须要null，做为发送参数。另外在接收到响应之前还可以调用abort()来取消异步请求（不建议调用它）</p>
<h3 id="HTTP状态验证">HTTP状态验证</h3>
<p>当收到响应后会自动填充xhr对象，它有几个比较重要的状态，我们必须要了解清楚与处理。</p>
<ul>
<li>responseText:作为响应主体返回的文本</li>
<li>responseXML:如果响应内容的类型是”text/xml”或者”application/xml”，这个属性中保存的就是XML的DOM文档</li>
<li>status：响应的HTTP状态</li>
<li>statusText：HTTP状态的说明</li>
<li>readyState：用于描述请求发送到完成的过程</li>
</ul>
<p>正常情况下需要检测status === 200 readyState === 4 这就表示responseText或者responseXML中已经填充了全部的数据可以提供给客户端使用了。</p>
<pre><code>1 开头的用于描述请求已经发送，需要请求者继续操作才能继续的状态
2 开头的用于描述请求已经成功
3 开头的用于描述成功，但是还需要继续操作
4 开头的用于描述客户端发送了什么数据导致服务器错误
5 开头的用于描述服务器错误（常见的如，服务端代码抛错了）
</code></pre><p>readyState状态</p>
<pre><code><span class="number">0</span> 未初始化，还没有调用<span class="built_in">open</span>方法
<span class="number">1</span> 已经调用<span class="built_in">open</span>方法，还没有调用<span class="built_in">send</span>方法
<span class="number">2</span> 已经调用<span class="built_in">send</span>方法，但是还没有接收到响应
<span class="number">3</span> 已经接收了部分数据
<span class="number">4</span> 已经接收了全部的数据
</code></pre><h3 id="xhr对象其他方法或事件">xhr对象其他方法或事件</h3>
<p>每一个请求和响应都会带有相应的HTTP头信息，其中对开发者是很有用的，而xhr对象提供了一个setRequestHeader方法来设置头信息，它必须在调用open方法之后并且在send方法之前。有设置，必须得有获取，xhr对象也提供了两个方法分别来获取，getResponseHeader传入一个头部字段名来获取，getAllResponseHeaders来获取全部的头信息。</p>
<p>onreadystatechange事件，每次刷新状态时，系统都会重新调用此事件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>IE8已上，支持现代XMLHttpRequest</p>
</blockquote>
<p>客户端Js与服务器进行网络交互必备的一个玩意，它不支持跨域，若要跨域还需要进行一些额外的处理。</p>
<pre><code><span class="ke]]>
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动H5-HybridApp开发思路的一些总结]]></title>
    <link href="http://lcepy.github.io/2015/01/10/%E7%A7%BB%E5%8A%A8H5-HybridApp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://lcepy.github.io/2015/01/10/移动H5-HybridApp开发思路的一些总结/</id>
    <published>2015-01-10T07:04:24.000Z</published>
    <updated>2015-01-10T08:31:57.000Z</updated>
    <content type="html"><![CDATA[<p>利用H5来开发移动app时，很大一部分的逻辑处理是在每一个视图的切换上，包括维护生命周期，释放内存，以及维护动画。我们在使用iOS时，基本上当前屏幕中内容显示的区域内就应该算是一个视图，当然H5版的app跟纯粹的iOS开发又有一些不同。</p>
<ul>
<li>H5版本的app是一个HTML页面，场景的切换基本上是切换内部的div容器，而当前浏览器内的框架则是它的window</li>
<li>H5版本的app还需要监听hashchange或者history，来维护每一个视图控制器js文件的加载，执行</li>
<li>每一个视图控制器需要维护它自身的生命周期，如创建，渲染视图，添加事件，销毁，以及离开当前视图时等一系列的生命周期</li>
<li>一个视图控制器对应一个视图，一个模型，视图控制器来控制模型的请求，视图的渲染，模型与视图之间互相不干扰</li>
<li>H5版本的app还需要维护一个NavigationController的头，用来控制内容区域内的视图控制器的转换以及它的动画</li>
<li>应用兼容iOS，安卓，WP手持设备的dom兼容库（zepto），以及手势，触摸事件的兼容处理</li>
<li>关于请求还需要维护本地存储与它之间的联系</li>
<li>在Hybrid中，要构建起与原生框架的交互桥梁，比如phoneGap</li>
<li>维护一个UI组件交互的库，比如一些常用的scoll，slider等</li>
</ul>
<p>从上述的一些总结中，可以看的出来要开发基于H5的移动端app，需要做的事情还是有很多的，浓缩的总结有三个方面：</p>
<blockquote>
<p>代码组织，MVC或者MVVM以及它们的生命周期与文件加载</p>
<p>DOM 触摸 手势兼容处理</p>
<p>与Native的交互</p>
</blockquote>
<p>在代码实现的思路上，这里都会使用一个栈来实现它。</p>
<ul>
<li>栈顶属于当前视图控制器</li>
<li>基栈则是根视图控制器</li>
</ul>
<a id="more"></a>

<h2 id="思路实现的假设">思路实现的假设</h2>
<p>每一个视图都会对应一个hash，可以监听window的hashchange事件来获取，而这个hash值做为一个唯一标识，用于map映射到对应的视图控制器实例上。</p>
<p>设计一个大的框架（page）根据功能或者业务划分，每个不同的业务需要使用不同的lcepy.github.io/page1/index.html  lcepy.github.io/page2/index.html，如果hash值为空，则默认为#index。这样的设计主要是考虑内存的消耗，释放的问题。因为业务代码不受约束，如果开发人员没有主动的意识，很可能出现溢出程序崩溃的情况。</p>
<p>每一个视图控制器最少要存在三个方法用于描述它的生命周期：</p>
<ul>
<li><strong>init</strong> 整个视图控制器的入口</li>
<li><strong>hide</strong> 当离开当前视图时执行</li>
<li><strong>viewwillapper</strong> 在创建视图容器时先执行</li>
</ul>
<p>每一个视图控制器最少要存在四个属性用于描述它的视图，标识，模版等：</p>
<ul>
<li><strong>hash</strong> 用于描述它的hash值</li>
<li><strong>view</strong> 存储视图的容器DOM对象</li>
<li><strong>didkeys</strong> 用于描述它创建时的唯一标识，hash值+当前时间的毫秒数</li>
<li><strong>template</strong> 用于描述当前视图的模版</li>
</ul>
<blockquote>
<p>场景假设：用户打开#index，并且点击一个按钮到#push</p>
<p>框架假设：navigationController 简称NC</p>
</blockquote>
<p>最少会执行下面的一些动作，以及可能会使用到下列的一些库：<strong>zepto requrejs template</strong></p>
<p>当客户端呈现#index页面时，会做如下的一些事情：</p>
<ul>
<li>获取hash值index，先检索NC的一个队列中是否存在index，如果不存在则利用requrejs加载index.js文件，map进入NC队列，标示这个文件已经加载，将来不重复加载。</li>
<li>文件加载成功后，可以获取到index视图控制器类，实例化，并把它压入栈，调用viewwillapper，生成一个视图容器</li>
<li>视图容器DOM对象赋值给view</li>
<li>加载的模版字符串赋值给template，并渲染到视图容器中</li>
<li>执行init方法</li>
</ul>
<p>当点击某个按钮，进入#push页面时，会做如下的一些事情：</p>
<ul>
<li>获取hash值并检索NC加载文件，实例化，入栈</li>
<li>调用基栈hide方法，并出栈，然后销毁释放内存</li>
<li>执行呈现#index时的那些动作</li>
</ul>
<p>当然一个比较成熟的项目需要处理的问题，肯定不是现在写的这些。</p>
<p><strong>总结在携程一年（移动开发）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>利用H5来开发移动app时，很大一部分的逻辑处理是在每一个视图的切换上，包括维护生命周期，释放内存，以及维护动画。我们在使用iOS时，基本上当前屏幕中内容显示的区域内就应该算是一个视图，当然H5版的app跟纯粹的iOS开发又有一些不同。</p>
<ul>
<li>H5版本的app是一个HTML页面，场景的切换基本上是切换内部的div容器，而当前浏览器内的框架则是它的window</li>
<li>H5版本的app还需要监听hashchange或者history，来维护每一个视图控制器js文件的加载，执行</li>
<li>每一个视图控制器需要维护它自身的生命周期，如创建，渲染视图，添加事件，销毁，以及离开当前视图时等一系列的生命周期</li>
<li>一个视图控制器对应一个视图，一个模型，视图控制器来控制模型的请求，视图的渲染，模型与视图之间互相不干扰</li>
<li>H5版本的app还需要维护一个NavigationController的头，用来控制内容区域内的视图控制器的转换以及它的动画</li>
<li>应用兼容iOS，安卓，WP手持设备的dom兼容库（zepto），以及手势，触摸事件的兼容处理</li>
<li>关于请求还需要维护本地存储与它之间的联系</li>
<li>在Hybrid中，要构建起与原生框架的交互桥梁，比如phoneGap</li>
<li>维护一个UI组件交互的库，比如一些常用的scoll，slider等</li>
</ul>
<p>从上述的一些总结中，可以看的出来要开发基于H5的移动端app，需要做的事情还是有很多的，浓缩的总结有三个方面：</p>
<blockquote>
<p>代码组织，MVC或者MVVM以及它们的生命周期与文件加载</p>
<p>DOM 触摸 手势兼容处理</p>
<p>与Native的交互</p>
</blockquote>
<p>在代码实现的思路上，这里都会使用一个栈来实现它。</p>
<ul>
<li>栈顶属于当前视图控制器</li>
<li>基栈则是根视图控制器</li>
</ul>
]]>
    
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[this与prototype的区别]]></title>
    <link href="http://lcepy.github.io/2015/01/05/this%E4%B8%8Eprototype%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://lcepy.github.io/2015/01/05/this与prototype的区别/</id>
    <published>2015-01-05T11:15:53.000Z</published>
    <updated>2015-01-05T12:08:36.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>this可以访问私有成员（用var声明的变量）私有方法（直接function或者内部），prototype无法访问</li>
<li>Js首先查找自身的静态属性，方法，再查找上下文中可以访问的属性或方法，最后才查找prototype，谁先谁优先</li>
<li>prototype比this要节约分配的空间，因为prototype有一个指向父类的指向，而this，每次实例化时都要分配存储空间</li>
</ul>
<pre><code>    <span class="keyword">var</span> Copy = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> d = <span class="string">"123"</span>;
        <span class="keyword">this</span>._log = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="built_in">console</span>.log(d);
        }
        <span class="keyword">this</span>.log = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="built_in">console</span>.log(<span class="string">'yes'</span>);
        }
    }
    Copy.prototype.log = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'no'</span>);
    }
    <span class="keyword">var</span> c = <span class="keyword">new</span> Copy();
    c.log();
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>this可以访问私有成员（用var声明的变量）私有方法（直接function或者内部），prototype无法访问</li>
<li>Js首先查找自身的静态属性，方法，再查找上下文中可以访问的属性或方法，最后才查找prototype，谁先谁优先</li>
<li]]>
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS学习第一个月心得与总结]]></title>
    <link href="http://lcepy.github.io/2015/01/02/iOS%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E5%BF%83%E5%BE%97%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://lcepy.github.io/2015/01/02/iOS学习第一个月心得与总结/</id>
    <published>2015-01-02T15:45:14.000Z</published>
    <updated>2015-01-03T05:34:21.000Z</updated>
    <content type="html"><![CDATA[<p>从买来Mac之后，还是看的池建强老师的一篇文章《程序员如何选择技术方向》，就开始自发的学习iOS了，因为我也想做一个自己的应用，想学一门编译型的语言，说来也巧，买Mac电脑，还是看了池老师《Mac Talk人生元编程》才开始真正下定决心入手了一台。</p>
<p>在开始学习iOS编程之前，我先重新去复习了一下C语言，这个是非常有必要的。虽然现在Swift已经出来了，但是Objective-C还是需要掌握的，而它又是C的超集，无可厚非，于是从头开始。</p>
<p>C语言总结：</p>
<ul>
<li>学习它的基本类型，比如int float等</li>
<li>学习数组，了解C语言数组是没有边界的，以及数组的指针是如何指向的</li>
<li>学习C语言的函数，了解它的一些传参，返回值等等，C语言中的函数如果想改变参数的值，那么必须传入指针类型</li>
<li>学习内存分配，以及如何分析问题</li>
<li>学习指针*，地址符&amp;</li>
<li>学习结构体，静态类型</li>
<li>学习宏定义，文件包含，条件编译</li>
<li>学习typedef</li>
<li>学习指向一维，二维数组的指针，指针字符串，以及指向函数的指针与返回指针的函数</li>
<li>枚举</li>
<li>个别C语言函数库</li>
</ul>
<p>总体来说学习完C语言之后，再学习OC非常的轻松，很多东西都可以command + 鼠标左键 去h文件中自己看，苹果的方法长的跟句子一样，真的很难记住，所以必须要看头文件了。而且学习完C语言，对于内存的分配，更加的清楚了。</p>
<p>Objective-C语言语法总结：</p>
<ul>
<li>学习OC后的结果第一条就是要学习如何看源代码</li>
<li>@interface定义一个类，在h文件中，以及如何在m文件中实现这个类@implementation，它们都有@end来结尾</li>
<li>了解OC是单继承，所以一个类只能继承一个父类，但可以有多个子类，OC中的继承是在头文件定义的类名后面:UIViewController 写上需要继承父类的类名</li>
<li>OC里也有成员变量，可以用一个大括号括起来，它也有如@public @private等，如果没有显示的声明，那么默认都是@protected</li>
<li>接着是学习如何定义方法，- + 以及self的作用，－表示实例方法，+表示静态方法，self表示当前谁用就指向谁</li>
<li>学习如何传入参数-(int)number:(int)num; 第一个括号表示返回值，冒号也算方法名，后面跟着的括号，表示传入一个int类型的参数</li>
<li>在成员变量中，可以显示的声明getter，setter方法，而在OC中这两种可以使用点语法来使用</li>
<li>学习分类category，在xcode中创建的文件一般都是类＋分类名比如@interface Game:(Test)，通过它可以实现对类的扩展</li>
<li>学习协议protocol，这玩意在做实际项目时会大量的运用到，它跟接口非常的类似，OC不强制要求实现全部的协议，使用的时候在类名后面加上尖括号<xxxdelegate>要求实现这个协议</xxxdelegate></li>
<li>block语法，^{}，这玩意跟Js中的callback函数非常的类似，只是OC实现的语法会非常的奇怪int(^number)(int,int)第一个int表示返回值，中间括号表示block的名字，最后一个括号表示传入参数的类型，这玩意字符多的时候看起来会有些怪异和费解</li>
<li>一些循环，for for in 或者block</li>
<li>内存管理，OC是使用引用计数的方式来管理内存的，所以创建就必须对应有释放，现在因为已经有了ARC所以这部分代码可以不用写了，编译器会帮助我们自动补全。alloc retain copy ＋1 relese -1 0的时候系统释放，一般情况下，谁使用，谁释放的原则，比如我现在用alloc创建一个对象，那么我就需要在relese它，如果我把这个对象setter给另一个对象当属性，那么这个对象就要retain一次，在dealloc这个方法中对它relese，原则就是这样的，谁使用，谁释放。</li>
<li>@property属性，OC提供了一个快速创建属性并默认实现getter setter方法的东西，主要是配合原子性，retain copy来使用，在开启ARC的环境下，可以用weak strong来使用，这个主要对应UI方面，一般情况下只是赋值用assign，NSString用copy，其他OC对象用retain</li>
<li>学习copy语法，了解什么是浅拷贝，深拷贝</li>
</ul>
<a id="more"></a>

<p>接下来是学习Foundation框架提供的OC类型了，都可以用@来快速实现，比如@””字符串，@[]数组，@{}字典，唯一的缺点是这些创建的是不可变的，如果要创建可变的，就要使用NSMutable …之类的了，前缀名字都一样。每一个类型都有N多方法，而且名字，长的根句子一样，所以就不写了，比如字符串，有创建，格式化，截取，数组，分割，排序等都有，需要学习Foundation提供的这些方法，因为它跟后面编写应用时，处理数据息息相关。</p>
<p>UIKit学习，到这里就开始进入应用编程的范围了，学习它是关于如何搭建UI界面，比如，如何使用xib，storyboard，用代码实现，认识UIViewController，以及如何监听事件，实现各控件的代理等。</p>
<p>UIKit学习总结：</p>
<ul>
<li>初识MVC</li>
</ul>
<p>官方的推荐任何一种对象都分配成三种角色。控制器可以直接访问模型和视图，但是模型跟视图是不允许互相访问。模型不允许直接访问控制器，从设计角度上来看，模型应该是重用的，如果下一个项目或者别的需要使用这个模型，如果模型中包含了控制器，那么就不可以使用了。模型应该关注的自身的数据，究竟这个数据需要放在哪里，则由控制器来控制。在控制中设置数据源datasource，当视图对控制器发送一个消息询问，数据源是啥，来索要数据。而它本身是不知道数据是哪个，而是由控制器来告知。</p>
<ul>
<li>清楚UIViewController的生命周期</li>
</ul>
<p>先走init方法，如果有自定义视图，则走自定义视图。如果没有，则走xib或storyborad，如果这个也没有则走loadView方法，loadView方法系统调用，也可以重载它。当我们重载它时，可以[super loadView] 父类帮助我们创建一个空的view，如果不调用父类，那么就要自己创建一个UIView，并且self.view = UIView。</p>
<p>如果在调用loadView时不调用父类，也不创建，如果使用self.view的getter method并且view等于nil，会发生自我循环调用。一般情况下，不要在初始化时做view相当的动作。在viewDiload中调用一些网络访问的动作，可以在初始化方法中做一些关于模型数据的准备工作。</p>
<p>如果覆盖了loadView，则必须创建UIViewController的view属性。如果没有覆盖该方法，UIViewController会默认调用initWithNibName方法来初始化并加载view。</p>
<p>viewWillAppear -&gt; viewDidAppear（控制视图显示）viewWillDisappear -&gt; viewDidDisappear （控制视图卸载）</p>
<ul>
<li>学习基础UI控件，比如UILabel UIButton等，创建基本上各控件都是一样的，可以用构造方法，也可以alloc，然后指定x y 高 宽，CGRect结构体，然后有些有代理，可以监听各种事件，有些则没有。大部分的基类都是UIView，有些是UIControl，它是继承至UIView，唯一的区别是后者可以监听事件，它是一个控制器。</li>
<li>学习UIView CAAnimation CATransition等，还有各控件的transform属性，可以做一些基础的动画，大部分是改变x y 高 宽值。然后会使用它们的block版本动画，少写很多代码。</li>
<li>学习模态视图，以及视图切换，控制器切换等。</li>
<li>学习UITableView UIPickerView UISlider UIImageView等，还有UIAlertView，太多了，就不一个一个的举例子了，比较重要，用的很多的就是UITableView UISlider UIImageView UIAlertView等，特别是UITableView，三个数据源，N个事件监听代理。</li>
<li>使用xib做自定义View</li>
</ul>
<p>关于UIKit的学习，可以每个多试一试 ，也可以去看看头文件。</p>
<h2 id="最后的总结">最后的总结</h2>
<p>一个月下来，也算是进门了，感觉它没有网上人们传的那么困难，凡事用心，一点一点的推进，就容易了，希望今年可以做自己的第一个应用上架App Store。</p>
<p><a href="https://github.com/lcepy/geekObjective-C/tree/master/UseHMGLTransitionsAnimations" target="_blank" rel="external">使用基础动画以及UITableView制作的一个Demo</a></p>
<p><a href="https://github.com/lcepy/geekObjective-C/tree/master/HttpImageAndPho" target="_blank" rel="external">访问相册，摄像头，简单从网络获取资源制作的一个Demo</a></p>
<p>iOS学习资料的收集</p>
<p><a href="https://github.com/lcepy/ios-programming-books-zh_CN" target="_blank" rel="external">https://github.com/lcepy/ios-programming-books-zh_CN</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从买来Mac之后，还是看的池建强老师的一篇文章《程序员如何选择技术方向》，就开始自发的学习iOS了，因为我也想做一个自己的应用，想学一门编译型的语言，说来也巧，买Mac电脑，还是看了池老师《Mac Talk人生元编程》才开始真正下定决心入手了一台。</p>
<p>在开始学习iOS编程之前，我先重新去复习了一下C语言，这个是非常有必要的。虽然现在Swift已经出来了，但是Objective-C还是需要掌握的，而它又是C的超集，无可厚非，于是从头开始。</p>
<p>C语言总结：</p>
<ul>
<li>学习它的基本类型，比如int float等</li>
<li>学习数组，了解C语言数组是没有边界的，以及数组的指针是如何指向的</li>
<li>学习C语言的函数，了解它的一些传参，返回值等等，C语言中的函数如果想改变参数的值，那么必须传入指针类型</li>
<li>学习内存分配，以及如何分析问题</li>
<li>学习指针*，地址符&amp;</li>
<li>学习结构体，静态类型</li>
<li>学习宏定义，文件包含，条件编译</li>
<li>学习typedef</li>
<li>学习指向一维，二维数组的指针，指针字符串，以及指向函数的指针与返回指针的函数</li>
<li>枚举</li>
<li>个别C语言函数库</li>
</ul>
<p>总体来说学习完C语言之后，再学习OC非常的轻松，很多东西都可以command + 鼠标左键 去h文件中自己看，苹果的方法长的跟句子一样，真的很难记住，所以必须要看头文件了。而且学习完C语言，对于内存的分配，更加的清楚了。</p>
<p>Objective-C语言语法总结：</p>
<ul>
<li>学习OC后的结果第一条就是要学习如何看源代码</li>
<li>@interface定义一个类，在h文件中，以及如何在m文件中实现这个类@implementation，它们都有@end来结尾</li>
<li>了解OC是单继承，所以一个类只能继承一个父类，但可以有多个子类，OC中的继承是在头文件定义的类名后面:UIViewController 写上需要继承父类的类名</li>
<li>OC里也有成员变量，可以用一个大括号括起来，它也有如@public @private等，如果没有显示的声明，那么默认都是@protected</li>
<li>接着是学习如何定义方法，- + 以及self的作用，－表示实例方法，+表示静态方法，self表示当前谁用就指向谁</li>
<li>学习如何传入参数-(int)number:(int)num; 第一个括号表示返回值，冒号也算方法名，后面跟着的括号，表示传入一个int类型的参数</li>
<li>在成员变量中，可以显示的声明getter，setter方法，而在OC中这两种可以使用点语法来使用</li>
<li>学习分类category，在xcode中创建的文件一般都是类＋分类名比如@interface Game:(Test)，通过它可以实现对类的扩展</li>
<li>学习协议protocol，这玩意在做实际项目时会大量的运用到，它跟接口非常的类似，OC不强制要求实现全部的协议，使用的时候在类名后面加上尖括号<xxxdelegate>要求实现这个协议</xxxdelegate></li>
<li>block语法，^{}，这玩意跟Js中的callback函数非常的类似，只是OC实现的语法会非常的奇怪int(^number)(int,int)第一个int表示返回值，中间括号表示block的名字，最后一个括号表示传入参数的类型，这玩意字符多的时候看起来会有些怪异和费解</li>
<li>一些循环，for for in 或者block</li>
<li>内存管理，OC是使用引用计数的方式来管理内存的，所以创建就必须对应有释放，现在因为已经有了ARC所以这部分代码可以不用写了，编译器会帮助我们自动补全。alloc retain copy ＋1 relese -1 0的时候系统释放，一般情况下，谁使用，谁释放的原则，比如我现在用alloc创建一个对象，那么我就需要在relese它，如果我把这个对象setter给另一个对象当属性，那么这个对象就要retain一次，在dealloc这个方法中对它relese，原则就是这样的，谁使用，谁释放。</li>
<li>@property属性，OC提供了一个快速创建属性并默认实现getter setter方法的东西，主要是配合原子性，retain copy来使用，在开启ARC的环境下，可以用weak strong来使用，这个主要对应UI方面，一般情况下只是赋值用assign，NSString用copy，其他OC对象用retain</li>
<li>学习copy语法，了解什么是浅拷贝，深拷贝</li>
</ul>
]]>
    
    </summary>
    
      <category term="iOS" scheme="http://lcepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用cocoapods来管理第三方库]]></title>
    <link href="http://lcepy.github.io/2014/12/31/%E4%BD%BF%E7%94%A8cocoapods%E6%9D%A5%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>http://lcepy.github.io/2014/12/31/使用cocoapods来管理第三方库/</id>
    <published>2014-12-31T05:52:58.000Z</published>
    <updated>2014-12-31T15:07:47.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="http://cocoapods.org/" target="_blank" rel="external">http://cocoapods.org/</a></li>
<li><a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="external">CocoaPods安装和使用教程</a></li>
<li><a href="http://blog.jobbole.com/72107/" target="_blank" rel="external">在 Swift 中使用 CocoaPods</a></li>
<li><a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="external">用CocoaPods做iOS程序的依赖管理</a></li>
<li><a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">https://github.com/CocoaPods/CocoaPods</a></li>
</ul>
<p><strong>关于配置，可以参考贴出来的上述的文章，唐巧的博客也写的比较详细</strong></p>
<p>在需要cocoapods来做管理的项目中建立Podfile文件，先通过pod search 来搜索所需要的库是否支持cocoapods，然后pod:(库名)，pod install来安装。</p>
<h2 id="坑处收集（针对xcode_6-1_实际项目出现的问题）">坑处收集（针对xcode 6.1 实际项目出现的问题）</h2>
<ul>
<li>安装时可以把ruby的镜像替换成淘宝的，第一次pod setup时稍微有些慢，需要耐心等待。</li>
<li>安装库时，如果出现链接阶段的错误，首先要查找一下link search paths 路径的问题，还有libpods.a文件是否添加到了library中。</li>
<li>安装库时，（最好能开代理就开代理，有时github网络会导致编译或者链接阶段出现莫名其妙的问题）因为文件没有下载全。</li>
<li>安装之前，最好是先command + shift + k clean一下编译的缓存，安装之后如果出现问题，也可以先clean一下，再编译尝试。</li>
<li>安装之前，最好先把项目关闭了，pod install 后，会在项目的根目录，生成一个新的xcworkspace文件，以后打开项目使用它，如果还用老的，打开又会出现莫名其妙的问题。</li>
<li>如果上述都没法解决问题，全部删除，重新来过。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><a href="http://cocoapods.org/" target="_blank" rel="external">http://cocoapods.org/</a></li>
<li><a href="http://code4app.com/arti]]>
    </summary>
    
      <category term="iOS" scheme="http://lcepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo写博客]]></title>
    <link href="http://lcepy.github.io/2014/11/22/%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lcepy.github.io/2014/11/22/用Hexo写博客/</id>
    <published>2014-11-21T16:12:00.000Z</published>
    <updated>2014-11-22T12:01:39.000Z</updated>
    <content type="html"><![CDATA[<p>在看下面内容之前，请先确认是否已经安装nodejs，若无则先安装。</p>
<p>访问<a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>，查看例子：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo -g
hexo init blog
cd blog
npm <span class="keyword">install</span>
hexo <span class="keyword">server</span></span>
</code></pre><p>hexo主要有如下几个命令来操作：</p>
<blockquote>
<p>hexo init  初始化一个hexo项目</p>
<p>hexo server 监听4000端口启动一个服务器，可以预览，端口可以在_config.yml文件中修改</p>
<p>hexo generate 输出静态文件，在public目录下</p>
<p>hexo new 生成一个md文件，这个文件就是我们要写的博客文件了</p>
<p>hexo clean 清除public目录以及缓存，其实这个缓存就是db.json文件</p>
<p>hexo deploy 如果在_conig.yml文件中配置了这项，它会帮助我们发布到网络</p>
</blockquote>
<p>一般大项的配置都是在顶层的_config.yml配置文件中配置，比如博客作者名，标题，时间格式，资源文件目录，静态资源文件目录，插件等等。而具体的博客配置，比如菜单之类的都在themes具体的主题_config.yml文件中配置。</p>
<a id="more"></a>

<h3 id="具体的操作步骤">具体的操作步骤</h3>
<p>建立一个名为myblog的目录。</p>
<p>cd ~/myblog</p>
<p>输入：hexo init 初始化一下</p>
<p>然后npm install 安装所需要的模块</p>
<p>输入hexo server 可以先进行一下预览，看看是否已经安装成功</p>
<p>subl _config.yml 打开这个文件先修改一下配置，比如title，author之类的</p>
<p><strong>在配置文件中:后要空一格再输入</strong></p>
<p>接着在主题<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">themes</a>中查看自己中意的主题，在插件<a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">plugins</a>中查看自己需要的插件。具体的配置，主题要git clone 在themes目录中，然后修改_config.yml配置文件中的theme:[主题名]。而插件则可以用npm来安装，例如安装feed插件，npm install hexo-generator-feed —save，然后在_config.yml文件中任意位置配置：</p>
<pre><code>feed:
    <span class="class"><span class="keyword">type</span>: <span class="title">atom</span></span>
    path: atom.xml
    limit: <span class="number">20</span>
</code></pre><p>基本上hexo渲染是可以用md来进行的，在配置好主题，插件之后，hexo new hello生成一个新的文章，然后开始你的写作之旅吧。</p>
<h2 id="开发主题">开发主题</h2>
<p>因为自己打算做一个关于订阅的项目，又不想自己写后台，于是根据hexo的特性，做了一部分修改，让主题不在局限于博客类型了，订阅主题可以使用<a href="https://github.com/lcepy/orange" target="_blank" rel="external">orange</a>，orange是完全参考的<a href="http://weekly.ios-wiki.com/" target="_blank" rel="external">http://weekly.ios-wiki.com/</a>而制作的基于hexo 2.4+的主题，它可以用于订阅类型的网站。</p>
<p>在开发自己的主题之前，可以先准备好静态文件。主题的开发主要依赖几个layout目录中的模版，除了布局模版，其他的可以根据自己的需求来修改。</p>
<p>访问<a href="http://hexo.io/docs/" target="_blank" rel="external">hexo docs</a>来获取具体的参考信息</p>
<blockquote>
<p>layout.ejs 是主题的一个基础框架模版</p>
<p>index.ejs 是主题的首页</p>
<p>post.ejs  是主题的内容页</p>
<p>archive.ejs 是主题的分类页</p>
</blockquote>
<p>这些相当于，手脚架，用户访问首页实际上访问的是layout.ejs + index.ejs 渲染出来的页面，而内容页则是layout.ejs + post.ejs 渲染出来的页面，当然，不仅仅只有这么四项，还有标签页等等，其他具体可以访问文档去参考。在这些模版中，可以使用&lt;%- partial() %&gt;来加载一个小模版，小模版可以放置在_partial目录下。</p>
<p><strong>全局变量</strong></p>
<blockquote>
<p>config 主要是可以获取到顶层的_config.yml中的配置项，比如想获取标题，&lt;%= config.title%&gt;</p>
<p>theme 主要是可以获取主题_config.yml中的配置项，使用&lt;%= theme.name%&gt;</p>
<p>site  在任何手脚架中都可以引用，site对象包含了posts（所有文章）pages（所有页面）tags（所有标签）categories（所有分类）可以each</p>
</blockquote>
<p><strong>具体变量</strong></p>
<blockquote>
<p>page 个对象中包含了具体内容，这所有的内容。如果不是在post.ejs中使用，则可以each。若是，则是一篇具体文章的所有对象 &lt;%= page.title%&gt;</p>
<p>post 包含所有文章的一个对象，可以each</p>
</blockquote>
<p><strong>布局</strong></p>
<p>基础布局，也就是不带&lt;%- body%&gt;的布局，在这个布局中也可以自定义其他布局，比如link之类的,若找不到自定的布局的话，则会根据 Generator 的不同，使用相对应的布局代替。而带&lt;%- body%&gt;的layout布局，则是把page对象一一传递给最终所使用的模版中。</p>
<p><strong>注意事项</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Your</span> code <span class="keyword">block</span> <span class="keyword">with</span> {{anything}}</div></pre></td></tr></table></figure>

<p><a href="https://github.com/hexojs/hexo/issues/916" target="_blank" rel="external">#916</a></p>
<p><strong>额外的学习</strong></p>
<p>主要是看看ejs模版如何使用，亲，玩转自己的主题去吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在看下面内容之前，请先确认是否已经安装nodejs，若无则先安装。</p>
<p>访问<a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>，查看例子：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo -g
hexo init blog
cd blog
npm <span class="keyword">install</span>
hexo <span class="keyword">server</span></span>
</code></pre><p>hexo主要有如下几个命令来操作：</p>
<blockquote>
<p>hexo init  初始化一个hexo项目</p>
<p>hexo server 监听4000端口启动一个服务器，可以预览，端口可以在_config.yml文件中修改</p>
<p>hexo generate 输出静态文件，在public目录下</p>
<p>hexo new 生成一个md文件，这个文件就是我们要写的博客文件了</p>
<p>hexo clean 清除public目录以及缓存，其实这个缓存就是db.json文件</p>
<p>hexo deploy 如果在_conig.yml文件中配置了这项，它会帮助我们发布到网络</p>
</blockquote>
<p>一般大项的配置都是在顶层的_config.yml配置文件中配置，比如博客作者名，标题，时间格式，资源文件目录，静态资源文件目录，插件等等。而具体的博客配置，比如菜单之类的都在themes具体的主题_config.yml文件中配置。</p>
]]>
    
    </summary>
    
      <category term="hexo" scheme="http://lcepy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则的一些理解]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%AD%A3%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://lcepy.github.io/2014/11/14/正则的一些理解/</id>
    <published>2014-11-14T13:50:22.000Z</published>
    <updated>2014-11-14T19:41:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天写到这里，是想总结一下，自己重新学习正则表达式之后，对它的一个全新的认识。我想描述一个中心思想，学习任何东西，编程，音乐，基础是非常important的，就好像吉他里基础不在于认识六线谱而是在于节拍。</p>
<h2 id="从人类的角度来阅读正则">从人类的角度来阅读正则</h2>
<p>在写代码示例之前，我描述一个正确的阅读正则表达式的方式，也许有点反人类，从右往左读。我很喜欢正则表达式，就像我喜欢python一样，因为它给了我一个很快速处理字符的能力。python中也有很多高效处理字符串的方式，比如步距，比如正则，嘿嘿。</p>
<p>import re</p>
<p>g = re.search(‘\d+(.\d*)?’,’0.2556223.556655’)</p>
<p>g.group(0)</p>
<p>我们来看一个搜索浮点数的正则，我们从右往左看，把这一个正则表达式分割成三分，\d+，(.\d<em>)，?。我们知道?描述的是出现零次或一次，在这里阅读的时候，是描述(.\d</em>)这一个组会出现零次或一次。我们再看这个组中的描述.用来描述.，\d用来描述0-9的数字，而*描述的是出现零次或多次，我们组合起来看，这个组就是来描述.后面的数字会出现零次或多次。\d依然是用来描述0-9的数字，+用来描述出现一次或多次。</p>
<p>到这里，我们把这三个部分，从右往左看，组合起来，用人类阅读的角度去描述它：小数点后面出现的数字是多次的，而这一个部分只能出现一次或零次，并且在小数点之前可以出现一次或多次的数字。<br><a id="more"></a><br>那么让我们看一个搜索邮件的正则：</p>
<p>import re</p>
<p>g = re.search(‘\w+@\w+.com’,’ww@ww.com’)</p>
<p>g.group(0)</p>
<p>依然在描述它时，分割开来，从右往左去描述，.com的字符串，\w描述任意字符，+的左边为\w，描述为出现一次或多次的字符。@的字符串，+的左边为\w，描述为出现一次或则多次的字符。</p>
<p>我依然把这三个部分，组合起来阅读，描述为：.com的左侧允许出现一次或多次的字符，左侧连接@，并且@的左侧允许出现一次或多次的字符。</p>
<p>升级一下，匹配存在子域的邮件：</p>
<p>import re</p>
<p>g = re.search(‘\w+@\w+(.\w+)?.com’,’ww@ww.ww.com’)</p>
<p>g.group(0)</p>
<p>从右往左来描述：.com的字符串，?左侧的(.\w+)描述为：(.后的字符可能出现一次或多次)但是它只能出现一次或零次。\w+，描述为字符串一次或多次。@的字符串，\w+，依然描述为字符串出现一次或多次。</p>
<p>把这几个部分合起来，描述：.com的左侧允许出现[.一次或多次的字符]= a，而a左侧[允许出一次或多次的字符] = b，b的左侧为@，@的左侧允许出现一次或多次的字符。</p>
<p>这样，一段复杂的表达式，往往可以通过分解的步骤来阅读它，但是，它需要基础，基础在于对这些特殊字符，元，的了解。再复杂的正则，也可以从左往右来阅读它，并用人类的语言，写在纸上，这会是一个非常棒的方式。</p>
<p>我喜欢，写在纸上，它让我对这一个部分，非常的清晰，了解，不信，可以试试？</p>
<p><strong>注释：因为是python的正则，所以去掉了一些特殊的</strong></p>
<h2 id="认识常用的基础">认识常用的基础</h2>
<p>字符 | 描述</p>
<p>.|匹配任意字符，除(\n)之外的字符</p>
<p>\ | 转意字符</p>
<p>[…] | 字符集</p>
<p>0-9|匹配0-9的数字</p>
<p>a-z A-Z|匹配从a到z的字符</p>
<p>预定义字符集 | 描述</p>
<p>\d | 匹配数字</p>
<p>\w | 匹配字符</p>
<p>\s | 匹配空格符</p>
<p>数量词 | 描述</p>
<p>* | 出现零次或多次</p>
<p>+ | 出现一次或多次</p>
<p>? | 出现零次或一次</p>
<p>{n} | 出现n次</p>
<p>{n,m} | 出现n次或m次</p>
<p>边界匹配 | 描述</p>
<p>^ | 在开始位置</p>
<p>$ | 在结束位置</p>
<p>逻辑 | 描述</p>
<p>|  逻辑或</p>
<p>()组 为一个子组，必须存在，才匹配</p>
<p>[]列 可以为出现任意一个，都匹配</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天写到这里，是想总结一下，自己重新学习正则表达式之后，对它的一个全新的认识。我想描述一个中心思想，学习任何东西，编程，音乐，基础是非常important的，就好像吉他里基础不在于认识六线谱而是在于节拍。</p>
<h2 id="从人类的角度来阅读正则">从人类的角度来阅读正则</h2>
<p>在写代码示例之前，我描述一个正确的阅读正则表达式的方式，也许有点反人类，从右往左读。我很喜欢正则表达式，就像我喜欢python一样，因为它给了我一个很快速处理字符的能力。python中也有很多高效处理字符串的方式，比如步距，比如正则，嘿嘿。</p>
<p>import re</p>
<p>g = re.search(‘\d+(.\d*)?’,’0.2556223.556655’)</p>
<p>g.group(0)</p>
<p>我们来看一个搜索浮点数的正则，我们从右往左看，把这一个正则表达式分割成三分，\d+，(.\d<em>)，?。我们知道?描述的是出现零次或一次，在这里阅读的时候，是描述(.\d</em>)这一个组会出现零次或一次。我们再看这个组中的描述.用来描述.，\d用来描述0-9的数字，而*描述的是出现零次或多次，我们组合起来看，这个组就是来描述.后面的数字会出现零次或多次。\d依然是用来描述0-9的数字，+用来描述出现一次或多次。</p>
<p>到这里，我们把这三个部分，从右往左看，组合起来，用人类阅读的角度去描述它：小数点后面出现的数字是多次的，而这一个部分只能出现一次或零次，并且在小数点之前可以出现一次或多次的数字。<br>]]>
    
    </summary>
    
      <category term="regex" scheme="http://lcepy.github.io/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于django中CSRF开启的问题]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%85%B3%E4%BA%8Edjango%E4%B8%ADCSRF%E5%BC%80%E5%90%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lcepy.github.io/2014/11/14/关于django中CSRF开启的问题/</id>
    <published>2014-11-14T12:33:12.000Z</published>
    <updated>2014-11-14T19:40:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="django_处理CSRF机制保护下的POST表单提交">django 处理CSRF机制保护下的POST表单提交</h2>
<p>昨天晚上使用django做一个POST表单提交的功能，发现出现了一个CSRF verification failed. Request aborted错误。于是，在网上找了很久，也没有什么好的办法可以解决它。我发现，大部分人的博客都不靠谱，Ctrl+C Ctrl+V的复制，坑了我不少时间，于是我去了django的官网，查询CSRF的问题，最后解决了。其实在解决这个问题之前，我们先要了解一下，CSRF到底是什么东东，为什么django提交一个POST表单这么困难呢。</p>
<p><a href="http://baike.baidu.com/link?url=OnI0sPQAHpQHhtxWSXvQFhN3kJWI3CU_rP3Fo7MqnPY3rTdhUPpuca-3lzJ651LdMI7ouoLvdnnihhojFyKtva" target="_blank" rel="external">CSRF 是什么</a></p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/contrib/csrf/" target="_blank" rel="external">django document CSRF</a></p>
<p>原来CSRF是为了防止跨站请求伪造用的，当我明白了这个解释之后，我开始找寻django document上如何开启CSRF。</p>
<p><strong>Add the middleware ‘django.middleware.csrf.CsrfViewMiddleware’ to your list of middleware classes, MIDDLEWARE_CLASSES. (It should come before any view middleware that assume that CSRF attacks have been dealt with.)</strong></p>
<p>那我在想，如果我把django.middleware.csrf.CsrfViewMiddleware注释掉，是不是就可以不开启CSRF来提交POST表单，人们常说实践是检验真理的唯一标准，试验一下，原来是可以的。但是这并没有解决，我想解决的问题，于是我又把这个中间件，重新写在了MIDDLEWARE_CLASSES上。</p>
<p>从官方的解释上来看，只要在MIDDLEWARE_CLASSES上加django.middleware.csrf.CsrfViewMiddleware就开启了CSRF机制。</p>
<p>现在我需要在模板中加入一个tag ｛%csrf_token%｝，来存放一个隐藏的token input。</p>
<p><strong>In the corresponding view functions, ensure that the ‘django.core.context_processors.csrf’ context processor is being used. Usually, this can be done in one of two ways:</strong></p>
<p>从这里的解释来看，我还需要django.core.context_processors.csrf，于是我导入这个模块from django.core.context_processors import csrf，运行一下貌似，还不行，接着往下看。我发现django的解释，这里可以用两种方式来处理，最后响应的response，而且django还说了，POST表单提交不要跨链接。</p>
<p><a id="more"></a><br><strong>Use RequestContext, which always uses ‘django.core.context_processors.csrf’ (no matter what your TEMPLATE_CONTEXT_PROCESSORS setting). If you are using generic views or contrib apps, you are covered already, since these apps use RequestContext throughout.</strong></p>
<p>方式一，是使用RequestContext来代替你模板的Context，并且你的apps必须都要使用它，而不是Context。</p>
<p><strong>Manually import and use the processor to generate the CSRF token and add it to the template context. e.g.</strong></p>
<p>方式二，手动的导入这个模块并调用此函数生成的token，并把它传入你模板的上下文中。</p>
<p>我使用的是方式二，在这里也许刚刚接触django的朋友会卡在这里，因为没法明白，怎么传入这个上下文。这里可以使用一个通用的方式去解决这个问题。请原谅我，我将脱离CSRF的内容，帮助你解决一下模板设置的问题，解决它才能解决它。回到django-admin.py startproject xxx初始化的项目中，打开settings.py文件，它是整个django项目的配置文件。找到TEMPLATE_DIRS配置上你模板目录的绝对路径，也可以是os.path生成出来的路径。然后通过from django.shortcuts import render_to_response来导入render_to_response。</p>
<pre><code>xxx.html结构

&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;&lt;/h1&gt;
        &lt;form action=<span class="string">"/"</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;
             ｛%csrf_token%｝
            &lt;input <span class="keyword">type</span>=<span class="string">"email"</span> name=<span class="string">"address"</span>&gt;
            &lt;button <span class="keyword">type</span>=<span class="string">"submit"</span> class=<span class="string">"btn btn-default"</span>&gt;send&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;



views.py <span class="comment">##视图文件</span>

<span class="keyword">from</span> django.<span class="keyword">template</span> <span class="keyword">import</span> <span class="type">Context</span>
<span class="keyword">from</span> django.core.context_processors <span class="keyword">import</span> csrf
<span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response
<span class="keyword">import</span> models

def index(request):
    dicts = {'we':'i send <span class="type">string</span>'}
    token = {}
    token.update(csrf(request))
    <span class="keyword">if</span> request.<span class="keyword">method</span> == '<span class="type">POST</span>':
        address = request.<span class="type">POST</span>.get('address')
        <span class="comment">## 可以用address来做其他验证或者其他处理程序</span>
        <span class="comment">## 此处省略其他处理函数</span>
    data = <span class="type">Context</span>(dicts)
    <span class="keyword">return</span> render_to_response('xxx.html',c,data)
    pass

urls.py <span class="comment">##路由配置文件，我的views是一个app所以需要导入xxx.views</span>
<span class="keyword">import</span> xxx.views
urlpatterns = patterns('',
    <span class="comment"># Examples:</span>
    <span class="comment"># url(r'^$', 'atomcoffee.views.home', name='home'),</span>
    <span class="comment"># url(r'^atomcoffee/', include('atomcoffee.foo.urls')),</span>
    url(r'^$',xxx.views.index),
    <span class="comment"># Uncomment the admin/doc line below to enable admin documentation:</span>
    <span class="comment"># url(r'^admin/doc/', include('django.contrib.admindocs.urls')),</span>

    <span class="comment"># Uncomment the next line to enable the admin:</span>
    <span class="comment"># url(r'^admin/', include(admin.site.urls)),</span>
)
</code></pre><p>大家可以尝试运行一下这个文件，你会发现，原来开启CSRF机制后的POST表单提交，成功了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="django_处理CSRF机制保护下的POST表单提交">django 处理CSRF机制保护下的POST表单提交</h2>
<p>昨天晚上使用django做一个POST表单提交的功能，发现出现了一个CSRF verification failed. Request aborted错误。于是，在网上找了很久，也没有什么好的办法可以解决它。我发现，大部分人的博客都不靠谱，Ctrl+C Ctrl+V的复制，坑了我不少时间，于是我去了django的官网，查询CSRF的问题，最后解决了。其实在解决这个问题之前，我们先要了解一下，CSRF到底是什么东东，为什么django提交一个POST表单这么困难呢。</p>
<p><a href="http://baike.baidu.com/link?url=OnI0sPQAHpQHhtxWSXvQFhN3kJWI3CU_rP3Fo7MqnPY3rTdhUPpuca-3lzJ651LdMI7ouoLvdnnihhojFyKtva" target="_blank" rel="external">CSRF 是什么</a></p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/contrib/csrf/" target="_blank" rel="external">django document CSRF</a></p>
<p>原来CSRF是为了防止跨站请求伪造用的，当我明白了这个解释之后，我开始找寻django document上如何开启CSRF。</p>
<p><strong>Add the middleware ‘django.middleware.csrf.CsrfViewMiddleware’ to your list of middleware classes, MIDDLEWARE_CLASSES. (It should come before any view middleware that assume that CSRF attacks have been dealt with.)</strong></p>
<p>那我在想，如果我把django.middleware.csrf.CsrfViewMiddleware注释掉，是不是就可以不开启CSRF来提交POST表单，人们常说实践是检验真理的唯一标准，试验一下，原来是可以的。但是这并没有解决，我想解决的问题，于是我又把这个中间件，重新写在了MIDDLEWARE_CLASSES上。</p>
<p>从官方的解释上来看，只要在MIDDLEWARE_CLASSES上加django.middleware.csrf.CsrfViewMiddleware就开启了CSRF机制。</p>
<p>现在我需要在模板中加入一个tag ｛%csrf_token%｝，来存放一个隐藏的token input。</p>
<p><strong>In the corresponding view functions, ensure that the ‘django.core.context_processors.csrf’ context processor is being used. Usually, this can be done in one of two ways:</strong></p>
<p>从这里的解释来看，我还需要django.core.context_processors.csrf，于是我导入这个模块from django.core.context_processors import csrf，运行一下貌似，还不行，接着往下看。我发现django的解释，这里可以用两种方式来处理，最后响应的response，而且django还说了，POST表单提交不要跨链接。</p>
<p>]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django模型使用的一些心得]]></title>
    <link href="http://lcepy.github.io/2014/11/14/django%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <id>http://lcepy.github.io/2014/11/14/django模型使用的一些心得/</id>
    <published>2014-11-14T12:30:31.000Z</published>
    <updated>2014-11-14T19:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>近很一直在学习django，因为我需要使用它为自己的项目写一个前台页面和一个后台服务。它是一个关于咖啡的邮件订阅社区，既然有服务，自然需要数据库层的支持。这是一个很好的开始，学习django让我了解到python开发web应用真的非常快速，但是也有一个很明显的缺点。那就是国内，对django社区的支持度非常不好，这或许跟国内python的有关，不过也不要紧，学习就是这样，要啃难而上。</p>
<p>说说在django中模型，对应的数据库层，也就是意味着django帮助我们完成了对数据库的访问，操作，通过它的模型类。</p>
<blockquote>
<p>django-admin.py startapp sendcloud</p>
</blockquote>
<p>通过上述的命令，我们可以完成一个app模块，这个模块中带有views.py models.py test.py，而models.py文件中，就是我们完成模型的一个最主要的文件。</p>
<blockquote>
<p>from django.db import models</p>
</blockquote>
<p>模型类，都需要继承自django.db.models类。通过它与manage.py来完成初始化等等动作。关于manage.py的命令，未来有时间，我会写写关于它的心得。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">WeeklySyncList</span><span class="params">(models.Model)</span>:</span>
    <span class="comment">#do something</span>
    <span class="keyword">pass</span>
</code></pre><p>一个模型类对于数据库层中的一个表，在我们定义好模型类之后，可以在命令行中输入：</p>
<blockquote>
<p>python manage.py sqlall sendcloud</p>
</blockquote>
<p>来完成对创建语法的查看以及错误信息的查看，准确没有错误之后，可以输入：</p>
<blockquote>
<p>python manage.py syncdb</p>
</blockquote>
<p>来初始数据库，django会帮助我们完成数据库层面的操作。</p>
<a id="more"></a>

<h2 id="说说我的应用中使用到的东西">说说我的应用中使用到的东西</h2>
<p>我的应用是一个关于咖啡资料的邮件订阅社区，前台页面主要是输入email完成订阅，激活订阅，退订，历史期刊的分页查看，最新一期查看。这里，我使用了三个表来描述它，（这个数据库中还有另外的表，在描述后台服务，这里仅仅用前台来说说我学习的过程。）用户订阅表，用户退订表，期刊表。在语言层面，就需要三个模型类，来描述它了。</p>
<p>另外：这个应用，已经开源在github上，大家通过它可以访问到<a href="https://github.com/lcepy/AtomCoffee-Client" target="_blank" rel="external">点击这里</a></p>
<p>我用到的字段类型，主要是三个字段varchar date int，主要是用于订阅的email，订阅时间，激活时间，是否激活的状态。</p>
<p>在django中，因为我们不是使用原始查询，所以还需要在模型类中定义相应的字段，这一部分需要学习，对应的就是数据库中的字段类型，但是django有它自己的描述。</p>
<p><strong>用户订阅时插入数据库</strong></p>
<pre><code>models.WeeklyActivation(<span class="variable">activation_email=</span>address,<span class="variable">activation_key=</span>_ac_sha_key)
</code></pre><p>用户条件的一条email，会经过在后台的验证，验证成功之后就插入一条新的纪录。从代码上来看，基本上实例化一个类。</p>
<p><strong>查询数据库</strong></p>
<p>在验证email之后，我会根据提交的信息，先去数据库中查询一下是否有这个email地址，另外它是否是激活的状态。</p>
<pre><code><span class="attribute">models.WeeklyActivation.objects.filter(activation_email</span>=<span class="string">address)</span>
</code></pre><p>如果存在，并且已经激活，自然就不用插入一条新的纪录了。如果订阅时间，超过了两个小时，系统就需要发送一封信的订阅激活邮件了。</p>
<p>在django模型类中，objects叫做管理器，通过它，可以完成一些不同的操作，比如查询，过滤，等等。</p>
<p><strong>更新数据</strong></p>
<p>当用户收到一封激活email时，用户点击URL过来，需要更新一下激活状态，初始化状态都是0。</p>
<pre><code><span class="variable">week =</span> models.WeeklyActivation.objects.filter(<span class="variable">activation_key=</span>offset)
</code></pre><p>根据用户点击过来的URL获取到激活key，根据激活KEY查询一条记录，如果存在则通过week完成其他的操作。</p>
<p>这里还有地方要注意，查询返回的结果是一个list，要week = week[0]，然后再来操作，更新完成之后不要忘记调用week.save()方法，不然更新不会成功。</p>
<p><strong>原生查询</strong></p>
<p>在查看最新一期期刊的这个地方，我纠结了大概一个小时，因为我不清楚django模型，是怎样完成数据库函数的调用的，比如一个表中，我只需要某个列的最大值，这里如果是原生SQL，我一般都会用MAX函数来完成。</p>
<p>在没有找到django关于这方面的信息之前，我用了原始查询，django支持这个。</p>
<pre><code>模型类.raw('<span class="operator"><span class="keyword">SELECT</span> id,<span class="keyword">MAX</span>(sync_number) <span class="keyword">AS</span> max_number <span class="keyword">FROM</span> sendcloud_weeklysynclist<span class="string">')</span></span>
</code></pre><p>另外这里也需要关注一个问题，如果要原始查询，必须要带上主键，不然django会抛一个错误出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近很一直在学习django，因为我需要使用它为自己的项目写一个前台页面和一个后台服务。它是一个关于咖啡的邮件订阅社区，既然有服务，自然需要数据库层的支持。这是一个很好的开始，学习django让我了解到python开发web应用真的非常快速，但是也有一个很明显的缺点。那就是国内，对django社区的支持度非常不好，这或许跟国内python的有关，不过也不要紧，学习就是这样，要啃难而上。</p>
<p>说说在django中模型，对应的数据库层，也就是意味着django帮助我们完成了对数据库的访问，操作，通过它的模型类。</p>
<blockquote>
<p>django-admin.py startapp sendcloud</p>
</blockquote>
<p>通过上述的命令，我们可以完成一个app模块，这个模块中带有views.py models.py test.py，而models.py文件中，就是我们完成模型的一个最主要的文件。</p>
<blockquote>
<p>from django.db import models</p>
</blockquote>
<p>模型类，都需要继承自django.db.models类。通过它与manage.py来完成初始化等等动作。关于manage.py的命令，未来有时间，我会写写关于它的心得。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">WeeklySyncList</span><span class="params">(models.Model)</span>:</span>
    <span class="comment">#do something</span>
    <span class="keyword">pass</span>
</code></pre><p>一个模型类对于数据库层中的一个表，在我们定义好模型类之后，可以在命令行中输入：</p>
<blockquote>
<p>python manage.py sqlall sendcloud</p>
</blockquote>
<p>来完成对创建语法的查看以及错误信息的查看，准确没有错误之后，可以输入：</p>
<blockquote>
<p>python manage.py syncdb</p>
</blockquote>
<p>来初始数据库，django会帮助我们完成数据库层面的操作。</p>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[携程邮轮开发部django分享]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%90%BA%E7%A8%8B%E9%82%AE%E8%BD%AE%E5%BC%80%E5%8F%91%E9%83%A8django%E5%88%86%E4%BA%AB/"/>
    <id>http://lcepy.github.io/2014/11/14/携程邮轮开发部django分享/</id>
    <published>2014-11-14T12:20:19.000Z</published>
    <updated>2014-11-14T19:41:28.000Z</updated>
    <content type="html"><![CDATA[<p>使用django快速开发一个web网站</p>
<p>分享内容（拟）</p>
<ol>
<li>介绍django的历史</li>
<li>安装以及配置django项目</li>
<li>介绍django对请求的回应机制</li>
<li>讲解django URL的配置</li>
<li>讲解django模型的使用</li>
<li>讲解django view template 的使用</li>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>分享学习Python django的资料，以及说说一些django的web工具</li>
</ol>
<a id="more"></a>

<h2 id="django的历史">django的历史</h2>
<p>django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的软件设计模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手django reinhardt来命名的。</p>
<p><strong>人生苦短，我用Python。</strong></p>
<h2 id="安装以及配置django项目">安装以及配置django项目</h2>
<p>安装方式一：</p>
<p>下载<a href="https://github.com/django/django" target="_blank" rel="external">django</a>源代码到本地，进入这个目录，执行命令：python install setup.py</p>
<p>安装方式二：</p>
<p>下载<a href="https://pip.pypa.io/en/latest/" target="_blank" rel="external">pip</a>模块管理器到本地，执行命令：python install get-pip.py</p>
<p>然后使用pip进行安装，pip install django。</p>
<p>使用pip安装，可以很方便的删除，选择需要安装的django版本，例如：pip install django==1.5.2安装1.5.2版本的django。</p>
<p>个人推荐，使用方式二。</p>
<p>在安装完成好django之后，可以在python shell 交互控制台中测试django是否安装成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> django</div><div class="line"></div><div class="line">print(django.get_version()) <span class="comment">#1.5.2</span></div></pre></td></tr></table></figure>

<p>django-admin.py是django提供了一个强大的shell命令行工具，比如建立项目，建立项目内应用，启动开发服务器，测试模型SQL语句，同步模型到数据库等等，用好django出了需要具备python标准库，语法知识，以及django定义的类，组件之外，还需要学习好它的shell命令行工具，admin管理系统等，因为它们会让开发一个web应用，变得非常简单与快速。</p>
<p>新建立一个项目：cruise</p>
<pre><code>某目录内 ~/ django.<span class="literal">admin</span>.py startproject cruise
</code></pre><p>cruise项目目录：</p>
<pre><code>cruise (dir)
    wsgi.<span class="keyword">py</span>
    setting.<span class="keyword">py</span>
    urls.<span class="keyword">py</span>
manage.<span class="keyword">py</span>
</code></pre><p>建立一个应用：login</p>
<pre><code>cruise目录内 ~/ <span class="keyword">python</span> manage.<span class="keyword">py</span> startapp login
</code></pre><p>login应用目录：</p>
<pre><code>login（dir）
    views.<span class="keyword">py</span>
    models.<span class="keyword">py</span>
    test.<span class="keyword">py</span>
</code></pre><p><strong>概念</strong> django项目中，各种服务类的功能，可以分离成一个个应用，而外层才是项目的配置文件。</p>
<p>wsgi.py 是一个符合wsgi标准的文件，由django实现，<a href="http://wsgi.readthedocs.org/en/latest/" target="_blank" rel="external">WSGI资料可查看</a></p>
<p>setting.py 为django项目的配置文件，django实现的组件，以及开发时模板，静态资源等等都在此配置。</p>
<p>urls.py 可以理解为django为view实现的路由系统。</p>
<h2 id="介绍django对请求的回应机制（3）">介绍django对请求的回应机制（3）</h2>
<p>当服务器接收到一个HTTP请求后，一个服务器特定的handler会创建HTTpRequest并传递给下一个处理程序，这个处理程序，会处理URLConf，并调用相应的view，把REQUEST传递给view 处理程序。</p>
<p>view处理程序，当处理完成之后，进行响应给客户端。另外django的中间件会，增强这些响应的作用。</p>
<h2 id="django_URL的配置（4）">django URL的配置（4）</h2>
<p>首先需要先导入django.conf.urls.defaults下的所有模块，它是django URLConf的基本构造，包含了一个patterns函数，调用patterns函数并将返回结果保存到 urlpatterns 变量。实际在建立项目时，django生成的文件中，已经帮助我们做好了这件事情。</p>
<p>它所需要的参数是一个元组，用来映射视图与URL的关系。</p>
<p><strong>额外：Python路径搜索规则，建议查看资料。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> patterns, include, url</div><div class="line"><span class="comment"># Uncomment the next two lines to enable the admin:</span></div><div class="line"><span class="comment"># from django.contrib import admin</span></div><div class="line"><span class="comment"># admin.autodiscover()</span></div><div class="line"><span class="keyword">import</span> login.views</div><div class="line"><span class="keyword">import</span> home.views</div><div class="line"><span class="comment">#在django中urls.py的作用有点类似于C，实际上它就是一个分发程序，帮助我们对每一项URL进行分发到具体的视图程序中。</span></div><div class="line">urlpatterns = patterns(<span class="string">''</span>,</div><div class="line">    <span class="comment"># Examples:</span></div><div class="line">    <span class="comment"># url(r'^$', 'cruise.views.home', name='home'),</span></div><div class="line">    <span class="comment"># url(r'^cruise/', include('cruise.foo.urls')),</span></div><div class="line">    url(<span class="string">r'^login/$'</span>,login.views.sign_in),</div><div class="line">    url(<span class="string">r'^logout/$'</span>,login.views.sign_out),</div><div class="line">    url(<span class="string">r'^register/$'</span>,login.views.register),</div><div class="line">    url(<span class="string">r'^$'</span>,home.views.mypage),</div><div class="line">    <span class="comment"># Uncomment the admin/doc line below to enable admin documentation:</span></div><div class="line">    <span class="comment"># url(r'^admin/doc/', include('django.contrib.admindocs.urls')),</span></div><div class="line">    <span class="comment">#URL配置例子</span></div><div class="line">    <span class="comment"># Uncomment the next line to enable the admin:</span></div><div class="line">    <span class="comment"># url(r'^admin/', include(admin.site.urls)),</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p><strong>URL正则表：</strong></p>
<blockquote>
<p>符号    匹配<br>. (dot)    任意单一字符<br>\d    任意一位数字<br>[A-Z]    A 到 Z中任意一个字符（大写）<br>[a-z]    a 到 z中任意一个字符（小写）<br>[A-Za-z]    a 到 z中任意一个字符（不区分大小写）</p>
<ul>
<li>匹配一个或更多 (例如, \d+ 匹配一个或 多个数字字符)<br>[^/]+    一个或多个不为‘/’的字符</li>
</ul>
<ul>
<li>零个或一个之前的表达式（例如：\d? 匹配零个或一个数字）</li>
<li>匹配0个或更多 (例如, \d* 匹配0个 或更多数字字符)<br>{1,3}    介于一个和三个（包含）之前的表达式（例如，\d{1,3}匹配一个或两个或三个数字）</li>
</ul>
</blockquote>
<h3 id="简单思路">简单思路</h3>
<p>导入视图模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> login.views</div><div class="line"><span class="keyword">import</span> home.views</div></pre></td></tr></table></figure>

<p>django URLConf 的配置，有多种多样的形式，这里主要是介绍一下简单的URL规则，在Python风格中URL应该是双斜杠//，例如：127.0.0.1/home/或者127.0.0.1/home/1/ 。</p>
<p>一般情况下一个URL是对应一个视图的，例如127.0.01/home/可能对于的就是视图home.views.home。而在URL中也可以动态，比如情况是书籍的详细情况，一本书有一个唯一的书籍号ID，而书籍号ID就可以描述为：127.0.0.1/book/1/，这是ID为1的书籍，又如127.0.0.1/book/2/，这是ID为2的书籍。</p>
<p>如何实现动态URL？</p>
<p>之前，有看过URL正则表达式，django URLConf是支持正则表达式，来描述URL的。它会成第二个参数，传递给视图处理程序。例如，我想获取书籍号ID，来显示不同本书籍，那么URL：^book/(\d+)/$，而在视图处理程序中第二个参数，就是GET请求时，获取的book/(\d+)/，这样的数字ID。</p>
<p>总之URLConf可以通过这些组合来映射相应的视图处理程序，来满足业务需求。</p>
<h2 id="django模型的使用（5）">django模型的使用（5）</h2>
<p>在使用模型之前，需要先配置数据库，django支持的数据库类型表：</p>
<p><code>postgresql</code>    PostgreSQL    psycopg 1.x版， <a href="http://www.djangoproject.com/r/python-pgsql/1/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-pgsql/1/。</a></p>
<p>postgresql_psycopg2    PostgreSQL    psycopg 2.x版， <a href="http://www.djangoproject.com/r/python-pgsql/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-pgsql/。</a></p>
<p>mysql    MySQL    MySQLdb , <a href="http://www.djangoproject.com/r/python-mysql/" target="_blank" rel="external">http://www.djangoproject.com/r/python-mysql/</a>.</p>
<p>sqlite3    SQLite    如果使用Python 2.5+则不需要适配器。 否则就使用 pysqlite ， <a href="http://www.djangoproject.com/r/python-sqlite/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-sqlite/。</a></p>
<p>oracle    Oracle    cx_Oracle , <a href="http://www.djangoproject.com/r/python-oracle/" target="_blank" rel="external">http://www.djangoproject.com/r/python-oracle/</a>.</p>
<p>主要为：mysql oracle sqlite等等。</p>
<p>打开setting.py文件，在起始位置出，默认情况下，这些都是无配置的，需要手动配置好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置数据库模型</span></div><div class="line">DATABASES = {</div><div class="line">    <span class="string">'default'</span>: {</div><div class="line">        <span class="string">'ENGINE'</span>: mydb.DB_ENGINE, <span class="comment"># Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.</span></div><div class="line">        <span class="string">'NAME'</span>: mydb.DB_NAME,                      <span class="comment"># Or path to database file if using sqlite3.</span></div><div class="line">        <span class="comment"># The following settings are not used with sqlite3:</span></div><div class="line">        <span class="string">'USER'</span>: mydb.DB_USER,</div><div class="line">        <span class="string">'PASSWORD'</span>: mydb.DB_PASSWORD,</div><div class="line">        <span class="string">'HOST'</span>: mydb.DB_HOST,                      <span class="comment"># Empty for localhost through domain sockets or '127.0.0.1' for localhost through TCP.</span></div><div class="line">        <span class="string">'PORT'</span>: mydb.DB_PORT,                      <span class="comment"># Set to empty string for default.</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>技巧</strong></p>
<p>可以使用python manage.py shell 进入一个交互环境，在这里可以测试一下增删改查等等。</p>
<p>django模型的使用是django框架学习比重非常大的一个地方，它实现了一套属于django自己的方式来操作数据库，包括增删改查，以及字段类型的定义，查询的技巧等等方式。</p>
<p>django中一个模型对应的是一张表，需要继承django.db中models类。</p>
<p>定义一个模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">x</span><span class="params">(models.Model)</span>:</span></div><div class="line">    u_name = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">    u_pass = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">    u_session = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">	u_status = models.IntegerField(max_length=<span class="number">1</span>,default=<span class="number">0</span>)</div><div class="line">   	<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p>CharField对应的是数据库中的varchar类型，而IntegerField对应的是int类型，自增主键，django为每一个模型定义了一个主键id。</p>
<p><strong>增</strong></p>
<p>要往表中插入一条数据，SQL的语句是INSERT INTO。而django则是实例一下定义的模型类，比如这里定义的x。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y = x(u_name=<span class="string">'123'</span>,u_pass=<span class="string">'a123'</span>,u_session=<span class="string">'123'</span>)</div><div class="line">y.save()</div></pre></td></tr></table></figure>

<p>最后调用一下save方法，来真正插入一条新的记录。</p>
<p><strong>查</strong></p>
<pre><code><span class="keyword">y</span> = <span class="keyword">x</span>.objects.<span class="built_in">filter</span>(u_name=<span class="string">'123'</span>)

<span class="keyword">y</span> = <span class="keyword">y</span>[<span class="number">0</span>]

<span class="keyword">print</span>(<span class="keyword">y</span>.u_name)
</code></pre><p><strong>改</strong></p>
<pre><code><span class="variable">y =</span> x.objects.filter(<span class="variable">u_name=</span>'<span class="number">123</span>')

<span class="variable">y =</span> y[<span class="number">0</span>]

y.<span class="variable">u_name =</span> <span class="number">456</span>

y.save()
</code></pre><p><strong>删</strong></p>
<pre><code><span class="keyword">y</span> = <span class="keyword">x</span>.objects.<span class="built_in">filter</span>(u_name=<span class="string">'123'</span>)

<span class="keyword">y</span> = <span class="keyword">y</span>[<span class="number">0</span>]

<span class="keyword">y</span>.<span class="built_in">delete</span>()
</code></pre><p><strong>其他，比如过滤，排序，更新多条数据，限制返回数据，连锁查询，获取单个对象等等，这些需要学习时间</strong></p>
<h2 id="django_view_template_的使用（6）">django view template 的使用（6）</h2>
<p>也许我们认为django是一个MTV框架，更加适合。M：模型 T：模板 V：视图。C的管理，由django内部去实现了。</p>
<p>在视图中文件中，需要导入视图相关的django组件，比如django.http 中的各类响应类，django.template中的与模板相关的类。</p>
<pre><code><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse
<span class="keyword">from</span> django.template <span class="keyword">import</span> Context,Template
<span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span>
    <span class="keyword">return</span> HttpResonse(<span class="string">'&lt;h1&gt;Hello&lt;/h1&gt;'</span>)
    <span class="keyword">pass</span>
</code></pre><p>这里写了一个hello视图函数，并在URLConf中配置好这个视图函数，即可在浏览器中查看这个页面了。</p>
<p><strong>视图函数中所使用的各种类，需要一定的时间学习。</strong></p>
<p>它不是最重要的，T才最重要的。</p>
<p><strong>简单基础</strong></p>
<p>django模板系统，对于逻辑的操作，需要用百分号，必须有结束语句。而赋值则是两个大括号。django的模板系统，是可以切换的。如果觉得原生自带的模板系统不够好用，可以在setting文件中重新配置要使用的模板系统。</p>
<p><strong>简单例子</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> Context,Template</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></div><div class="line">	t_html = Template(<span class="string">'''</span></div><div class="line">		&lt;h1&gt;&lt;/h1&gt;</div><div class="line">		</div><div class="line">	''')</div><div class="line">	c = Context({<span class="string">"wow"</span>:<span class="keyword">True</span>,<span class="string">"page"</span>:<span class="string">"Hello"</span>})</div><div class="line">	t_html = t_html.render(c)</div><div class="line">	<span class="keyword">return</span> HttpResponse(t_html)</div><div class="line">	<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p><strong>扩展：模板系统也是一个学习重点，中间有很多技巧性的问题，比如：导入，同一个模板多个上下文，过滤器等等</strong></p>
<h2 id="扩展部分">扩展部分</h2>
<ol>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>简单django中几个常用的组件</li>
<li>分享学习Python django的资料</li>
</ol>
<p>django提供了N多的web工具，例如：</p>
<pre><code>认证
缓存
日志
发送电子邮件
聚合供稿(RSS/Atom)
评论, 评论审核 和 自定义评论
分页
消息框架
序列化
Sessions
站点地图
静态文件管理
数据验证
</code></pre><p>django是一个大而全的框架，它提供了很多很多基本上包括了web开发中所需要的功能，学习它需要大量的时间。</p>
<p>学习django的基础，是学习好Python。</p>
<p><strong>人生苦短 我用Python</strong></p>
<p><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="external">Python 标准库</a> </p>
<p><a href="http://docs.pythonsprints.com/python3_porting/py-porting.html" target="_blank" rel="external">Python2x与Python3x对照表</a></p>
<p><a href="https://docs.djangoproject.com/en/1.6/" target="_blank" rel="external">Django API</a></p>
<p><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">一本django1.5电子书</a></p>
<p><a href="http://uliweb.clkg.org/tutorial/read/20" target="_blank" rel="external">简单的django学习</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用django快速开发一个web网站</p>
<p>分享内容（拟）</p>
<ol>
<li>介绍django的历史</li>
<li>安装以及配置django项目</li>
<li>介绍django对请求的回应机制</li>
<li>讲解django URL的配置</li>
<li>讲解django模型的使用</li>
<li>讲解django view template 的使用</li>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>分享学习Python django的资料，以及说说一些django的web工具</li>
</ol>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django静态资源配置的问题]]></title>
    <link href="http://lcepy.github.io/2014/11/14/django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lcepy.github.io/2014/11/14/django静态资源配置的问题/</id>
    <published>2014-11-14T12:16:20.000Z</published>
    <updated>2014-11-14T19:41:56.000Z</updated>
    <content type="html"><![CDATA[<p>在初始化一个django项目时，我还遇见了一个比较头疼的问题，静态资源的配置，硬编码问题。其实，按照正常的部署来说，静态资源，比如（.css .js img）等，应该另启动一个服务器，去做静态资源的处理，这样是非常常见的，和语言无关，脱离了动态开发内容，特别的适合做内容分发。但是，考虑到前期，我想能在django中集合这样的资源类型，于是，碰到了比较纠结的问题。另外，在django初始化的项目中，竟然还不能在注释中打中文，是不是很疼，没关系，往下看，能解决这样的问题。</p>
<a id="more"></a>

<p>其实，在django settings.py文件中，我们可以找到三个关于static的内容。STATIC_ROOT，STATIC_URL，STATICFILES_DIRS。于是，我在想，是不是就是配置这三项呢。</p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/settings/" target="_blank" rel="external">settings.py 官方给出的配置参数解释</a></p>
<p>顾名思义，我想在我的项目中利用django内置的服务器来处理静态资源，最能给我合理的参数应该是STATICFILES_DIRS。</p>
<p><strong>This setting defines the additional locations the staticfiles app will traverse if the FileSystemFinder finder is enabled, e.g. if you use the collectstatic or findstatic management command or use the static file serving view.</strong></p>
<p>从官方的解释上来看，这个设置，可以通过我的管理命令集来启动这个视图，那不是意味着，它可以读取我的静态资源呢。实践下来，配置上，我项目的绝对路径，成功。</p>
<p>当然，我看django的官方配置文件中所描述的方式，有多种，而上述是一个最容易搞定的方式，反正是开发，何必纠结呢。不建议，在部署时，也使用django的静态资源服务，这会增加很多压力。合理的安排，是另外启用一个静态资源服务器，专门存储这些静态资源。</p>
<p>在处理好静态资源之后，我想给这里添加一个注释，并写上中文。于是，我发现，出现了一个编码问题。后来查询了python官方的一个PEP，了解到原来，如果我的不是utf-8或者其他支持中文的编码，直接写上中文，那是报一个大大的错误的。</p>
<p><a href="http://legacy.python.org/dev/peps/" target="_blank" rel="external">Python 官方关于编码的PEP</a></p>
<p>在文件的头部写上#coding=utf-8即可，这一项2.7到3.x都是完美兼容的，如果现在学习python，建议最小选择从2.7.3开始，到3.x。2.7除了模块不一样名不一样，有很多内置函数，是继承到了3.x。当然如果，不考虑工作的话，我建议直接从python3.x开始学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在初始化一个django项目时，我还遇见了一个比较头疼的问题，静态资源的配置，硬编码问题。其实，按照正常的部署来说，静态资源，比如（.css .js img）等，应该另启动一个服务器，去做静态资源的处理，这样是非常常见的，和语言无关，脱离了动态开发内容，特别的适合做内容分发。但是，考虑到前期，我想能在django中集合这样的资源类型，于是，碰到了比较纠结的问题。另外，在django初始化的项目中，竟然还不能在注释中打中文，是不是很疼，没关系，往下看，能解决这样的问题。</p>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[减肥与训练]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%87%8F%E8%82%A5%E4%B8%8E%E8%AE%AD%E7%BB%83/"/>
    <id>http://lcepy.github.io/2014/11/14/减肥与训练/</id>
    <published>2014-11-14T12:11:56.000Z</published>
    <updated>2014-11-14T19:41:07.000Z</updated>
    <content type="html"><![CDATA[<p>训练的目的在于，训练自身的素质，为长距离骑行做准备。主要是训练意志力，大腿肌肉，胸部肌肉，以及肺活量。</p>
<p>我的训练计划有参考的价值，如下：</p>
<ol>
<li>第一个月每天晚上做20个抱头的仰卧起坐，15个双手水平放直的仰卧起坐。</li>
<li>第一个月每天晚上做10个俯卧撑。</li>
<li>每天下班之后来回骑行15-20公里。</li>
<li>训练之前，做热身运动。</li>
<li>一周内去健身房三次，听从专业教练的训练。（看情况）</li>
</ol>
<p>从目标的第一个月开始，逐月增加5的增量，训练最重要的是坚持，特别是意志力。这样的训练，最重要的是训练意志力，以及身体的素质。</p>
<p>另外一项属于文化类的训练，需要熟读交通指示牌，以及骑行手语。</p>
<p><a id="more"></a></p>
<h2 id="07-12">07-12</h2>
<p>从今天开始我准备了一项比较长久的减肥与训练计划，也是从今天开始我去健身房办理了一张健身卡，教练给我的建议有两项，一是减肥，二是练肌肉。基本同意这样的建议，于是开始着手这方面的准备。</p>
<p>第一次去训练，最开始10分钟在跑步机上热身，然后开始练器材，分三组，一组十个，包括了有仰卧起坐，练胸拉伸，练手臂的拉伸，做下来，真的很痛，第一次训练这些。</p>
<p>就是这样，第一次训练一起花了一个小时二十分钟的样子。</p>
<h2 id="07-13">07-13</h2>
<p>因为昨天的开始训练，把身上特别是手臂到胸的那个关节处，特别的痛，所以只在跑步机上跑了二十分钟。本来各项要练习三组，但是今天只练了一组，就练不起来了。</p>
<h2 id="07-16">07-16</h2>
<p>距上次在健身房练习，有三天没有去了，因为周一加班，周二又发布，所以周三才去。几天没有健身，感觉不是那么痛了，于是像第一次一样的开始练，感觉好像适应了一般，三组下来，没有任何的不适感，这倒是个好消息。</p>
<h2 id="07-17到07-20">07-17到07-20</h2>
<p>这几天都像往常一样，没有什么特别的事情，于是去了健身房，依然跟第一次一样，各三组，但是我发现好像没有什么效果，还是65公斤，想想，这不科学啊，是不是哪里出了什么问题，问了问教练，也去知乎上搜了大量的资料，原来发现减肥除了运动还跟吃，也就是食物有关系。</p>
<h2 id="07-22">07-22</h2>
<p>在考虑了两天之后，我重新制定了一份计划，包括健身，食物。也从8月开始，就不跟大家一起吃饭了。健身计划按月为一个分界线，开始往上逐渐递增。我的计划就是，在七月份的最后一周内，仰卧起坐三十个，分三组。练手臂肌肉拉伸，50个分四组，前两组15，后两组10.练胸肌肉拉伸（扩胸）为35个，前一组为15个，后两组为10个，另外还多了一项，虽然我暂时不知道它叫什么，依然是35个，前一组15个，后两组为10.并且我重新调整的训练秩序，从家里走到健身房为热身，先练器材，最后跑步。而跑步我的分钟为25分钟连续跑。</p>
<h2 id="07-23到07-24">07-23到07-24</h2>
<p>这两天我在研究食物，到底怎么吃才能配合健身能到达更好的效果，初步出了一个方案，这两天的健身从22开始，持续。怎么吃，我写在最后。</p>
<h2 id="07-25">07-25</h2>
<p>从今天开始，我跑又重新做了一份调整，时间为25分钟并且增加了10分钟练习自行车。</p>
<h2 id="07-26到07-27">07-26到07-27</h2>
<p>07-22的计划未变，持续。去看重量的时候，感觉少了2斤，我吃了饭。</p>
<h2 id="07-28">07-28</h2>
<p>今天去健身房本来打算依然像昨天那样训练，只是练完器材之后，跑步机真心不爽，跑了5分钟就走了。</p>
<h2 id="08-03">08-03</h2>
<p>上周一周的时间都在加班，所以没有进行训练，今天去训练，为了适应，跑步做了时间上的减少，为15分钟，其他照就。</p>
<h1 id="附件：怎么吃才能配合健身达到更好的效果">附件：怎么吃才能配合健身达到更好的效果</h1>
<p>07-28今天花了一天的时间在琢磨食谱，到底怎么吃才能达到效果，于是有了这些减肥食物的控制理论，蔬菜水果粗粮为主，并且辅助大量的运动与器材训练，另外还要戒烟戒酒，特别是烟和啤酒，烟中有大量的尼古丁，啤酒特别容易肥肚子，我的食物安排是这样的，而且是一日多餐。</p>
<p>早餐的食物，为脱脂牛奶，燕麦片或者无糖黑芝麻糊。牛奶就不用说了，不充蛋白质。而燕麦片是粗粮，主要来促进肠胃。</p>
<p>中午的食物，为粗粮，如玉米，大麦等。如果有玉米则吃玉米，另外西红柿一个，黄瓜三到四根，玉米两个。下午三点半左右，吃一个水果，一些坚果。</p>
<p>晚餐则是食谱类的，主要是汤，炒，凉拌，这里我做了一下分类，原则上，晚餐才吃米饭和菜。搭配上为一炒一汤，或者一凉拌一汤。汤主要为清煮类，全部少量盐。</p>
<p>青菜豆腐汤，材料为青菜，豆腐，葱花，少量盐与胡椒，清煮。</p>
<p>冬瓜肉丝汤（原则上，一周只能一次），材料为冬瓜，猪肉，猪肉切成丝，少量，先要用热开水沸煮，去掉脂肪等，然后搭配冬瓜，少量盐，胡椒，葱花。</p>
<p>西红柿豆腐汤，材料为西红柿，豆腐，少量盐，清水煮，配上葱花。</p>
<p>魔芋汤，魔芋切片，清煮，不放盐。</p>
<p>爆辣椒，材料为青辣椒，生姜，大蒜，辣椒拍烂，配上生姜，大蒜，爆炒。</p>
<p>大蒜炒空心菜，材料为空心菜，大蒜，爆炒。</p>
<p>闷南瓜，材料为南瓜，少量水煮，一直闷熟。</p>
<p>凉拌黄瓜，材料为黄瓜，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>凉拌海带，材料为海带，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>凉拌莴笋，材料为莴笋，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>清炒长豆角，或者清炒四季豆，清炒，少量盐。</p>
<p>家常豆腐皮，材料为豆腐皮，青辣椒，少量玉米油清炒。</p>
<p>酸辣土豆丝，配少量醋，豆豉辣椒油，青红辣椒丝，清炒。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>训练的目的在于，训练自身的素质，为长距离骑行做准备。主要是训练意志力，大腿肌肉，胸部肌肉，以及肺活量。</p>
<p>我的训练计划有参考的价值，如下：</p>
<ol>
<li>第一个月每天晚上做20个抱头的仰卧起坐，15个双手水平放直的仰卧起坐。</li>
<li>第一个月每天晚上做10个俯卧撑。</li>
<li>每天下班之后来回骑行15-20公里。</li>
<li>训练之前，做热身运动。</li>
<li>一周内去健身房三次，听从专业教练的训练。（看情况）</li>
</ol>
<p>从目标的第一个月开始，逐月增加5的增量，训练最重要的是坚持，特别是意志力。这样的训练，最重要的是训练意志力，以及身体的素质。</p>
<p>另外一项属于文化类的训练，需要熟读交通指示牌，以及骑行手语。</p>
<p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://lcepy.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的项目经历]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    <id>http://lcepy.github.io/2014/11/14/我的项目经历/</id>
    <published>2014-11-14T12:09:19.000Z</published>
    <updated>2015-01-09T10:48:08.000Z</updated>
    <content type="html"><![CDATA[<p><em>开源项目，可以在 github 查看，主要分为两类项目，一类为给公司开发的开源工具，用来前端的编程效率，一类为自己的学习项目，比如桌面端的MVC一套解决方案，移动组件库，以及个人项目。</em></p>
<p><em>擅长领域，主要为javascript，python，关系型数据库为mysql mongodb 工作中以javascript为主。</em></p>
<h2 id="个人项目展示">个人项目展示</h2>
<p><a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">HTTP Proxy</a></p>
<p><a href="https://github.com/lcepy/kalimdor" target="_blank" rel="external">kalimdor MVC</a></p>
<p><a href="https://github.com/lcepy/Find" target="_blank" rel="external">Find zepto UI</a></p>
<p><a href="https://github.com/lcepy/nagrand" target="_blank" rel="external">nagrand onload</a></p>
<p><a href="https://github.com/lcepy/douban-shell-app" target="_blank" rel="external">douban-shell</a></p>
<p><a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">webapp 打包工具</a></p>
<p><a id="more"></a></p>
<h2 id="携程">携程</h2>
<p><em>在线项目为携程H5站点，hybrid app。H5站点地址 : </em><a href="http://m.ctrip.com/webapp/cruise/index.html" target="_blank" rel="external">H5</a><em> hybrid app IOS可以在app store中下载，安卓可以在各大安卓市场下载，负责cruise的移动端开发</em></p>
<h5 id="2014年10月15日到2014年11月18日_CRUISE_H5_Hybrid_6-0（邮轮）">2014年10月15日到2014年11月18日 CRUISE H5 Hybrid 6.0（邮轮）</h5>
<p>主要邮轮产品详情页，邮轮岸上游详情页，修复H5跳Hybrid，增加在搜索页定位图标，增加常见问题页FAQ。迁移首页，列表，搜索页三个页面到新版2.1框架，支持首页，列表页的SEO</p>
<h5 id="2014年9月15日到2014年10月9日_CRUISE_H5_Hybrid_5-10（邮轮）">2014年9月15日到2014年10月9日 CRUISE H5 Hybrid 5.10（邮轮）</h5>
<p>主要负责把搜索与筛选的业务逻辑全部修改为联调机制，并且在搜索中，增加途径国家，增加多级的搜索，列表页需要支持URL参数并且支持SEO，修改首页的地理位置定位与默认参数的逻辑，制作一个新的营销CR页面。</p>
<p><strong>让用户从之前的单个搜索，筛选，变更为在同一个view中进行搜索与筛选，不切换view在体检上就不会感觉到很麻烦。</strong></p>
<h5 id="2014年8月9日到9月11日_CRUISE_H5_Hybrid_5-9（邮轮）">2014年8月9日到9月11日 CRUISE H5 Hybrid 5.9（邮轮）</h5>
<p>主要负责重构邮轮首页，列表页，搜索页以及筛选的业务逻辑，中间修改了广告营销，预定咨询页，修复5.8bug以及新增需求。</p>
<p><strong>帮助同事进行源代码重构，分享一些过往的开发经验。</strong></p>
<h5 id="2014年7月7日到2014年8月5日_CRUISE_H5_Hybrid_5-8（邮轮）">2014年7月7日到2014年8月5日 CRUISE H5 Hybrid 5.8（邮轮）</h5>
<p>主要是新接手同事的列表，搜索排序，筛选排序，新做了订单意向单，邮轮详情页中的行程介绍，岸上游详情介绍，修复5.7bug以及新增需求。</p>
<h5 id="2014年5月21日到2014年6月27日_CRUISE_H5_Hybrid_5-7（邮轮）">2014年5月21日到2014年6月27日 CRUISE H5 Hybrid 5.7（邮轮）</h5>
<p>主要是负责邮轮的整个订单部分，分为订单第一步，选择班期。订单第二步，选择房型。订单第三步，填写常用联系人，并核算消费明细等。配套的有，常用旅客的选择，编辑，新增，另外两项功能性选择，为保险多选选择，岸上游单选选择，并且提交支付。<br>中间的逻辑（不复述了）</p>
<p><strong>解决了携程邮轮在无线端下订单从无到有的开始。</strong></p>
<h5 id="2014年4月25日到2014年5月19日_CRUISE_H5_Hybrid_5-6（邮轮）编写了两个工具">2014年4月25日到2014年5月19日 CRUISE H5 Hybrid 5.6（邮轮）编写了两个工具</h5>
<p>主要是负责了第一版邮轮的订单意向单，预定须知，签证签出。在当时的开发环境下为其他开发人员编写了两个工具，一个工具是HTTP代理服务器用来模拟数据（nodejs）这个已经提交在个人github中，项目名为glob-proxy，另外一个是给组长编写的excels导入工具（python）</p>
<p>时间：<strong>2014(04-25到05-02)</strong></p>
<h4 id="excels导出工具">excels导出工具</h4>
<p><em>基于python编写的excels导出GUI工具，根据SOAP协议远程调用query，生成excels报表。</em></p>
<p><strong>是帮助当时的开发经理从项目日志中，导出excels表。</strong></p>
<p>时间：<strong>2014(05-5到05-10)</strong> </p>
<h4 id="glob-proxy">glob-proxy</h4>
<p><em>基于nodejs的HTTP请求代理服务器，根据映射表，实现在本地的mock，提交远程GET POST请求，支持H5跨域，支持对远程请求数据的内存缓存与物理缓存，实现对内存缓存的管理，根据打分机制来自动释放，使用度不高的请求缓存。</em></p>
<p><strong>解决了当时开发团队在开发方式上的困难，因为前后不同步的原因，需要经常在模型层中修改请求地址，或是在本地自己模拟假数据。这个工具的出现，则统一由代理服务器去切换请求地址或者在本地生成mock数据。</strong></p>
<p>源代码仓库：<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a></p>
<p><strong>2014年3月10日到4月11日 门票 H5 Hybrid 5.5</strong></p>
<p>当时主要是负责了门票详情页，预定须知，点评，地图交互，景点介绍</p>
<p><strong>2014年2月12日到3月3日  机票 H5 Hybrid 5.5  编写了一个工具</strong></p>
<p>当时在机票主要是负责从用户订取机票的时间与航空公司的上下班时间中分析出一个合理的时间区间数组来。<br>打包工具主要是根据SOAP协议来调取webapp包地址，多线程下载完成之后重新打包。现工具已经在提交在个人github上，项目名为downloadZIP</p>
<p><strong>关于时间区间的分析，根据航空公司上下班时间与用户自己期望的时间分析出一个合理的时间数组，让用户可以清晰的了解到取票的时间范围。</strong></p>
<p>时间：<strong>2014(02-12到02-18)</strong></p>
<h4 id="downloadZIP">downloadZIP</h4>
<p><em>说明：基于python编写的webapp打包工具，根据SOAP协议来远程调用query查询获取webapp包地址，根据包地址下载，解压，重新打包为一个webapp zip文件。此工具为GUI工具，下载为多线程后台下载。</em></p>
<p><strong>解决了不同版本的APP打包的问题</strong></p>
<p>源代码仓库：<a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">downloadZIP</a></p>
<h2 id="万言网（兼职）">万言网（兼职）</h2>
<p>2013年11月15日-2013年12月24日：设计移动端体系，并负责开发第一版，万言网投票达人触屏版<br>应用参考地址：（开发测试地址） <a href="http://m.wanyan.com" target="_blank" rel="external">http://m.wanyan.com</a> （投票，数据分析功能需要注册登录）</p>
<p>2013年10月13日-2013年11月10：重新设计桌面前端体系，并负责开发言交所项目。<br>应用参考地址： <a href="http://www.wanyan.com/yanex" target="_blank" rel="external">http://www.wanyan.com/yanex</a> (需注册登录)</p>
<p><em>万言项目的在线地址：</em><a href="http://www.wanyan.com/" target="_blank" rel="external">wanyan</a></p>
<p>万言网投票H5移动端，桌面版 时间：<strong>2013(10-13)-2014(01-10)</strong></p>
<p><em>说明：重新设计了桌面端的架构实现，组织了模块化，以及客户端MVC对应的RESTFU路由请求模块，应用自动化打包，检测等工具。此项目设计，应用在万言网的言交所项目，其他需要SEO页面，则组织了通用模板，一套模板应用在服务端，客户端两端。而万言网的移动触屏版，投票达人应用，在桌面版架构实现的基础上，简化了代码量与性能提升，增加了UI组件库，本地存储系统，单页实现。SEO依然是通用模板，根据URL请求来识别是否是搜索引擎，还是用户正常点击，来切换模板。</em></p>
<p>内部打分收集系统 时间 <strong>2013(12-10)-2014(01-10)</strong></p>
<p><em>说明：基于python django mysql的后台打分收集系统，根据用户的反馈情况，来评分。提供给运营人员查看，编辑，分析。主要的业务逻辑，在于整套数据的评分，以及优质内容的评定。</em></p>
<p><strong>在兼职期间把万言网的PC端的架构重写，并且运用在投票达人，言交所这两个大的板块中。另解决了移动浏览器项目的开发选型，组织框架，应用了投票达人的移动试用版。</strong></p>
<h2 id="回湖南时">回湖南时</h2>
<p><strong>2013年9月-2013年10月：开发了一套可以应用在企业级应用中的mvc框架与解决方案</strong></p>
<p>主要根据之前两年左右的企业级应用开发经验，做了这么一套东西，可以适用在财务报表，财务分析，等报表类企业级b/s应用中。<br>源代码仓库：<a href="https://github.com/lcepy/kalimdor" target="_blank" rel="external">kalimdor</a></p>
<h2 id="远光软件">远光软件</h2>
<p><em>在远光软件的工作，主要是企业级开发，管理，报表分析系统，均部署在两网五大发电集团内部，无在线地址。</em></p>
<p>项目：<strong>基于EAP2.0平台重构费用报销系统</strong> 时间：<strong>2013年8月初－8月底</strong></p>
<p><em>费用报销系统</em>：费用报销系统是以单据为节点，用于费用的报销，领导审批，会签，查看等。主要负责了界面UI开发，数据表渲染，单据绘画，基础存储模块，待办事项模块，单据查询模块。工具栏中的查看单据，上载资料，审批传递。单据中的样式表部分。</p>
<p>项目：<strong>EAP2.0平台seeker2.0平台框架开发与迁移旧系统到新平台框架下</strong> 时间：<strong>2013(03-08)</strong> </p>
<h4 id="平台开发说明">平台开发说明</h4>
<p>主要负责</p>
<ol>
<li>平台下的各个产品通用存储控制层。</li>
<li>MVC中的模型解析引擎，模型解析引擎，是以原始定义的元数据为基础，匹配框架自动填充的容器，来对应每一项。此项工作，还包括基础定义，与服务端取数，主要用于模型层的的解析以及存储各项提供给框架内部使用的存储容器。</li>
<li>用于数据表与样式表中触发是否有联级关系的项目，当存在联级项目时，触发此引擎工作。存储在公共容器中，多事件触发器组成，比如关闭单据时，触发此事件，以检测单据中的样式表与数据是否有数据变更的检测机制。</li>
<li>平台下各产品通用的基础消息用于统一的消息提示api，以及各项操作之后的动作返回。</li>
<li>用于平台框架下各控件的统一api调用，以及各控件之间的交互的UI基类。</li>
<li>用于各项单据中的验证，比如输入长度，是否为数据等各项在存储之前的验证检索验证机制。</li>
<li>控件开发，包括组合的对象控件：业务对象，部门对象，选择对象，银行对象，对话框，样式表数据表的隐藏域，基于父子关系的上下级模块。</li>
<li>基于seeker2.0框架，费用报销系统改造与升级工程。</li>
</ol>
<p><strong>在seeker2.0中，主要是将模型更加的通用化，平衡了在SMB所有产品关于调用API的规范化，并且把组件全部重写。另外把费用报销系统改造升级后，写了关于升级应用的PPT，和同事两个人，在评审中给领导讲解，以及给其他小组的同事培训如何运用。</strong></p>
<p>项目：<strong>费用报销系统，工程管理系统，核算系统</strong> 时间：<strong>2012（07-12）</strong></p>
<h4 id="负责开发说明">负责开发说明</h4>
<p><em>费用报销系统开发：</em>费用报销系统是以单据为节点，用于费用的报销，领导审批，会签，查看等。主要负责了界面UI开发，数据表渲染，单据绘画，基础存储模块，待办事项模块，单据查询模块。工具栏中的查看单据，上载资料，审批传递。单据中的样式表部分。</p>
<p><em>工程管理系统开发：</em>以费用报销系统为模版，增加了科目，预算体系，账目汇总等功能。主要负责了科目体系，与账目汇总。其余由，费用报销系统改动。</p>
<p><em>核算系统：</em>以费用报销系统为模版，增加了工程合同，审批等功能。主要负责了，会签审批这个功能。</p>
<p><strong>在这三个业务系统的开发中，最主要的贡献是解决了单据报表的绘画工作，主要是扩展和改进了当时的百度编辑器，让它更加的适应于企业财务人员的使用习惯。</strong></p>
<p>项目：<strong>seeker1.0框架开发</strong> 时间：<strong>2012(05-07)</strong></p>
<h4 id="负责开发说明-1">负责开发说明</h4>
<p>基于jqGrid的网格系统二次开发，开发单据设计器，比如：一键应用，选择单据项目，单据选择器，单据绘制等等，此部分应用在核算桌面软件中。seeker1.0主要是负责MVC，模型解析引擎的开发，与UI插件库的开发。此版本框架只应用于1.0版本的费用报销系统与其相应改动的其他系统。</p>
<p><strong>解决了当时在报表系统中，网格化表格的应用。加入SMB团队之后，加速了seeker1.0的开发进程，利用这个框架，三个人写了初版的费用报销系统，奠定了seeker1.0应用的模板。</strong></p>
<h2 id="湖南日报华声在线-教育频道">湖南日报华声在线-教育频道</h2>
<p><em>几年过去了，在线地址以及开发内容已经变更，这里不在提供。</em></p>
<p>项目：<strong>快乐学习网社交空间 新闻频道，作文频道，视频频道</strong> 时间：<strong>2011(08)-2012(04)</strong></p>
<h4 id="负责说明">负责说明</h4>
<p>快乐学习网社交空间，工作的内容是负责了全站的前端开发任务，空间类似于2011年的QQ空间。负责教育产品，社交空间的前端开发，培训组内的前端技术，并提供教育系列产品的前端解决方案，并负责一定的服务端开发工作，主要是拼写模板。</p>
<p>当时的站点，是基于jQuery编写的，使用的是jQuery1.4。</p>
<p><strong>第一次参加工作，这个阶段皆以学习琢磨为主，在当时的团队中，是主要的程序开发者，根据python的模板的特点，引入了jQuery_Template模板，改变了团队开发程序的形式，模板从服务端移到了在前端实现。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>开源项目，可以在 github 查看，主要分为两类项目，一类为给公司开发的开源工具，用来前端的编程效率，一类为自己的学习项目，比如桌面端的MVC一套解决方案，移动组件库，以及个人项目。</em></p>
<p><em>擅长领域，主要为javascript，python，关系型数据库为mysql mongodb 工作中以javascript为主。</em></p>
<h2 id="个人项目展示">个人项目展示</h2>
<p><a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">HTTP Proxy</a></p>
<p><a href="https://github.com/lcepy/kalimdor" target="_blank" rel="external">kalimdor MVC</a></p>
<p><a href="https://github.com/lcepy/Find" target="_blank" rel="external">Find zepto UI</a></p>
<p><a href="https://github.com/lcepy/nagrand" target="_blank" rel="external">nagrand onload</a></p>
<p><a href="https://github.com/lcepy/douban-shell-app" target="_blank" rel="external">douban-shell</a></p>
<p><a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">webapp 打包工具</a></p>
<p>]]>
    
    </summary>
    
      <category term="项目经历 长期维护" scheme="http://lcepy.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86-%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在实际工作中node开发的一些见解与调试]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%9C%A8%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E4%B8%ADnode%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%81%E8%A7%A3%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://lcepy.github.io/2014/11/14/在实际工作中node开发的一些见解与调试/</id>
    <published>2014-11-14T12:04:45.000Z</published>
    <updated>2014-11-14T19:40:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>真实情况是这样的</strong> </p>
<ol>
<li>开发，前端与后端物理性的隔离，前端通过restful接口请求相应的数据，并在客户端渲染。</li>
<li>前端的渲染依赖于后端响应的数据，后端开发的进度永远比前端慢。</li>
<li>需要通过本地模拟数据，约定契约总是会纠结很久。</li>
<li>联调时，需要改多处代码。</li>
</ol>
<p><strong>治标不治本的解决方案</strong></p>
<p>为了解决工作中的上述问题，于是就想到了网络代理与客户端mock的功能，并且能很好的识别出错误，以及分发请求，<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a>。通过一对键值对来描述需要响应的请求，通过GET参数来适配读取本地，还是分发到网络，并对响应的请求response进行内存缓存与物理缓存。本地构建的元数据，可以使用mock来生成。</p>
<p>但是上述的解决方案，并没有解决工作中出现的问题。反而加重了开发的成本，问题3，依然没有很好的解决，而问题4解决了一半，联调时依然需要更改多处，不然提交到测试的代码，还是键值对中映射的地址，虽然我的本机可以访问，但是测试人员却访问不了。</p>
<p>上遇到上述问题的时候，我一直在想，是不是需要另外启用一个服务器来做代理的代理。我实现了上述需要解决的几个问题，比如分解model.js中测试地址，将这个测试地址，生成为一个配置文件，提供给代理服务器2，代理服务器1依然是之前的配置文件。在webapp发起请求时，代理服务器1截取请求，提交给代理服务器2，代理服务器2获取完毕后，发送给远程。</p>
<p>这个问题好像，滚雪球一样，越滚越大。后来，我的同事找到了一个比较好的方案，我编写的一半socket proxy基本上可以废弃了。我们使用了fiddler来做代理服务器1.</p>
<p>这里的逻辑是这样的，在启动glob-proxy时，我提供了两个API出来，一是：抓取配置文件中的model.js，根据测试URL生成fiddler需要的xml配置文件，并将这个xml导入到fiddler中。如果是local=1，glob-proxy将扫描本地文件，来做响应。如果local为false，请求将通过glob-proxy发送到fiddler中，fiddler去请求远程，来响应node服务器，node服务器再响应给webapp。</p>
<p>好在上述，难的地方已经处理好了，现在要理清的还是这个请求代理的逻辑顺序。但是这样的绕，是不是有些比较蛋疼呢。<br><a id="more"></a><br><strong>好好整理了资料，并思考了一个问题</strong></p>
<p>通常情况下，我们的webapp还需要解决SEO的问题，基本上来说这是一个无解的过程。ajax请求在客户端渲染的webapp，对搜索引擎并不友好。而且与后端的约定契约问题，也让人头疼。我在想，既然nodejs的出现，为什么不能把职能划分的更加请求，把契约留给前端的开发人员不是更加的合理？</p>
<p>带着这样的疑问，上网搜索了很多资料，包括淘宝那边提出并实现的<a href="http://ued.taobao.org/blog/category/bowen/frontend/" target="_blank" rel="external">前后端分离</a>比较受到启发。</p>
<p><strong>说说我的感觉</strong></p>
<p>我们的公司是.net做的基础平台，如果能让.net去更加的专注于数据模型，而前端开发人员通过请求代理，或者socket编程来访问数据模型，自己定义相应的数据，自己选择是否在客户端渲染，还是在服务端渲染，这样的形式，岂不是更加的合理？中间消除了，大量的问题。</p>
<ol>
<li>与后端沟通的问题</li>
<li>再也不需要契约，或者glob-proxy了</li>
<li>解决了SEO的问题</li>
<li>根据模板，跨终端。因为javascript的模板，可以在客户端，服务端两处进行渲染工作。</li>
</ol>
<p>web安全性与性能方面的考虑，或许是对前端开发人员的一种制约。请求=消耗，这样的消耗是不是用户能接受的？这样的工作方式，是不是能节约成本，并且对整体项目是不是有益处的。而且安全性方面，可以考虑把node这一层，在前期做为一个代理层，node只处理表面的数据，最终通过SOAP或者SOCKET提交给.net平台去做验证？而web上的安全性考虑，比如CSRF XSS这些都可以放在node这一层来做。</p>
<p>我觉得这样的方式，是可行的。对于公司而言，那4个问题最大的成本，而对开发者来说，那4个问题很烦。</p>
<h1 id="node_debug">node debug</h1>
<blockquote>
<p>npm install -g supervisor</p>
<p>npm install -g node-inspector</p>
</blockquote>
<p>这两个工具，在nodejs开发中是非常有用的，debug并不是太难，写这个的原因，是想记录下来。首先，安装这两个模块，全局模式。如果是linux或mac系统，输入sudo给予权限即可。</p>
<p>一般情况下node-inspector使用默认端口8080，当然也可以改变端口。输入node-inspector —help，可以查看命令行的帮助信息，如：『截取了部分帮助信息』</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">-help</span></div><div class="line"></div><div class="line">-<span class="ruby">-version</span></div><div class="line"></div><div class="line">-<span class="ruby">-web-port={number}</span></div><div class="line"></div><div class="line">-<span class="ruby">-web-host={string}</span></div><div class="line"></div><div class="line">-<span class="ruby">-debug-port={number}</span></div></pre></td></tr></table></figure>

<p>如果想要改变端口，可以在命令行中输入node-inspector —web-port=xxx —debug-port=xx。<br>而supervisor，则是一个非常有用的监听工具，能帮助我们重启node服务。我一般的做法是与node-inspector配合使用。比如，我会先开启一个debug的端口。node-inspector —web-port=8055 默认的debug端口依然是5858。然后在chrome中打开<a href="http://127.0.0.1:8080/debug?prot=5858，调出debug页面。然后另外启用一个命令行，输入supervisor" target="_blank" rel="external">http://127.0.0.1:8080/debug?prot=5858，调出debug页面。然后另外启用一个命令行，输入supervisor</a> —debug xx.js来运行这份debug监听。</p>
<p><em>主题配置采用的是 theme flatland</em></p>
<ol>
<li>配置SublimeREPL编译器环境，运行在编辑器内运行PYTHON，编译器环境可选，不一定是PYTHON。<a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">下载</a></li>
<li>配置python语法智能提示，当然也不仅仅是PYTHON的语法智能提示<a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="external">下载</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>真实情况是这样的</strong> </p>
<ol>
<li>开发，前端与后端物理性的隔离，前端通过restful接口请求相应的数据，并在客户端渲染。</li>
<li>前端的渲染依赖于后端响应的数据，后端开发的进度永远比前端慢。</li>
<li>需要通过本地模拟数据，约定契约总是会纠结很久。</li>
<li>联调时，需要改多处代码。</li>
</ol>
<p><strong>治标不治本的解决方案</strong></p>
<p>为了解决工作中的上述问题，于是就想到了网络代理与客户端mock的功能，并且能很好的识别出错误，以及分发请求，<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a>。通过一对键值对来描述需要响应的请求，通过GET参数来适配读取本地，还是分发到网络，并对响应的请求response进行内存缓存与物理缓存。本地构建的元数据，可以使用mock来生成。</p>
<p>但是上述的解决方案，并没有解决工作中出现的问题。反而加重了开发的成本，问题3，依然没有很好的解决，而问题4解决了一半，联调时依然需要更改多处，不然提交到测试的代码，还是键值对中映射的地址，虽然我的本机可以访问，但是测试人员却访问不了。</p>
<p>上遇到上述问题的时候，我一直在想，是不是需要另外启用一个服务器来做代理的代理。我实现了上述需要解决的几个问题，比如分解model.js中测试地址，将这个测试地址，生成为一个配置文件，提供给代理服务器2，代理服务器1依然是之前的配置文件。在webapp发起请求时，代理服务器1截取请求，提交给代理服务器2，代理服务器2获取完毕后，发送给远程。</p>
<p>这个问题好像，滚雪球一样，越滚越大。后来，我的同事找到了一个比较好的方案，我编写的一半socket proxy基本上可以废弃了。我们使用了fiddler来做代理服务器1.</p>
<p>这里的逻辑是这样的，在启动glob-proxy时，我提供了两个API出来，一是：抓取配置文件中的model.js，根据测试URL生成fiddler需要的xml配置文件，并将这个xml导入到fiddler中。如果是local=1，glob-proxy将扫描本地文件，来做响应。如果local为false，请求将通过glob-proxy发送到fiddler中，fiddler去请求远程，来响应node服务器，node服务器再响应给webapp。</p>
<p>好在上述，难的地方已经处理好了，现在要理清的还是这个请求代理的逻辑顺序。但是这样的绕，是不是有些比较蛋疼呢。<br>]]>
    
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
</feed>
