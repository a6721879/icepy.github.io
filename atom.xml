<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[lcepy]]></title>
  <subtitle><![CDATA[曾记否，到中流击水，浪遏飞舟!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://lcepy.github.io/"/>
  <updated>2014-11-14T19:42:21.085Z</updated>
  <id>http://lcepy.github.io/</id>
  
  <author>
    <name><![CDATA[lcepy]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[正则的一些理解]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%AD%A3%E5%88%99%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://lcepy.github.io/2014/11/14/正则的一些理解/</id>
    <published>2014-11-14T13:50:22.000Z</published>
    <updated>2014-11-14T19:41:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天写到这里，是想总结一下，自己重新学习正则表达式之后，对它的一个全新的认识。我想描述一个中心思想，学习任何东西，编程，音乐，基础是非常important的，就好像吉他里基础不在于认识六线谱而是在于节拍。</p>
<h2 id="从人类的角度来阅读正则">从人类的角度来阅读正则</h2>
<p>在写代码示例之前，我描述一个正确的阅读正则表达式的方式，也许有点反人类，从右往左读。我很喜欢正则表达式，就像我喜欢python一样，因为它给了我一个很快速处理字符的能力。python中也有很多高效处理字符串的方式，比如步距，比如正则，嘿嘿。</p>
<p>import re</p>
<p>g = re.search(‘\d+(.\d*)?’,’0.2556223.556655’)</p>
<p>g.group(0)</p>
<p>我们来看一个搜索浮点数的正则，我们从右往左看，把这一个正则表达式分割成三分，\d+，(.\d<em>)，?。我们知道?描述的是出现零次或一次，在这里阅读的时候，是描述(.\d</em>)这一个组会出现零次或一次。我们再看这个组中的描述.用来描述.，\d用来描述0-9的数字，而*描述的是出现零次或多次，我们组合起来看，这个组就是来描述.后面的数字会出现零次或多次。\d依然是用来描述0-9的数字，+用来描述出现一次或多次。</p>
<p>到这里，我们把这三个部分，从右往左看，组合起来，用人类阅读的角度去描述它：小数点后面出现的数字是多次的，而这一个部分只能出现一次或零次，并且在小数点之前可以出现一次或多次的数字。<br><a id="more"></a><br>那么让我们看一个搜索邮件的正则：</p>
<p>import re</p>
<p>g = re.search(‘\w+@\w+.com’,’ww@ww.com’)</p>
<p>g.group(0)</p>
<p>依然在描述它时，分割开来，从右往左去描述，.com的字符串，\w描述任意字符，+的左边为\w，描述为出现一次或多次的字符。@的字符串，+的左边为\w，描述为出现一次或则多次的字符。</p>
<p>我依然把这三个部分，组合起来阅读，描述为：.com的左侧允许出现一次或多次的字符，左侧连接@，并且@的左侧允许出现一次或多次的字符。</p>
<p>升级一下，匹配存在子域的邮件：</p>
<p>import re</p>
<p>g = re.search(‘\w+@\w+(.\w+)?.com’,’ww@ww.ww.com’)</p>
<p>g.group(0)</p>
<p>从右往左来描述：.com的字符串，?左侧的(.\w+)描述为：(.后的字符可能出现一次或多次)但是它只能出现一次或零次。\w+，描述为字符串一次或多次。@的字符串，\w+，依然描述为字符串出现一次或多次。</p>
<p>把这几个部分合起来，描述：.com的左侧允许出现[.一次或多次的字符]= a，而a左侧[允许出一次或多次的字符] = b，b的左侧为@，@的左侧允许出现一次或多次的字符。</p>
<p>这样，一段复杂的表达式，往往可以通过分解的步骤来阅读它，但是，它需要基础，基础在于对这些特殊字符，元，的了解。再复杂的正则，也可以从左往右来阅读它，并用人类的语言，写在纸上，这会是一个非常棒的方式。</p>
<p>我喜欢，写在纸上，它让我对这一个部分，非常的清晰，了解，不信，可以试试？</p>
<p><strong>注释：因为是python的正则，所以去掉了一些特殊的</strong></p>
<h2 id="认识常用的基础">认识常用的基础</h2>
<p>字符 | 描述</p>
<p>.|匹配任意字符，除(\n)之外的字符</p>
<p>\ | 转意字符</p>
<p>[…] | 字符集</p>
<p>0-9|匹配0-9的数字</p>
<p>a-z A-Z|匹配从a到z的字符</p>
<p>预定义字符集 | 描述</p>
<p>\d | 匹配数字</p>
<p>\w | 匹配字符</p>
<p>\s | 匹配空格符</p>
<p>数量词 | 描述</p>
<p>* | 出现零次或多次</p>
<p>+ | 出现一次或多次</p>
<p>? | 出现零次或一次</p>
<p>{n} | 出现n次</p>
<p>{n,m} | 出现n次或m次</p>
<p>边界匹配 | 描述</p>
<p>^ | 在开始位置</p>
<p>$ | 在结束位置</p>
<p>逻辑 | 描述</p>
<p>|  逻辑或</p>
<p>()组 为一个子组，必须存在，才匹配</p>
<p>[]列 可以为出现任意一个，都匹配</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天写到这里，是想总结一下，自己重新学习正则表达式之后，对它的一个全新的认识。我想描述一个中心思想，学习任何东西，编程，音乐，基础是非常important的，就好像吉他里基础不在于认识六线谱而是在于节拍。</p>
<h2 id="从人类的角度来阅读正则">从人类的角度来阅读正则</h2>
<p>在写代码示例之前，我描述一个正确的阅读正则表达式的方式，也许有点反人类，从右往左读。我很喜欢正则表达式，就像我喜欢python一样，因为它给了我一个很快速处理字符的能力。python中也有很多高效处理字符串的方式，比如步距，比如正则，嘿嘿。</p>
<p>import re</p>
<p>g = re.search(‘\d+(.\d*)?’,’0.2556223.556655’)</p>
<p>g.group(0)</p>
<p>我们来看一个搜索浮点数的正则，我们从右往左看，把这一个正则表达式分割成三分，\d+，(.\d<em>)，?。我们知道?描述的是出现零次或一次，在这里阅读的时候，是描述(.\d</em>)这一个组会出现零次或一次。我们再看这个组中的描述.用来描述.，\d用来描述0-9的数字，而*描述的是出现零次或多次，我们组合起来看，这个组就是来描述.后面的数字会出现零次或多次。\d依然是用来描述0-9的数字，+用来描述出现一次或多次。</p>
<p>到这里，我们把这三个部分，从右往左看，组合起来，用人类阅读的角度去描述它：小数点后面出现的数字是多次的，而这一个部分只能出现一次或零次，并且在小数点之前可以出现一次或多次的数字。<br>]]>
    
    </summary>
    
      <category term="regex" scheme="http://lcepy.github.io/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于django中CSRF开启的问题]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%85%B3%E4%BA%8Edjango%E4%B8%ADCSRF%E5%BC%80%E5%90%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lcepy.github.io/2014/11/14/关于django中CSRF开启的问题/</id>
    <published>2014-11-14T12:33:12.000Z</published>
    <updated>2014-11-14T19:40:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="django_处理CSRF机制保护下的POST表单提交">django 处理CSRF机制保护下的POST表单提交</h2>
<p>昨天晚上使用django做一个POST表单提交的功能，发现出现了一个CSRF verification failed. Request aborted错误。于是，在网上找了很久，也没有什么好的办法可以解决它。我发现，大部分人的博客都不靠谱，Ctrl+C Ctrl+V的复制，坑了我不少时间，于是我去了django的官网，查询CSRF的问题，最后解决了。其实在解决这个问题之前，我们先要了解一下，CSRF到底是什么东东，为什么django提交一个POST表单这么困难呢。</p>
<p><a href="http://baike.baidu.com/link?url=OnI0sPQAHpQHhtxWSXvQFhN3kJWI3CU_rP3Fo7MqnPY3rTdhUPpuca-3lzJ651LdMI7ouoLvdnnihhojFyKtva" target="_blank" rel="external">CSRF 是什么</a></p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/contrib/csrf/" target="_blank" rel="external">django document CSRF</a></p>
<p>原来CSRF是为了防止跨站请求伪造用的，当我明白了这个解释之后，我开始找寻django document上如何开启CSRF。</p>
<p><strong>Add the middleware ‘django.middleware.csrf.CsrfViewMiddleware’ to your list of middleware classes, MIDDLEWARE_CLASSES. (It should come before any view middleware that assume that CSRF attacks have been dealt with.)</strong></p>
<p>那我在想，如果我把django.middleware.csrf.CsrfViewMiddleware注释掉，是不是就可以不开启CSRF来提交POST表单，人们常说实践是检验真理的唯一标准，试验一下，原来是可以的。但是这并没有解决，我想解决的问题，于是我又把这个中间件，重新写在了MIDDLEWARE_CLASSES上。</p>
<p>从官方的解释上来看，只要在MIDDLEWARE_CLASSES上加django.middleware.csrf.CsrfViewMiddleware就开启了CSRF机制。</p>
<p>现在我需要在模板中加入一个tag ｛%csrf_token%｝，来存放一个隐藏的token input。</p>
<p><strong>In the corresponding view functions, ensure that the ‘django.core.context_processors.csrf’ context processor is being used. Usually, this can be done in one of two ways:</strong></p>
<p>从这里的解释来看，我还需要django.core.context_processors.csrf，于是我导入这个模块from django.core.context_processors import csrf，运行一下貌似，还不行，接着往下看。我发现django的解释，这里可以用两种方式来处理，最后响应的response，而且django还说了，POST表单提交不要跨链接。</p>
<p><a id="more"></a><br><strong>Use RequestContext, which always uses ‘django.core.context_processors.csrf’ (no matter what your TEMPLATE_CONTEXT_PROCESSORS setting). If you are using generic views or contrib apps, you are covered already, since these apps use RequestContext throughout.</strong></p>
<p>方式一，是使用RequestContext来代替你模板的Context，并且你的apps必须都要使用它，而不是Context。</p>
<p><strong>Manually import and use the processor to generate the CSRF token and add it to the template context. e.g.</strong></p>
<p>方式二，手动的导入这个模块并调用此函数生成的token，并把它传入你模板的上下文中。</p>
<p>我使用的是方式二，在这里也许刚刚接触django的朋友会卡在这里，因为没法明白，怎么传入这个上下文。这里可以使用一个通用的方式去解决这个问题。请原谅我，我将脱离CSRF的内容，帮助你解决一下模板设置的问题，解决它才能解决它。回到django-admin.py startproject xxx初始化的项目中，打开settings.py文件，它是整个django项目的配置文件。找到TEMPLATE_DIRS配置上你模板目录的绝对路径，也可以是os.path生成出来的路径。然后通过from django.shortcuts import render_to_response来导入render_to_response。</p>
<pre><code>xxx.html结构

&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;&lt;/h1&gt;
        &lt;form action=<span class="string">"/"</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;
             ｛%csrf_token%｝
            &lt;input <span class="keyword">type</span>=<span class="string">"email"</span> name=<span class="string">"address"</span>&gt;
            &lt;button <span class="keyword">type</span>=<span class="string">"submit"</span> class=<span class="string">"btn btn-default"</span>&gt;send&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;



views.py <span class="comment">##视图文件</span>

<span class="keyword">from</span> django.<span class="keyword">template</span> <span class="keyword">import</span> <span class="type">Context</span>
<span class="keyword">from</span> django.core.context_processors <span class="keyword">import</span> csrf
<span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response
<span class="keyword">import</span> models

def index(request):
    dicts = {'we':'i send <span class="type">string</span>'}
    token = {}
    token.update(csrf(request))
    <span class="keyword">if</span> request.<span class="keyword">method</span> == '<span class="type">POST</span>':
        address = request.<span class="type">POST</span>.get('address')
        <span class="comment">## 可以用address来做其他验证或者其他处理程序</span>
        <span class="comment">## 此处省略其他处理函数</span>
    data = <span class="type">Context</span>(dicts)
    <span class="keyword">return</span> render_to_response('xxx.html',c,data)
    pass

urls.py <span class="comment">##路由配置文件，我的views是一个app所以需要导入xxx.views</span>
<span class="keyword">import</span> xxx.views
urlpatterns = patterns('',
    <span class="comment"># Examples:</span>
    <span class="comment"># url(r'^$', 'atomcoffee.views.home', name='home'),</span>
    <span class="comment"># url(r'^atomcoffee/', include('atomcoffee.foo.urls')),</span>
    url(r'^$',xxx.views.index),
    <span class="comment"># Uncomment the admin/doc line below to enable admin documentation:</span>
    <span class="comment"># url(r'^admin/doc/', include('django.contrib.admindocs.urls')),</span>

    <span class="comment"># Uncomment the next line to enable the admin:</span>
    <span class="comment"># url(r'^admin/', include(admin.site.urls)),</span>
)
</code></pre><p>大家可以尝试运行一下这个文件，你会发现，原来开启CSRF机制后的POST表单提交，成功了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="django_处理CSRF机制保护下的POST表单提交">django 处理CSRF机制保护下的POST表单提交</h2>
<p>昨天晚上使用django做一个POST表单提交的功能，发现出现了一个CSRF verification failed. Request aborted错误。于是，在网上找了很久，也没有什么好的办法可以解决它。我发现，大部分人的博客都不靠谱，Ctrl+C Ctrl+V的复制，坑了我不少时间，于是我去了django的官网，查询CSRF的问题，最后解决了。其实在解决这个问题之前，我们先要了解一下，CSRF到底是什么东东，为什么django提交一个POST表单这么困难呢。</p>
<p><a href="http://baike.baidu.com/link?url=OnI0sPQAHpQHhtxWSXvQFhN3kJWI3CU_rP3Fo7MqnPY3rTdhUPpuca-3lzJ651LdMI7ouoLvdnnihhojFyKtva" target="_blank" rel="external">CSRF 是什么</a></p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/contrib/csrf/" target="_blank" rel="external">django document CSRF</a></p>
<p>原来CSRF是为了防止跨站请求伪造用的，当我明白了这个解释之后，我开始找寻django document上如何开启CSRF。</p>
<p><strong>Add the middleware ‘django.middleware.csrf.CsrfViewMiddleware’ to your list of middleware classes, MIDDLEWARE_CLASSES. (It should come before any view middleware that assume that CSRF attacks have been dealt with.)</strong></p>
<p>那我在想，如果我把django.middleware.csrf.CsrfViewMiddleware注释掉，是不是就可以不开启CSRF来提交POST表单，人们常说实践是检验真理的唯一标准，试验一下，原来是可以的。但是这并没有解决，我想解决的问题，于是我又把这个中间件，重新写在了MIDDLEWARE_CLASSES上。</p>
<p>从官方的解释上来看，只要在MIDDLEWARE_CLASSES上加django.middleware.csrf.CsrfViewMiddleware就开启了CSRF机制。</p>
<p>现在我需要在模板中加入一个tag ｛%csrf_token%｝，来存放一个隐藏的token input。</p>
<p><strong>In the corresponding view functions, ensure that the ‘django.core.context_processors.csrf’ context processor is being used. Usually, this can be done in one of two ways:</strong></p>
<p>从这里的解释来看，我还需要django.core.context_processors.csrf，于是我导入这个模块from django.core.context_processors import csrf，运行一下貌似，还不行，接着往下看。我发现django的解释，这里可以用两种方式来处理，最后响应的response，而且django还说了，POST表单提交不要跨链接。</p>
<p>]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django模型使用的一些心得]]></title>
    <link href="http://lcepy.github.io/2014/11/14/django%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/"/>
    <id>http://lcepy.github.io/2014/11/14/django模型使用的一些心得/</id>
    <published>2014-11-14T12:30:31.000Z</published>
    <updated>2014-11-14T19:41:53.000Z</updated>
    <content type="html"><![CDATA[<p>近很一直在学习django，因为我需要使用它为自己的项目写一个前台页面和一个后台服务。它是一个关于咖啡的邮件订阅社区，既然有服务，自然需要数据库层的支持。这是一个很好的开始，学习django让我了解到python开发web应用真的非常快速，但是也有一个很明显的缺点。那就是国内，对django社区的支持度非常不好，这或许跟国内python的有关，不过也不要紧，学习就是这样，要啃难而上。</p>
<p>说说在django中模型，对应的数据库层，也就是意味着django帮助我们完成了对数据库的访问，操作，通过它的模型类。</p>
<blockquote>
<p>django-admin.py startapp sendcloud</p>
</blockquote>
<p>通过上述的命令，我们可以完成一个app模块，这个模块中带有views.py models.py test.py，而models.py文件中，就是我们完成模型的一个最主要的文件。</p>
<blockquote>
<p>from django.db import models</p>
</blockquote>
<p>模型类，都需要继承自django.db.models类。通过它与manage.py来完成初始化等等动作。关于manage.py的命令，未来有时间，我会写写关于它的心得。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">WeeklySyncList</span><span class="params">(models.Model)</span>:</span>
    <span class="comment">#do something</span>
    <span class="keyword">pass</span>
</code></pre><p>一个模型类对于数据库层中的一个表，在我们定义好模型类之后，可以在命令行中输入：</p>
<blockquote>
<p>python manage.py sqlall sendcloud</p>
</blockquote>
<p>来完成对创建语法的查看以及错误信息的查看，准确没有错误之后，可以输入：</p>
<blockquote>
<p>python manage.py syncdb</p>
</blockquote>
<p>来初始数据库，django会帮助我们完成数据库层面的操作。</p>
<a id="more"></a>

<h2 id="说说我的应用中使用到的东西">说说我的应用中使用到的东西</h2>
<p>我的应用是一个关于咖啡资料的邮件订阅社区，前台页面主要是输入email完成订阅，激活订阅，退订，历史期刊的分页查看，最新一期查看。这里，我使用了三个表来描述它，（这个数据库中还有另外的表，在描述后台服务，这里仅仅用前台来说说我学习的过程。）用户订阅表，用户退订表，期刊表。在语言层面，就需要三个模型类，来描述它了。</p>
<p>另外：这个应用，已经开源在github上，大家通过它可以访问到<a href="https://github.com/lcepy/AtomCoffee-Client" target="_blank" rel="external">点击这里</a></p>
<p>我用到的字段类型，主要是三个字段varchar date int，主要是用于订阅的email，订阅时间，激活时间，是否激活的状态。</p>
<p>在django中，因为我们不是使用原始查询，所以还需要在模型类中定义相应的字段，这一部分需要学习，对应的就是数据库中的字段类型，但是django有它自己的描述。</p>
<p><strong>用户订阅时插入数据库</strong></p>
<pre><code>models.WeeklyActivation(<span class="variable">activation_email=</span>address,<span class="variable">activation_key=</span>_ac_sha_key)
</code></pre><p>用户条件的一条email，会经过在后台的验证，验证成功之后就插入一条新的纪录。从代码上来看，基本上实例化一个类。</p>
<p><strong>查询数据库</strong></p>
<p>在验证email之后，我会根据提交的信息，先去数据库中查询一下是否有这个email地址，另外它是否是激活的状态。</p>
<pre><code><span class="attribute">models.WeeklyActivation.objects.filter(activation_email</span>=<span class="string">address)</span>
</code></pre><p>如果存在，并且已经激活，自然就不用插入一条新的纪录了。如果订阅时间，超过了两个小时，系统就需要发送一封信的订阅激活邮件了。</p>
<p>在django模型类中，objects叫做管理器，通过它，可以完成一些不同的操作，比如查询，过滤，等等。</p>
<p><strong>更新数据</strong></p>
<p>当用户收到一封激活email时，用户点击URL过来，需要更新一下激活状态，初始化状态都是0。</p>
<pre><code><span class="variable">week =</span> models.WeeklyActivation.objects.filter(<span class="variable">activation_key=</span>offset)
</code></pre><p>根据用户点击过来的URL获取到激活key，根据激活KEY查询一条记录，如果存在则通过week完成其他的操作。</p>
<p>这里还有地方要注意，查询返回的结果是一个list，要week = week[0]，然后再来操作，更新完成之后不要忘记调用week.save()方法，不然更新不会成功。</p>
<p><strong>原生查询</strong></p>
<p>在查看最新一期期刊的这个地方，我纠结了大概一个小时，因为我不清楚django模型，是怎样完成数据库函数的调用的，比如一个表中，我只需要某个列的最大值，这里如果是原生SQL，我一般都会用MAX函数来完成。</p>
<p>在没有找到django关于这方面的信息之前，我用了原始查询，django支持这个。</p>
<pre><code>模型类.raw('<span class="operator"><span class="keyword">SELECT</span> id,<span class="keyword">MAX</span>(sync_number) <span class="keyword">AS</span> max_number <span class="keyword">FROM</span> sendcloud_weeklysynclist<span class="string">')</span></span>
</code></pre><p>另外这里也需要关注一个问题，如果要原始查询，必须要带上主键，不然django会抛一个错误出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近很一直在学习django，因为我需要使用它为自己的项目写一个前台页面和一个后台服务。它是一个关于咖啡的邮件订阅社区，既然有服务，自然需要数据库层的支持。这是一个很好的开始，学习django让我了解到python开发web应用真的非常快速，但是也有一个很明显的缺点。那就是国内，对django社区的支持度非常不好，这或许跟国内python的有关，不过也不要紧，学习就是这样，要啃难而上。</p>
<p>说说在django中模型，对应的数据库层，也就是意味着django帮助我们完成了对数据库的访问，操作，通过它的模型类。</p>
<blockquote>
<p>django-admin.py startapp sendcloud</p>
</blockquote>
<p>通过上述的命令，我们可以完成一个app模块，这个模块中带有views.py models.py test.py，而models.py文件中，就是我们完成模型的一个最主要的文件。</p>
<blockquote>
<p>from django.db import models</p>
</blockquote>
<p>模型类，都需要继承自django.db.models类。通过它与manage.py来完成初始化等等动作。关于manage.py的命令，未来有时间，我会写写关于它的心得。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">WeeklySyncList</span><span class="params">(models.Model)</span>:</span>
    <span class="comment">#do something</span>
    <span class="keyword">pass</span>
</code></pre><p>一个模型类对于数据库层中的一个表，在我们定义好模型类之后，可以在命令行中输入：</p>
<blockquote>
<p>python manage.py sqlall sendcloud</p>
</blockquote>
<p>来完成对创建语法的查看以及错误信息的查看，准确没有错误之后，可以输入：</p>
<blockquote>
<p>python manage.py syncdb</p>
</blockquote>
<p>来初始数据库，django会帮助我们完成数据库层面的操作。</p>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[携程邮轮开发部django分享]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%90%BA%E7%A8%8B%E9%82%AE%E8%BD%AE%E5%BC%80%E5%8F%91%E9%83%A8django%E5%88%86%E4%BA%AB/"/>
    <id>http://lcepy.github.io/2014/11/14/携程邮轮开发部django分享/</id>
    <published>2014-11-14T12:20:19.000Z</published>
    <updated>2014-11-14T19:41:28.000Z</updated>
    <content type="html"><![CDATA[<p>使用django快速开发一个web网站</p>
<p>分享内容（拟）</p>
<ol>
<li>介绍django的历史</li>
<li>安装以及配置django项目</li>
<li>介绍django对请求的回应机制</li>
<li>讲解django URL的配置</li>
<li>讲解django模型的使用</li>
<li>讲解django view template 的使用</li>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>分享学习Python django的资料，以及说说一些django的web工具</li>
</ol>
<a id="more"></a>

<h2 id="django的历史">django的历史</h2>
<p>django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的软件设计模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手django reinhardt来命名的。</p>
<p><strong>人生苦短，我用Python。</strong></p>
<h2 id="安装以及配置django项目">安装以及配置django项目</h2>
<p>安装方式一：</p>
<p>下载<a href="https://github.com/django/django" target="_blank" rel="external">django</a>源代码到本地，进入这个目录，执行命令：python install setup.py</p>
<p>安装方式二：</p>
<p>下载<a href="https://pip.pypa.io/en/latest/" target="_blank" rel="external">pip</a>模块管理器到本地，执行命令：python install get-pip.py</p>
<p>然后使用pip进行安装，pip install django。</p>
<p>使用pip安装，可以很方便的删除，选择需要安装的django版本，例如：pip install django==1.5.2安装1.5.2版本的django。</p>
<p>个人推荐，使用方式二。</p>
<p>在安装完成好django之后，可以在python shell 交互控制台中测试django是否安装成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> django</div><div class="line"></div><div class="line">print(django.get_version()) <span class="comment">#1.5.2</span></div></pre></td></tr></table></figure>

<p>django-admin.py是django提供了一个强大的shell命令行工具，比如建立项目，建立项目内应用，启动开发服务器，测试模型SQL语句，同步模型到数据库等等，用好django出了需要具备python标准库，语法知识，以及django定义的类，组件之外，还需要学习好它的shell命令行工具，admin管理系统等，因为它们会让开发一个web应用，变得非常简单与快速。</p>
<p>新建立一个项目：cruise</p>
<pre><code>某目录内 ~/ django.<span class="literal">admin</span>.py startproject cruise
</code></pre><p>cruise项目目录：</p>
<pre><code>cruise (dir)
    wsgi.<span class="keyword">py</span>
    setting.<span class="keyword">py</span>
    urls.<span class="keyword">py</span>
manage.<span class="keyword">py</span>
</code></pre><p>建立一个应用：login</p>
<pre><code>cruise目录内 ~/ <span class="keyword">python</span> manage.<span class="keyword">py</span> startapp login
</code></pre><p>login应用目录：</p>
<pre><code>login（dir）
    views.<span class="keyword">py</span>
    models.<span class="keyword">py</span>
    test.<span class="keyword">py</span>
</code></pre><p><strong>概念</strong> django项目中，各种服务类的功能，可以分离成一个个应用，而外层才是项目的配置文件。</p>
<p>wsgi.py 是一个符合wsgi标准的文件，由django实现，<a href="http://wsgi.readthedocs.org/en/latest/" target="_blank" rel="external">WSGI资料可查看</a></p>
<p>setting.py 为django项目的配置文件，django实现的组件，以及开发时模板，静态资源等等都在此配置。</p>
<p>urls.py 可以理解为django为view实现的路由系统。</p>
<h2 id="介绍django对请求的回应机制（3）">介绍django对请求的回应机制（3）</h2>
<p>当服务器接收到一个HTTP请求后，一个服务器特定的handler会创建HTTpRequest并传递给下一个处理程序，这个处理程序，会处理URLConf，并调用相应的view，把REQUEST传递给view 处理程序。</p>
<p>view处理程序，当处理完成之后，进行响应给客户端。另外django的中间件会，增强这些响应的作用。</p>
<h2 id="django_URL的配置（4）">django URL的配置（4）</h2>
<p>首先需要先导入django.conf.urls.defaults下的所有模块，它是django URLConf的基本构造，包含了一个patterns函数，调用patterns函数并将返回结果保存到 urlpatterns 变量。实际在建立项目时，django生成的文件中，已经帮助我们做好了这件事情。</p>
<p>它所需要的参数是一个元组，用来映射视图与URL的关系。</p>
<p><strong>额外：Python路径搜索规则，建议查看资料。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> patterns, include, url</div><div class="line"><span class="comment"># Uncomment the next two lines to enable the admin:</span></div><div class="line"><span class="comment"># from django.contrib import admin</span></div><div class="line"><span class="comment"># admin.autodiscover()</span></div><div class="line"><span class="keyword">import</span> login.views</div><div class="line"><span class="keyword">import</span> home.views</div><div class="line"><span class="comment">#在django中urls.py的作用有点类似于C，实际上它就是一个分发程序，帮助我们对每一项URL进行分发到具体的视图程序中。</span></div><div class="line">urlpatterns = patterns(<span class="string">''</span>,</div><div class="line">    <span class="comment"># Examples:</span></div><div class="line">    <span class="comment"># url(r'^$', 'cruise.views.home', name='home'),</span></div><div class="line">    <span class="comment"># url(r'^cruise/', include('cruise.foo.urls')),</span></div><div class="line">    url(<span class="string">r'^login/$'</span>,login.views.sign_in),</div><div class="line">    url(<span class="string">r'^logout/$'</span>,login.views.sign_out),</div><div class="line">    url(<span class="string">r'^register/$'</span>,login.views.register),</div><div class="line">    url(<span class="string">r'^$'</span>,home.views.mypage),</div><div class="line">    <span class="comment"># Uncomment the admin/doc line below to enable admin documentation:</span></div><div class="line">    <span class="comment"># url(r'^admin/doc/', include('django.contrib.admindocs.urls')),</span></div><div class="line">    <span class="comment">#URL配置例子</span></div><div class="line">    <span class="comment"># Uncomment the next line to enable the admin:</span></div><div class="line">    <span class="comment"># url(r'^admin/', include(admin.site.urls)),</span></div><div class="line">)</div></pre></td></tr></table></figure>

<p><strong>URL正则表：</strong></p>
<blockquote>
<p>符号    匹配<br>. (dot)    任意单一字符<br>\d    任意一位数字<br>[A-Z]    A 到 Z中任意一个字符（大写）<br>[a-z]    a 到 z中任意一个字符（小写）<br>[A-Za-z]    a 到 z中任意一个字符（不区分大小写）</p>
<ul>
<li>匹配一个或更多 (例如, \d+ 匹配一个或 多个数字字符)<br>[^/]+    一个或多个不为‘/’的字符</li>
</ul>
<ul>
<li>零个或一个之前的表达式（例如：\d? 匹配零个或一个数字）</li>
<li>匹配0个或更多 (例如, \d* 匹配0个 或更多数字字符)<br>{1,3}    介于一个和三个（包含）之前的表达式（例如，\d{1,3}匹配一个或两个或三个数字）</li>
</ul>
</blockquote>
<h3 id="简单思路">简单思路</h3>
<p>导入视图模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> login.views</div><div class="line"><span class="keyword">import</span> home.views</div></pre></td></tr></table></figure>

<p>django URLConf 的配置，有多种多样的形式，这里主要是介绍一下简单的URL规则，在Python风格中URL应该是双斜杠//，例如：127.0.0.1/home/或者127.0.0.1/home/1/ 。</p>
<p>一般情况下一个URL是对应一个视图的，例如127.0.01/home/可能对于的就是视图home.views.home。而在URL中也可以动态，比如情况是书籍的详细情况，一本书有一个唯一的书籍号ID，而书籍号ID就可以描述为：127.0.0.1/book/1/，这是ID为1的书籍，又如127.0.0.1/book/2/，这是ID为2的书籍。</p>
<p>如何实现动态URL？</p>
<p>之前，有看过URL正则表达式，django URLConf是支持正则表达式，来描述URL的。它会成第二个参数，传递给视图处理程序。例如，我想获取书籍号ID，来显示不同本书籍，那么URL：^book/(\d+)/$，而在视图处理程序中第二个参数，就是GET请求时，获取的book/(\d+)/，这样的数字ID。</p>
<p>总之URLConf可以通过这些组合来映射相应的视图处理程序，来满足业务需求。</p>
<h2 id="django模型的使用（5）">django模型的使用（5）</h2>
<p>在使用模型之前，需要先配置数据库，django支持的数据库类型表：</p>
<p><code>postgresql</code>    PostgreSQL    psycopg 1.x版， <a href="http://www.djangoproject.com/r/python-pgsql/1/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-pgsql/1/。</a></p>
<p>postgresql_psycopg2    PostgreSQL    psycopg 2.x版， <a href="http://www.djangoproject.com/r/python-pgsql/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-pgsql/。</a></p>
<p>mysql    MySQL    MySQLdb , <a href="http://www.djangoproject.com/r/python-mysql/" target="_blank" rel="external">http://www.djangoproject.com/r/python-mysql/</a>.</p>
<p>sqlite3    SQLite    如果使用Python 2.5+则不需要适配器。 否则就使用 pysqlite ， <a href="http://www.djangoproject.com/r/python-sqlite/。" target="_blank" rel="external">http://www.djangoproject.com/r/python-sqlite/。</a></p>
<p>oracle    Oracle    cx_Oracle , <a href="http://www.djangoproject.com/r/python-oracle/" target="_blank" rel="external">http://www.djangoproject.com/r/python-oracle/</a>.</p>
<p>主要为：mysql oracle sqlite等等。</p>
<p>打开setting.py文件，在起始位置出，默认情况下，这些都是无配置的，需要手动配置好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置数据库模型</span></div><div class="line">DATABASES = {</div><div class="line">    <span class="string">'default'</span>: {</div><div class="line">        <span class="string">'ENGINE'</span>: mydb.DB_ENGINE, <span class="comment"># Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.</span></div><div class="line">        <span class="string">'NAME'</span>: mydb.DB_NAME,                      <span class="comment"># Or path to database file if using sqlite3.</span></div><div class="line">        <span class="comment"># The following settings are not used with sqlite3:</span></div><div class="line">        <span class="string">'USER'</span>: mydb.DB_USER,</div><div class="line">        <span class="string">'PASSWORD'</span>: mydb.DB_PASSWORD,</div><div class="line">        <span class="string">'HOST'</span>: mydb.DB_HOST,                      <span class="comment"># Empty for localhost through domain sockets or '127.0.0.1' for localhost through TCP.</span></div><div class="line">        <span class="string">'PORT'</span>: mydb.DB_PORT,                      <span class="comment"># Set to empty string for default.</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>技巧</strong></p>
<p>可以使用python manage.py shell 进入一个交互环境，在这里可以测试一下增删改查等等。</p>
<p>django模型的使用是django框架学习比重非常大的一个地方，它实现了一套属于django自己的方式来操作数据库，包括增删改查，以及字段类型的定义，查询的技巧等等方式。</p>
<p>django中一个模型对应的是一张表，需要继承django.db中models类。</p>
<p>定义一个模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">x</span><span class="params">(models.Model)</span>:</span></div><div class="line">    u_name = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">    u_pass = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">    u_session = models.CharField(max_length=<span class="number">45</span>)</div><div class="line">	u_status = models.IntegerField(max_length=<span class="number">1</span>,default=<span class="number">0</span>)</div><div class="line">   	<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p>CharField对应的是数据库中的varchar类型，而IntegerField对应的是int类型，自增主键，django为每一个模型定义了一个主键id。</p>
<p><strong>增</strong></p>
<p>要往表中插入一条数据，SQL的语句是INSERT INTO。而django则是实例一下定义的模型类，比如这里定义的x。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y = x(u_name=<span class="string">'123'</span>,u_pass=<span class="string">'a123'</span>,u_session=<span class="string">'123'</span>)</div><div class="line">y.save()</div></pre></td></tr></table></figure>

<p>最后调用一下save方法，来真正插入一条新的记录。</p>
<p><strong>查</strong></p>
<pre><code><span class="keyword">y</span> = <span class="keyword">x</span>.objects.<span class="built_in">filter</span>(u_name=<span class="string">'123'</span>)

<span class="keyword">y</span> = <span class="keyword">y</span>[<span class="number">0</span>]

<span class="keyword">print</span>(<span class="keyword">y</span>.u_name)
</code></pre><p><strong>改</strong></p>
<pre><code><span class="variable">y =</span> x.objects.filter(<span class="variable">u_name=</span>'<span class="number">123</span>')

<span class="variable">y =</span> y[<span class="number">0</span>]

y.<span class="variable">u_name =</span> <span class="number">456</span>

y.save()
</code></pre><p><strong>删</strong></p>
<pre><code><span class="keyword">y</span> = <span class="keyword">x</span>.objects.<span class="built_in">filter</span>(u_name=<span class="string">'123'</span>)

<span class="keyword">y</span> = <span class="keyword">y</span>[<span class="number">0</span>]

<span class="keyword">y</span>.<span class="built_in">delete</span>()
</code></pre><p><strong>其他，比如过滤，排序，更新多条数据，限制返回数据，连锁查询，获取单个对象等等，这些需要学习时间</strong></p>
<h2 id="django_view_template_的使用（6）">django view template 的使用（6）</h2>
<p>也许我们认为django是一个MTV框架，更加适合。M：模型 T：模板 V：视图。C的管理，由django内部去实现了。</p>
<p>在视图中文件中，需要导入视图相关的django组件，比如django.http 中的各类响应类，django.template中的与模板相关的类。</p>
<pre><code><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse
<span class="keyword">from</span> django.template <span class="keyword">import</span> Context,Template
<span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span>
    <span class="keyword">return</span> HttpResonse(<span class="string">'&lt;h1&gt;Hello&lt;/h1&gt;'</span>)
    <span class="keyword">pass</span>
</code></pre><p>这里写了一个hello视图函数，并在URLConf中配置好这个视图函数，即可在浏览器中查看这个页面了。</p>
<p><strong>视图函数中所使用的各种类，需要一定的时间学习。</strong></p>
<p>它不是最重要的，T才最重要的。</p>
<p><strong>简单基础</strong></p>
<p>django模板系统，对于逻辑的操作，需要用百分号，必须有结束语句。而赋值则是两个大括号。django的模板系统，是可以切换的。如果觉得原生自带的模板系统不够好用，可以在setting文件中重新配置要使用的模板系统。</p>
<p><strong>简单例子</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> Context,Template</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></div><div class="line">	t_html = Template(<span class="string">'''</span></div><div class="line">		&lt;h1&gt;&lt;/h1&gt;</div><div class="line">		</div><div class="line">	''')</div><div class="line">	c = Context({<span class="string">"wow"</span>:<span class="keyword">True</span>,<span class="string">"page"</span>:<span class="string">"Hello"</span>})</div><div class="line">	t_html = t_html.render(c)</div><div class="line">	<span class="keyword">return</span> HttpResponse(t_html)</div><div class="line">	<span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p><strong>扩展：模板系统也是一个学习重点，中间有很多技巧性的问题，比如：导入，同一个模板多个上下文，过滤器等等</strong></p>
<h2 id="扩展部分">扩展部分</h2>
<ol>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>简单django中几个常用的组件</li>
<li>分享学习Python django的资料</li>
</ol>
<p>django提供了N多的web工具，例如：</p>
<pre><code>认证
缓存
日志
发送电子邮件
聚合供稿(RSS/Atom)
评论, 评论审核 和 自定义评论
分页
消息框架
序列化
Sessions
站点地图
静态文件管理
数据验证
</code></pre><p>django是一个大而全的框架，它提供了很多很多基本上包括了web开发中所需要的功能，学习它需要大量的时间。</p>
<p>学习django的基础，是学习好Python。</p>
<p><strong>人生苦短 我用Python</strong></p>
<p><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="external">Python 标准库</a> </p>
<p><a href="http://docs.pythonsprints.com/python3_porting/py-porting.html" target="_blank" rel="external">Python2x与Python3x对照表</a></p>
<p><a href="https://docs.djangoproject.com/en/1.6/" target="_blank" rel="external">Django API</a></p>
<p><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">一本django1.5电子书</a></p>
<p><a href="http://uliweb.clkg.org/tutorial/read/20" target="_blank" rel="external">简单的django学习</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用django快速开发一个web网站</p>
<p>分享内容（拟）</p>
<ol>
<li>介绍django的历史</li>
<li>安装以及配置django项目</li>
<li>介绍django对请求的回应机制</li>
<li>讲解django URL的配置</li>
<li>讲解django模型的使用</li>
<li>讲解django view template 的使用</li>
<li>通过一个例子讲解如何快速的实现一个简单的网站（注册，登录，验证用户状态）</li>
<li>分享学习Python django的资料，以及说说一些django的web工具</li>
</ol>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django静态资源配置的问题]]></title>
    <link href="http://lcepy.github.io/2014/11/14/django%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lcepy.github.io/2014/11/14/django静态资源配置的问题/</id>
    <published>2014-11-14T12:16:20.000Z</published>
    <updated>2014-11-14T19:41:56.000Z</updated>
    <content type="html"><![CDATA[<p>在初始化一个django项目时，我还遇见了一个比较头疼的问题，静态资源的配置，硬编码问题。其实，按照正常的部署来说，静态资源，比如（.css .js img）等，应该另启动一个服务器，去做静态资源的处理，这样是非常常见的，和语言无关，脱离了动态开发内容，特别的适合做内容分发。但是，考虑到前期，我想能在django中集合这样的资源类型，于是，碰到了比较纠结的问题。另外，在django初始化的项目中，竟然还不能在注释中打中文，是不是很疼，没关系，往下看，能解决这样的问题。</p>
<a id="more"></a>

<p>其实，在django settings.py文件中，我们可以找到三个关于static的内容。STATIC_ROOT，STATIC_URL，STATICFILES_DIRS。于是，我在想，是不是就是配置这三项呢。</p>
<p><a href="https://docs.djangoproject.com/en/1.5/ref/settings/" target="_blank" rel="external">settings.py 官方给出的配置参数解释</a></p>
<p>顾名思义，我想在我的项目中利用django内置的服务器来处理静态资源，最能给我合理的参数应该是STATICFILES_DIRS。</p>
<p><strong>This setting defines the additional locations the staticfiles app will traverse if the FileSystemFinder finder is enabled, e.g. if you use the collectstatic or findstatic management command or use the static file serving view.</strong></p>
<p>从官方的解释上来看，这个设置，可以通过我的管理命令集来启动这个视图，那不是意味着，它可以读取我的静态资源呢。实践下来，配置上，我项目的绝对路径，成功。</p>
<p>当然，我看django的官方配置文件中所描述的方式，有多种，而上述是一个最容易搞定的方式，反正是开发，何必纠结呢。不建议，在部署时，也使用django的静态资源服务，这会增加很多压力。合理的安排，是另外启用一个静态资源服务器，专门存储这些静态资源。</p>
<p>在处理好静态资源之后，我想给这里添加一个注释，并写上中文。于是，我发现，出现了一个编码问题。后来查询了python官方的一个PEP，了解到原来，如果我的不是utf-8或者其他支持中文的编码，直接写上中文，那是报一个大大的错误的。</p>
<p><a href="http://legacy.python.org/dev/peps/" target="_blank" rel="external">Python 官方关于编码的PEP</a></p>
<p>在文件的头部写上#coding=utf-8即可，这一项2.7到3.x都是完美兼容的，如果现在学习python，建议最小选择从2.7.3开始，到3.x。2.7除了模块不一样名不一样，有很多内置函数，是继承到了3.x。当然如果，不考虑工作的话，我建议直接从python3.x开始学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在初始化一个django项目时，我还遇见了一个比较头疼的问题，静态资源的配置，硬编码问题。其实，按照正常的部署来说，静态资源，比如（.css .js img）等，应该另启动一个服务器，去做静态资源的处理，这样是非常常见的，和语言无关，脱离了动态开发内容，特别的适合做内容分发。但是，考虑到前期，我想能在django中集合这样的资源类型，于是，碰到了比较纠结的问题。另外，在django初始化的项目中，竟然还不能在注释中打中文，是不是很疼，没关系，往下看，能解决这样的问题。</p>
]]>
    
    </summary>
    
      <category term="python django" scheme="http://lcepy.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[减肥与训练]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%87%8F%E8%82%A5%E4%B8%8E%E8%AE%AD%E7%BB%83/"/>
    <id>http://lcepy.github.io/2014/11/14/减肥与训练/</id>
    <published>2014-11-14T12:11:56.000Z</published>
    <updated>2014-11-14T19:41:07.000Z</updated>
    <content type="html"><![CDATA[<p>训练的目的在于，训练自身的素质，为长距离骑行做准备。主要是训练意志力，大腿肌肉，胸部肌肉，以及肺活量。</p>
<p>我的训练计划有参考的价值，如下：</p>
<ol>
<li>第一个月每天晚上做20个抱头的仰卧起坐，15个双手水平放直的仰卧起坐。</li>
<li>第一个月每天晚上做10个俯卧撑。</li>
<li>每天下班之后来回骑行15-20公里。</li>
<li>训练之前，做热身运动。</li>
<li>一周内去健身房三次，听从专业教练的训练。（看情况）</li>
</ol>
<p>从目标的第一个月开始，逐月增加5的增量，训练最重要的是坚持，特别是意志力。这样的训练，最重要的是训练意志力，以及身体的素质。</p>
<p>另外一项属于文化类的训练，需要熟读交通指示牌，以及骑行手语。</p>
<p><a id="more"></a></p>
<h2 id="07-12">07-12</h2>
<p>从今天开始我准备了一项比较长久的减肥与训练计划，也是从今天开始我去健身房办理了一张健身卡，教练给我的建议有两项，一是减肥，二是练肌肉。基本同意这样的建议，于是开始着手这方面的准备。</p>
<p>第一次去训练，最开始10分钟在跑步机上热身，然后开始练器材，分三组，一组十个，包括了有仰卧起坐，练胸拉伸，练手臂的拉伸，做下来，真的很痛，第一次训练这些。</p>
<p>就是这样，第一次训练一起花了一个小时二十分钟的样子。</p>
<h2 id="07-13">07-13</h2>
<p>因为昨天的开始训练，把身上特别是手臂到胸的那个关节处，特别的痛，所以只在跑步机上跑了二十分钟。本来各项要练习三组，但是今天只练了一组，就练不起来了。</p>
<h2 id="07-16">07-16</h2>
<p>距上次在健身房练习，有三天没有去了，因为周一加班，周二又发布，所以周三才去。几天没有健身，感觉不是那么痛了，于是像第一次一样的开始练，感觉好像适应了一般，三组下来，没有任何的不适感，这倒是个好消息。</p>
<h2 id="07-17到07-20">07-17到07-20</h2>
<p>这几天都像往常一样，没有什么特别的事情，于是去了健身房，依然跟第一次一样，各三组，但是我发现好像没有什么效果，还是65公斤，想想，这不科学啊，是不是哪里出了什么问题，问了问教练，也去知乎上搜了大量的资料，原来发现减肥除了运动还跟吃，也就是食物有关系。</p>
<h2 id="07-22">07-22</h2>
<p>在考虑了两天之后，我重新制定了一份计划，包括健身，食物。也从8月开始，就不跟大家一起吃饭了。健身计划按月为一个分界线，开始往上逐渐递增。我的计划就是，在七月份的最后一周内，仰卧起坐三十个，分三组。练手臂肌肉拉伸，50个分四组，前两组15，后两组10.练胸肌肉拉伸（扩胸）为35个，前一组为15个，后两组为10个，另外还多了一项，虽然我暂时不知道它叫什么，依然是35个，前一组15个，后两组为10.并且我重新调整的训练秩序，从家里走到健身房为热身，先练器材，最后跑步。而跑步我的分钟为25分钟连续跑。</p>
<h2 id="07-23到07-24">07-23到07-24</h2>
<p>这两天我在研究食物，到底怎么吃才能配合健身能到达更好的效果，初步出了一个方案，这两天的健身从22开始，持续。怎么吃，我写在最后。</p>
<h2 id="07-25">07-25</h2>
<p>从今天开始，我跑又重新做了一份调整，时间为25分钟并且增加了10分钟练习自行车。</p>
<h2 id="07-26到07-27">07-26到07-27</h2>
<p>07-22的计划未变，持续。去看重量的时候，感觉少了2斤，我吃了饭。</p>
<h2 id="07-28">07-28</h2>
<p>今天去健身房本来打算依然像昨天那样训练，只是练完器材之后，跑步机真心不爽，跑了5分钟就走了。</p>
<h2 id="08-03">08-03</h2>
<p>上周一周的时间都在加班，所以没有进行训练，今天去训练，为了适应，跑步做了时间上的减少，为15分钟，其他照就。</p>
<h1 id="附件：怎么吃才能配合健身达到更好的效果">附件：怎么吃才能配合健身达到更好的效果</h1>
<p>07-28今天花了一天的时间在琢磨食谱，到底怎么吃才能达到效果，于是有了这些减肥食物的控制理论，蔬菜水果粗粮为主，并且辅助大量的运动与器材训练，另外还要戒烟戒酒，特别是烟和啤酒，烟中有大量的尼古丁，啤酒特别容易肥肚子，我的食物安排是这样的，而且是一日多餐。</p>
<p>早餐的食物，为脱脂牛奶，燕麦片或者无糖黑芝麻糊。牛奶就不用说了，不充蛋白质。而燕麦片是粗粮，主要来促进肠胃。</p>
<p>中午的食物，为粗粮，如玉米，大麦等。如果有玉米则吃玉米，另外西红柿一个，黄瓜三到四根，玉米两个。下午三点半左右，吃一个水果，一些坚果。</p>
<p>晚餐则是食谱类的，主要是汤，炒，凉拌，这里我做了一下分类，原则上，晚餐才吃米饭和菜。搭配上为一炒一汤，或者一凉拌一汤。汤主要为清煮类，全部少量盐。</p>
<p>青菜豆腐汤，材料为青菜，豆腐，葱花，少量盐与胡椒，清煮。</p>
<p>冬瓜肉丝汤（原则上，一周只能一次），材料为冬瓜，猪肉，猪肉切成丝，少量，先要用热开水沸煮，去掉脂肪等，然后搭配冬瓜，少量盐，胡椒，葱花。</p>
<p>西红柿豆腐汤，材料为西红柿，豆腐，少量盐，清水煮，配上葱花。</p>
<p>魔芋汤，魔芋切片，清煮，不放盐。</p>
<p>爆辣椒，材料为青辣椒，生姜，大蒜，辣椒拍烂，配上生姜，大蒜，爆炒。</p>
<p>大蒜炒空心菜，材料为空心菜，大蒜，爆炒。</p>
<p>闷南瓜，材料为南瓜，少量水煮，一直闷熟。</p>
<p>凉拌黄瓜，材料为黄瓜，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>凉拌海带，材料为海带，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>凉拌莴笋，材料为莴笋，大蒜，生姜，葱花，豆豉辣椒油，少量盐，少量鸡精，凉拌。</p>
<p>清炒长豆角，或者清炒四季豆，清炒，少量盐。</p>
<p>家常豆腐皮，材料为豆腐皮，青辣椒，少量玉米油清炒。</p>
<p>酸辣土豆丝，配少量醋，豆豉辣椒油，青红辣椒丝，清炒。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>训练的目的在于，训练自身的素质，为长距离骑行做准备。主要是训练意志力，大腿肌肉，胸部肌肉，以及肺活量。</p>
<p>我的训练计划有参考的价值，如下：</p>
<ol>
<li>第一个月每天晚上做20个抱头的仰卧起坐，15个双手水平放直的仰卧起坐。</li>
<li>第一个月每天晚上做10个俯卧撑。</li>
<li>每天下班之后来回骑行15-20公里。</li>
<li>训练之前，做热身运动。</li>
<li>一周内去健身房三次，听从专业教练的训练。（看情况）</li>
</ol>
<p>从目标的第一个月开始，逐月增加5的增量，训练最重要的是坚持，特别是意志力。这样的训练，最重要的是训练意志力，以及身体的素质。</p>
<p>另外一项属于文化类的训练，需要熟读交通指示牌，以及骑行手语。</p>
<p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://lcepy.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的项目经历]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    <id>http://lcepy.github.io/2014/11/14/我的项目经历/</id>
    <published>2014-11-14T12:09:19.000Z</published>
    <updated>2014-11-14T19:40:28.000Z</updated>
    <content type="html"><![CDATA[<p><em>开源项目，可以在 github 查看，主要分为两类项目，一类为给公司开发的开源工具，用来前端的编程效率，一类为自己的学习项目，比如桌面端的MVC一套解决方案，移动组件库，以及个人项目。</em></p>
<p><em>擅长领域，主要为javascript，python，关系型数据库为mysql，工作中以javascript为主。</em></p>
<h2 id="个人项目展示">个人项目展示</h2>
<p><a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">HTTP Proxy</a></p>
<p><a href="https://github.com/lcepy/kalimdor" target="_blank" rel="external">kalimdor MVC</a></p>
<p><a href="https://github.com/lcepy/Find" target="_blank" rel="external">Find zepto UI</a></p>
<p><a href="https://github.com/lcepy/nagrand" target="_blank" rel="external">nagrand onload</a></p>
<p><a href="https://github.com/lcepy/douban-shell-app" target="_blank" rel="external">douban-shell</a></p>
<p><a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">webapp 打包工具</a></p>
<p><a href="https://github.com/lcepy/my-learning-project" target="_blank" rel="external">我的学习</a></p>
<p><a id="more"></a></p>
<h2 id="携程">携程</h2>
<p><em>在线项目为携程H5站点，hybrid app。H5站点地址 : </em><a href="http://m.ctrip.com/webapp/cruise/index.html" target="_blank" rel="external">H5</a><em> hybrid app IOS可以在app store中下载，安卓可以在各大安卓市场下载，负责cruise的移动端开发</em></p>
<h5 id="2014年9月15日到2014年10月9日_CRUISE_H5_Hybrid_5-10（邮轮）">2014年9月15日到2014年10月9日 CRUISE H5 Hybrid 5.10（邮轮）</h5>
<p>主要负责把搜索与筛选的业务逻辑全部修改为联调机制，并且在搜索中，增加途径国家，增加多级的搜索，列表页需要支持URL参数并且支持SEO，修改首页的地理位置定位与默认参数的逻辑，制作一个新的营销CR页面。</p>
<p><strong>让用户从之前的单个搜索，筛选，变更为在同一个view中进行搜索与筛选，不切换view在体检上就不会感觉到很麻烦。</strong></p>
<h5 id="2014年8月9日到9月11日_CRUISE_H5_Hybrid_5-9（邮轮）">2014年8月9日到9月11日 CRUISE H5 Hybrid 5.9（邮轮）</h5>
<p>主要负责重构邮轮首页，列表页，搜索页以及筛选的业务逻辑，中间修改了广告营销，预定咨询页，修复5.8bug以及新增需求。</p>
<p><strong>帮助同事进行源代码重构，分享一些过往的开发经验。</strong></p>
<h5 id="2014年7月7日到2014年8月5日_CRUISE_H5_Hybrid_5-8（邮轮）">2014年7月7日到2014年8月5日 CRUISE H5 Hybrid 5.8（邮轮）</h5>
<p>主要是新接手同事的列表，搜索排序，筛选排序，新做了订单意向单，邮轮详情页中的行程介绍，岸上游详情介绍，修复5.7bug以及新增需求。</p>
<h5 id="2014年5月21日到2014年6月27日_CRUISE_H5_Hybrid_5-7（邮轮）">2014年5月21日到2014年6月27日 CRUISE H5 Hybrid 5.7（邮轮）</h5>
<p>主要是负责邮轮的整个订单部分，分为订单第一步，选择班期。订单第二步，选择房型。订单第三步，填写常用联系人，并核算消费明细等。配套的有，常用旅客的选择，编辑，新增，另外两项功能性选择，为保险多选选择，岸上游单选选择，并且提交支付。<br>中间的逻辑（不复述了）</p>
<p><strong>解决了携程邮轮在无线端下订单从无到有的开始。</strong></p>
<h5 id="2014年4月25日到2014年5月19日_CRUISE_H5_Hybrid_5-6（邮轮）编写了两个工具">2014年4月25日到2014年5月19日 CRUISE H5 Hybrid 5.6（邮轮）编写了两个工具</h5>
<p>主要是负责了第一版邮轮的订单意向单，预定须知，签证签出。在当时的开发环境下为其他开发人员编写了两个工具，一个工具是HTTP代理服务器用来模拟数据（nodejs）这个已经提交在个人github中，项目名为glob-proxy，另外一个是给组长编写的excels导入工具（python）</p>
<p>时间：<strong>2014(04-25到05-02)</strong></p>
<h4 id="excels导出工具">excels导出工具</h4>
<p><em>基于python编写的excels导出GUI工具，根据SOAP协议远程调用query，生成excels报表。</em></p>
<p><strong>是帮助当时的开发经理从项目日志中，导出excels表。</strong></p>
<p>时间：<strong>2014(05-5到05-10)</strong> </p>
<h4 id="glob-proxy">glob-proxy</h4>
<p><em>基于nodejs的HTTP请求代理服务器，根据映射表，实现在本地的mock，提交远程GET POST请求，支持H5跨域，支持对远程请求数据的内存缓存与物理缓存，实现对内存缓存的管理，根据打分机制来自动释放，使用度不高的请求缓存。</em></p>
<p><strong>解决了当时开发团队在开发方式上的困难，因为前后不同步的原因，需要经常在模型层中修改请求地址，或是在本地自己模拟假数据。这个工具的出现，则统一由代理服务器去切换请求地址或者在本地生成mock数据。</strong></p>
<p>源代码仓库：<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a></p>
<p><strong>2014年3月10日到4月11日 门票 H5 Hybrid 5.5</strong></p>
<p>当时主要是负责了门票详情页，预定须知，点评，地图交互，景点介绍</p>
<p><strong>2014年2月12日到3月3日  机票 H5 Hybrid 5.5  编写了一个工具</strong></p>
<p>当时在机票主要是负责从用户订取机票的时间与航空公司的上下班时间中分析出一个合理的时间区间数组来。<br>打包工具主要是根据SOAP协议来调取webapp包地址，多线程下载完成之后重新打包。现工具已经在提交在个人github上，项目名为downloadZIP</p>
<p><strong>关于时间区间的分析，根据航空公司上下班时间与用户自己期望的时间分析出一个合理的时间数组，让用户可以清晰的了解到取票的时间范围。</strong></p>
<p>时间：<strong>2014(02-12到02-18)</strong></p>
<h4 id="downloadZIP">downloadZIP</h4>
<p><em>说明：基于python编写的webapp打包工具，根据SOAP协议来远程调用query查询获取webapp包地址，根据包地址下载，解压，重新打包为一个webapp zip文件。此工具为GUI工具，下载为多线程后台下载。</em></p>
<p><strong>解决了不同版本的APP打包的问题</strong></p>
<p>源代码仓库：<a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">downloadZIP</a></p>
<h2 id="万言网（兼职）">万言网（兼职）</h2>
<p>2013年11月15日-2013年12月24日：设计移动端体系，并负责开发第一版，万言网投票达人触屏版<br>应用参考地址：（开发测试地址） <a href="http://m.wanyan.com" target="_blank" rel="external">http://m.wanyan.com</a> （投票，数据分析功能需要注册登录）</p>
<p>2013年10月13日-2013年11月10：重新设计桌面前端体系，并负责开发言交所项目。<br>应用参考地址： <a href="http://www.wanyan.com/yanex" target="_blank" rel="external">http://www.wanyan.com/yanex</a> (需注册登录)</p>
<p><em>万言项目的在线地址：</em><a href="http://www.wanyan.com/" target="_blank" rel="external">wanyan</a></p>
<p>万言网投票H5移动端，桌面版 时间：<strong>2013(10-13)-2014(01-10)</strong></p>
<p><em>说明：重新设计了桌面端的架构实现，组织了模块化，以及客户端MVC对应的RESTFU路由请求模块，应用自动化打包，检测等工具。此项目设计，应用在万言网的言交所项目，其他需要SEO页面，则组织了通用模板，一套模板应用在服务端，客户端两端。而万言网的移动触屏版，投票达人应用，在桌面版架构实现的基础上，简化了代码量与性能提升，增加了UI组件库，本地存储系统，单页实现。SEO依然是通用模板，根据URL请求来识别是否是搜索引擎，还是用户正常点击，来切换模板。</em></p>
<p>内部打分收集系统 时间 <strong>2013(12-10)-2014(01-10)</strong></p>
<p><em>说明：基于python django mysql的后台打分收集系统，根据用户的反馈情况，来评分。提供给运营人员查看，编辑，分析。主要的业务逻辑，在于整套数据的评分，以及优质内容的评定。</em></p>
<p><strong>在兼职期间把万言网的PC端的架构重写，并且运用在投票达人，言交所这两个大的板块中。另解决了移动浏览器项目的开发选型，组织框架，应用了投票达人的移动试用版。</strong></p>
<h2 id="回湖南时">回湖南时</h2>
<p><strong>2013年9月-2013年10月：开发了一套可以应用在企业级应用中的mvc框架与解决方案</strong></p>
<p>主要根据之前两年左右的企业级应用开发经验，做了这么一套东西，可以适用在财务报表，财务分析，等报表类企业级b/s应用中。<br>源代码仓库：<a href="https://github.com/UnableToParse/kalimdor" target="_blank" rel="external">kalimdor</a></p>
<h2 id="远光软件">远光软件</h2>
<p><em>在远光软件的工作，主要是企业级开发，管理，报表分析系统，均部署在两网五大发电集团内部，无在线地址。</em></p>
<p>项目：<strong>EAP2.0平台seeker2.0平台框架开发与迁移旧系统到新平台框架下</strong> 时间：<strong>2013(03-08)</strong> </p>
<h4 id="平台开发说明">平台开发说明</h4>
<p>主要负责</p>
<ol>
<li>平台下的各个产品通用存储控制层。</li>
<li>MVC中的模型解析引擎，模型解析引擎，是以原始定义的元数据为基础，匹配框架自动填充的容器，来对应每一项。此项工作，还包括基础定义，与服务端取数，主要用于模型层的的解析以及存储各项提供给框架内部使用的存储容器。</li>
<li>用于数据表与样式表中触发是否有联级关系的项目，当存在联级项目时，触发此引擎工作。存储在公共容器中，多事件触发器组成，比如关闭单据时，触发此事件，以检测单据中的样式表与数据是否有数据变更的检测机制。</li>
<li>平台下各产品通用的基础消息用于统一的消息提示api，以及各项操作之后的动作返回。</li>
<li>用于平台框架下各控件的统一api调用，以及各控件之间的交互的UI基类。</li>
<li>用于各项单据中的验证，比如输入长度，是否为数据等各项在存储之前的验证检索验证机制。</li>
<li>控件开发，包括组合的对象控件：业务对象，部门对象，选择对象，银行对象，对话框，样式表数据表的隐藏域，基于父子关系的上下级模块。</li>
<li>基于seeker2.0框架，费用报销系统改造与升级工程。</li>
</ol>
<p><strong>在seeker2.0中，主要是将模型更加的通用化，平衡了在SMB所有产品关于调用API的规范化，并且把组件全部重写。另外把费用报销系统改造升级后，写了关于升级应用的PPT，和同事两个人，在评审中给领导讲解，以及给其他小组的同事培训如何运用。</strong></p>
<p>项目：<strong>费用报销系统，工程管理系统，核算系统</strong> 时间：<strong>2012（07-12）</strong></p>
<h4 id="负责开发说明">负责开发说明</h4>
<p><em>费用报销系统开发：</em>费用报销系统是以单据为节点，用于费用的报销，领导审批，会签，查看等。主要负责了界面UI开发，数据表渲染，单据绘画，基础存储模块，待办事项模块，单据查询模块。工具栏中的查看单据，上载资料，审批传递。单据中的样式表部分。</p>
<p><em>工程管理系统开发：</em>以费用报销系统为模版，增加了科目，预算体系，账目汇总等功能。主要负责了科目体系，与账目汇总。其余由，费用报销系统改动。</p>
<p><em>核算系统：</em>以费用报销系统为模版，增加了工程合同，审批等功能。主要负责了，会签审批这个功能。</p>
<p><strong>在这三个业务系统的开发中，最主要的贡献是解决了单据报表的绘画工作，主要是扩展和改进了当时的百度编辑器，让它更加的适应于企业财务人员的使用习惯。</strong></p>
<p>项目：<strong>seeker1.0框架开发</strong> 时间：<strong>2012(05-07)</strong></p>
<h4 id="负责开发说明-1">负责开发说明</h4>
<p>基于jqGrid的网格系统二次开发，开发单据设计器，比如：一键应用，选择单据项目，单据选择器，单据绘制等等，此部分应用在核算桌面软件中。seeker1.0主要是负责MVC，模型解析引擎的开发，与UI插件库的开发。此版本框架只应用于1.0版本的费用报销系统与其相应改动的其他系统。</p>
<p><strong>解决了当时在报表系统中，网格化表格的应用。加入SMB团队之后，加速了seeker1.0的开发进程，利用这个框架，三个人写了初版的费用报销系统，奠定了seeker1.0应用的模板。</strong></p>
<h2 id="湖南日报华声在线-教育频道">湖南日报华声在线-教育频道</h2>
<p><em>几年过去了，在线地址以及开发内容已经变更，这里不在提供。</em></p>
<p>项目：<strong>快乐学习网社交空间 新闻频道，作文频道，视频频道</strong> 时间：<strong>2011(08)-2012(04)</strong></p>
<h4 id="负责说明">负责说明</h4>
<p>快乐学习网社交空间，工作的内容是负责了全站的前端开发任务，空间类似于2011年的QQ空间。负责教育产品，社交空间的前端开发，培训组内的前端技术，并提供教育系列产品的前端解决方案，并负责一定的服务端开发工作，主要是拼写模板。</p>
<p>当时的站点，是基于jQuery编写的，使用的是jQuery1.4。</p>
<p><strong>第一次参加工作，这个阶段皆以学习琢磨为主，在当时的团队中，是主要的程序开发者，根据python的模板的特点，引入了jQuery_Template模板，改变了团队开发程序的形式，模板从服务端移到了在前端实现。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>开源项目，可以在 github 查看，主要分为两类项目，一类为给公司开发的开源工具，用来前端的编程效率，一类为自己的学习项目，比如桌面端的MVC一套解决方案，移动组件库，以及个人项目。</em></p>
<p><em>擅长领域，主要为javascript，python，关系型数据库为mysql，工作中以javascript为主。</em></p>
<h2 id="个人项目展示">个人项目展示</h2>
<p><a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">HTTP Proxy</a></p>
<p><a href="https://github.com/lcepy/kalimdor" target="_blank" rel="external">kalimdor MVC</a></p>
<p><a href="https://github.com/lcepy/Find" target="_blank" rel="external">Find zepto UI</a></p>
<p><a href="https://github.com/lcepy/nagrand" target="_blank" rel="external">nagrand onload</a></p>
<p><a href="https://github.com/lcepy/douban-shell-app" target="_blank" rel="external">douban-shell</a></p>
<p><a href="https://github.com/lcepy/downloadZIP" target="_blank" rel="external">webapp 打包工具</a></p>
<p><a href="https://github.com/lcepy/my-learning-project" target="_blank" rel="external">我的学习</a></p>
<p>]]>
    
    </summary>
    
      <category term="项目经历 维护" scheme="http://lcepy.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86-%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在实际工作中node开发的一些见解与调试]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%9C%A8%E5%AE%9E%E9%99%85%E5%B7%A5%E4%BD%9C%E4%B8%ADnode%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%81%E8%A7%A3%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://lcepy.github.io/2014/11/14/在实际工作中node开发的一些见解与调试/</id>
    <published>2014-11-14T12:04:45.000Z</published>
    <updated>2014-11-14T19:40:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>真实情况是这样的</strong> </p>
<ol>
<li>开发，前端与后端物理性的隔离，前端通过restful接口请求相应的数据，并在客户端渲染。</li>
<li>前端的渲染依赖于后端响应的数据，后端开发的进度永远比前端慢。</li>
<li>需要通过本地模拟数据，约定契约总是会纠结很久。</li>
<li>联调时，需要改多处代码。</li>
</ol>
<p><strong>治标不治本的解决方案</strong></p>
<p>为了解决工作中的上述问题，于是就想到了网络代理与客户端mock的功能，并且能很好的识别出错误，以及分发请求，<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a>。通过一对键值对来描述需要响应的请求，通过GET参数来适配读取本地，还是分发到网络，并对响应的请求response进行内存缓存与物理缓存。本地构建的元数据，可以使用mock来生成。</p>
<p>但是上述的解决方案，并没有解决工作中出现的问题。反而加重了开发的成本，问题3，依然没有很好的解决，而问题4解决了一半，联调时依然需要更改多处，不然提交到测试的代码，还是键值对中映射的地址，虽然我的本机可以访问，但是测试人员却访问不了。</p>
<p>上遇到上述问题的时候，我一直在想，是不是需要另外启用一个服务器来做代理的代理。我实现了上述需要解决的几个问题，比如分解model.js中测试地址，将这个测试地址，生成为一个配置文件，提供给代理服务器2，代理服务器1依然是之前的配置文件。在webapp发起请求时，代理服务器1截取请求，提交给代理服务器2，代理服务器2获取完毕后，发送给远程。</p>
<p>这个问题好像，滚雪球一样，越滚越大。后来，我的同事找到了一个比较好的方案，我编写的一半socket proxy基本上可以废弃了。我们使用了fiddler来做代理服务器1.</p>
<p>这里的逻辑是这样的，在启动glob-proxy时，我提供了两个API出来，一是：抓取配置文件中的model.js，根据测试URL生成fiddler需要的xml配置文件，并将这个xml导入到fiddler中。如果是local=1，glob-proxy将扫描本地文件，来做响应。如果local为false，请求将通过glob-proxy发送到fiddler中，fiddler去请求远程，来响应node服务器，node服务器再响应给webapp。</p>
<p>好在上述，难的地方已经处理好了，现在要理清的还是这个请求代理的逻辑顺序。但是这样的绕，是不是有些比较蛋疼呢。<br><a id="more"></a><br><strong>好好整理了资料，并思考了一个问题</strong></p>
<p>通常情况下，我们的webapp还需要解决SEO的问题，基本上来说这是一个无解的过程。ajax请求在客户端渲染的webapp，对搜索引擎并不友好。而且与后端的约定契约问题，也让人头疼。我在想，既然nodejs的出现，为什么不能把职能划分的更加请求，把契约留给前端的开发人员不是更加的合理？</p>
<p>带着这样的疑问，上网搜索了很多资料，包括淘宝那边提出并实现的<a href="http://ued.taobao.org/blog/category/bowen/frontend/" target="_blank" rel="external">前后端分离</a>比较受到启发。</p>
<p><strong>说说我的感觉</strong></p>
<p>我们的公司是.net做的基础平台，如果能让.net去更加的专注于数据模型，而前端开发人员通过请求代理，或者socket编程来访问数据模型，自己定义相应的数据，自己选择是否在客户端渲染，还是在服务端渲染，这样的形式，岂不是更加的合理？中间消除了，大量的问题。</p>
<ol>
<li>与后端沟通的问题</li>
<li>再也不需要契约，或者glob-proxy了</li>
<li>解决了SEO的问题</li>
<li>根据模板，跨终端。因为javascript的模板，可以在客户端，服务端两处进行渲染工作。</li>
</ol>
<p>web安全性与性能方面的考虑，或许是对前端开发人员的一种制约。请求=消耗，这样的消耗是不是用户能接受的？这样的工作方式，是不是能节约成本，并且对整体项目是不是有益处的。而且安全性方面，可以考虑把node这一层，在前期做为一个代理层，node只处理表面的数据，最终通过SOAP或者SOCKET提交给.net平台去做验证？而web上的安全性考虑，比如CSRF XSS这些都可以放在node这一层来做。</p>
<p>我觉得这样的方式，是可行的。对于公司而言，那4个问题最大的成本，而对开发者来说，那4个问题很烦。</p>
<h1 id="node_debug">node debug</h1>
<blockquote>
<p>npm install -g supervisor</p>
<p>npm install -g node-inspector</p>
</blockquote>
<p>这两个工具，在nodejs开发中是非常有用的，debug并不是太难，写这个的原因，是想记录下来。首先，安装这两个模块，全局模式。如果是linux或mac系统，输入sudo给予权限即可。</p>
<p>一般情况下node-inspector使用默认端口8080，当然也可以改变端口。输入node-inspector —help，可以查看命令行的帮助信息，如：『截取了部分帮助信息』</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">-help</span></div><div class="line"></div><div class="line">-<span class="ruby">-version</span></div><div class="line"></div><div class="line">-<span class="ruby">-web-port={number}</span></div><div class="line"></div><div class="line">-<span class="ruby">-web-host={string}</span></div><div class="line"></div><div class="line">-<span class="ruby">-debug-port={number}</span></div></pre></td></tr></table></figure>

<p>如果想要改变端口，可以在命令行中输入node-inspector —web-port=xxx —debug-port=xx。<br>而supervisor，则是一个非常有用的监听工具，能帮助我们重启node服务。我一般的做法是与node-inspector配合使用。比如，我会先开启一个debug的端口。node-inspector —web-port=8055 默认的debug端口依然是5858。然后在chrome中打开<a href="http://127.0.0.1:8080/debug?prot=5858，调出debug页面。然后另外启用一个命令行，输入supervisor" target="_blank" rel="external">http://127.0.0.1:8080/debug?prot=5858，调出debug页面。然后另外启用一个命令行，输入supervisor</a> —debug xx.js来运行这份debug监听。</p>
<p><em>主题配置采用的是 theme flatland</em></p>
<ol>
<li>配置SublimeREPL编译器环境，运行在编辑器内运行PYTHON，编译器环境可选，不一定是PYTHON。<a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">下载</a></li>
<li>配置python语法智能提示，当然也不仅仅是PYTHON的语法智能提示<a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="external">下载</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>真实情况是这样的</strong> </p>
<ol>
<li>开发，前端与后端物理性的隔离，前端通过restful接口请求相应的数据，并在客户端渲染。</li>
<li>前端的渲染依赖于后端响应的数据，后端开发的进度永远比前端慢。</li>
<li>需要通过本地模拟数据，约定契约总是会纠结很久。</li>
<li>联调时，需要改多处代码。</li>
</ol>
<p><strong>治标不治本的解决方案</strong></p>
<p>为了解决工作中的上述问题，于是就想到了网络代理与客户端mock的功能，并且能很好的识别出错误，以及分发请求，<a href="https://github.com/lcepy/glob-proxy" target="_blank" rel="external">glob-proxy</a>。通过一对键值对来描述需要响应的请求，通过GET参数来适配读取本地，还是分发到网络，并对响应的请求response进行内存缓存与物理缓存。本地构建的元数据，可以使用mock来生成。</p>
<p>但是上述的解决方案，并没有解决工作中出现的问题。反而加重了开发的成本，问题3，依然没有很好的解决，而问题4解决了一半，联调时依然需要更改多处，不然提交到测试的代码，还是键值对中映射的地址，虽然我的本机可以访问，但是测试人员却访问不了。</p>
<p>上遇到上述问题的时候，我一直在想，是不是需要另外启用一个服务器来做代理的代理。我实现了上述需要解决的几个问题，比如分解model.js中测试地址，将这个测试地址，生成为一个配置文件，提供给代理服务器2，代理服务器1依然是之前的配置文件。在webapp发起请求时，代理服务器1截取请求，提交给代理服务器2，代理服务器2获取完毕后，发送给远程。</p>
<p>这个问题好像，滚雪球一样，越滚越大。后来，我的同事找到了一个比较好的方案，我编写的一半socket proxy基本上可以废弃了。我们使用了fiddler来做代理服务器1.</p>
<p>这里的逻辑是这样的，在启动glob-proxy时，我提供了两个API出来，一是：抓取配置文件中的model.js，根据测试URL生成fiddler需要的xml配置文件，并将这个xml导入到fiddler中。如果是local=1，glob-proxy将扫描本地文件，来做响应。如果local为false，请求将通过glob-proxy发送到fiddler中，fiddler去请求远程，来响应node服务器，node服务器再响应给webapp。</p>
<p>好在上述，难的地方已经处理好了，现在要理清的还是这个请求代理的逻辑顺序。但是这样的绕，是不是有些比较蛋疼呢。<br>]]>
    
    </summary>
    
      <category term="node&amp;js" scheme="http://lcepy.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于中小项目我该如何组织我的代码]]></title>
    <link href="http://lcepy.github.io/2014/11/14/%E5%AF%B9%E4%BA%8E%E4%B8%AD%E5%B0%8F%E9%A1%B9%E7%9B%AE%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://lcepy.github.io/2014/11/14/对于中小项目我该如何组织我的代码/</id>
    <published>2014-11-14T11:19:11.000Z</published>
    <updated>2014-11-14T19:41:18.000Z</updated>
    <content type="html"><![CDATA[<p>从三个角度来分析</p>
<ol>
<li>我需要什么（need）</li>
<li>我为什么需要这些（why this）</li>
<li>我能做些什么（what can）</li>
</ol>
<p>在这里讨论的一个命题是为了一个不大不小的项目来组织一套可以应用的移动开发流程，能否达到预期的目标，能否使用于中小公司，以及业务不是企业级复杂的逻辑。对于现在越来越工程化的前端体系，组织好它，我可能需要很多额外的工具，来辅助我效率的开发。</p>
<p><a id="more"></a><br><strong>移动开发H5版实例</strong></p>
<h2 id="命题1：我需要什么">命题1：我需要什么</h2>
<p>我罗列了一部分我能思考到的东西，从如下几个地方来分析：</p>
<ol>
<li>我需要一套标准化的UI</li>
<li>我需要模块化加载来实现对代码模块级别的控制</li>
<li>我需要对代码风格，以及层级的划分</li>
<li>我需要对文件操作的自动化</li>
<li>我需要模板引擎</li>
<li>我需要工具库</li>
<li>我需要消除浏览器兼容的选择器，事件系统，ajax，以及动画系统。</li>
</ol>
<p>是的，如上七个方向，看看，原来我需要这么些东西，来构建一个移动H5的应用。</p>
<h2 id="命题2：我为什么需要这些">命题2：我为什么需要这些</h2>
<p>从上述的七个方向，构成了我基于它的分析，从而来构建自己的应用。但是它仍然抽象，不好理解。比如一套标准的UI，那么什么才是标准？又比如代码风格，以及层级的划分，那么什么样的代码风格和层级划分才比较适合呢？这个命题的讨论，就是把上述的分析方向具体到某些工具的选择，以及实现。</p>
<ol>
<li>标准化的UI，这里选择的是ratchet，做为bootstrap原班人马对移动H5的重新实现，它还是值得信赖的。利用它，节省了大量的UI实现以及风格命名，如果需要无法实现，可以在它的基础上来修正视觉，以及利用它的结构，来重新书写UI。虽然它不是标准，但是大量的设计，有参考的价值。</li>
<li>对于模块化加载器的选择，我更倾向于require.js，浏览器的开发，模块有意义，但是生产分离这么多模块就没有意义了。相比seajs，require.js更加的熟悉，以及它打包工具的使用。</li>
<li>代码风格的作用，是为了给今后的伙伴或者未来的日子，自己查看阅读使用的。好的风格，在修改bug时，心情可以愉悦。如果几个风格凑合在一起的代码，我想想都比较纠结。所以说到代码风格，又不能不提到层级的划分，以及整个应用业务逻辑实现的规划。你想使用哪些？MVC？MVP？MVVM？这些都有个综合考虑，有些业务场景，也许比较适合MVC，而又有些业务场景又比较适合MVVM，不是说谁比谁更先进，而是谁比谁更适合你的业务。在这里，我选择使用的是MVP。一个非常小巧的库来构建分层系统与代码风格：riot.js。<a href="http://www.oschina.net/translate/riotjs-the-1kb-mvp-framework" target="_blank" rel="external">什么是MVP</a></li>
<li>自动化的意义，是在于帮助开发者解决琐碎的事情，例如文件的压缩，开发时的静态资源，代码检查，自动重启服务器与清楚缓存等等，现在市面上，有几个关于构建自动化任务的工具，相比之下，这里选择了一个比较稳定而且大众的工具：grunt。</li>
<li>模板的出现，可以最大限度的复用结构。移动端H5的开发，需要关注渲染的速度，于是这里我选择一款比较小众但是性能非常不错的模板引擎artTemplate，它书写的风格比较类似于Python模板的风格，它甚至可以把一个模板分拆为几个子模板，最大程度的复用。 </li>
<li>工具类的选择，市面上有几个比较流行的工具库，如underscore。这里的选择，可以把常用的模块抽取出来，并组织进统一的顶层空间中。另外，有些朋友收集了一些，可以替代underscore的工具库，也可以抽取部分，如Lo-Dash。<a href="http://lodash.com/docs" target="_blank" rel="external">lodash DOC</a></li>
<li>最后我们要消除处理DOM时的兼容，我选择的是zepto，它有15个模块，而常用的模块，我们可以抽取出来。比如选择器引擎，AJAX，事件系统。当然动画系统，我认为，可以利用css3实现一个自己的小helper，它可以更加的小巧，而且可以利用硬件加速来保证流畅度。</li>
</ol>
<h2 id="命题3：我能做些什么">命题3：我能做些什么</h2>
<p>当我们把上述七个方向的东西，整合成一套体系时，能做的事情，可以根据你的想象，而无限扩大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从三个角度来分析</p>
<ol>
<li>我需要什么（need）</li>
<li>我为什么需要这些（why this）</li>
<li>我能做些什么（what can）</li>
</ol>
<p>在这里讨论的一个命题是为了一个不大不小的项目来组织一套可以应用的移动开发流程，能否达到预期的目标，能否使用于中小公司，以及业务不是企业级复杂的逻辑。对于现在越来越工程化的前端体系，组织好它，我可能需要很多额外的工具，来辅助我效率的开发。</p>
<p>]]>
    
    </summary>
    
      <category term="代码组织" scheme="http://lcepy.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年夏天骑行计划安排事项]]></title>
    <link href="http://lcepy.github.io/2014/11/14/2015%E5%B9%B4%E5%A4%8F%E5%A4%A9%E9%AA%91%E8%A1%8C%E8%AE%A1%E5%88%92%E5%AE%89%E6%8E%92%E4%BA%8B%E9%A1%B9/"/>
    <id>http://lcepy.github.io/2014/11/14/2015年夏天骑行计划安排事项/</id>
    <published>2014-11-13T16:30:26.000Z</published>
    <updated>2014-11-14T19:41:46.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://websources.qiniudn.com/img/wow.jpg" alt="回忆是一幅风景"></p>
<h2 id="装备预算">装备预算</h2>
<p><strong>骑行必备装预算，计算总价为最低档。</strong></p>
<p>如果选择捷安特的整车，如XTC750,XTC790的话，预算分别为3300，5300</p>
<p>如果是自己配置的话，尽量选择高性能的车架，轮胎，以及变速器，预算也在2500-3000左右。</p>
<p>魔术头巾，大概6-15元</p>
<p>头盔 120-160元</p>
<p><em>头盔要选择轻量的，通风口越多的头盔。</em></p>
<p>骑行太阳镜 100-130元</p>
<p><em>骑行眼镜要选择对光线处理的比较好的</em></p>
<p>水壶，水壶架，前后置灯光</p>
<p>40元  20元  58元</p>
<p><em>建议是来穿衣要穿白色或五颜六色的衣服，目标比较醒目。</em></p>
<p>捷安特750，魔术头巾，头盔，骑行太阳眼镜，水壶，水壶架，前后置灯光</p>
<p>总价：3708元</p>
<p><strong>不可选项，但为整个车队携带</strong></p>
<p>山地车维修工具</p>
<p><em>注明：一个车队带一套即可，配件为三份</em></p>
<p>山地车链条（3）</p>
<p>山地刹车（2）</p>
<p>山地车轮胎（1）</p>
<p><strong>轮胎的价格大概50-80，刹车如果带一个碟刹，大概400-600，一个V刹车200-300，链条比较便宜，几十块。维护工具选择了一个专业的工具套装大概300元左右，维修工具由某个人单独购买吧，不计入预算。</strong></p>
<p>总价：740-1070元</p>
<p>外伤医疗包</p>
<p>感冒药以及一些必备药品<br><a id="more"></a><br><strong>外伤，主要是双氧水，碘酒，纱布，棉签，这些消毒用品。药物方面，主要携带，感冒药，消食片等等辅助类的。这一类价格在100-200元左右</strong></p>
<p><strong>不可选的装备预算大概在4700左右，也就是将近5000块钱了。建议项目，选择高性能的车架，车垫，以及骑行裤子，这样会，在出发前，要科学的练习一下骑行姿势的训练，这样能减少骑行过程中所出现的问题。</strong></p>
<h2 id="游玩预算">游玩预算</h2>
<p><em>一路大概要经过13个城镇，必须的费用为吃，住宿。吃的方面可以节约一点，晚上可以吃好一点，其他主要是干粮和水，住宿的话，也可以住旅社，不住酒店。</em></p>
<p>旅社住宿的费用大概一晚100-150</p>
<p>吃的费用也不贵。</p>
<p>我的算法是一个人五千的预算，另外再放一个2000的预算为额外的预算。</p>
<p>5000元主要是走完全程，以及路上去旅游景点的费用，以及可能出现的状况。</p>
<p>我会分配20%的为一号额外预算，另外放的2000为0号额外预算。</p>
<p><strong>2000 5000  这个地方没法估算，只能在路上看具体的情况，大概是不会超出5000的。一个人身上带2000的现金，其余的钱都放到一个人的银行卡里，另外在带一张备用的空卡。</strong></p>
<p><strong>整体的费用估算，只包括所有必选项，预算费用在12000左右</strong></p>
<p><strong>可选项</strong></p>
<p><em>可选看个人的需求购买，这里的罗列我已全部装备。</em></p>
<p>骑行衣裤（两套）</p>
<p>骑行鞋子</p>
<p>骑行护手</p>
<p>骑行护膝</p>
<p>骑行袜子</p>
<p>旅行背包</p>
<p>照相机</p>
<p>心率仪</p>
<p>车载摄像仪</p>
<p>军刀</p>
<p>红外线测试仪（野外的热能探测）</p>
<p>匕首</p>
<p>防水的打火机</p>
<p>雷朋太阳眼镜</p>
<p>通信设备</p>
<p>GPS定位（可以用手机替代）</p>
<p>低频干扰仪</p>
<p>对讲机</p>
<h2 id="路线大纲建议">路线大纲建议</h2>
<h3 id="这是一份建议性质的计划，路程上完全凭借个人自己的主观意愿来决定骑行哪一条线路，是否要统一思想，待大家讨论决定。骑行具有一定的危险性，而且我们都仅仅是个人爱好一起出发（自助的形式），所以出发前，各自检查身体状况，购买好保险。测试阶段，仅仅是我和我表弟在家中测试我们自己的车的性能与设备能否正常工作，不具备统一性。">这是一份建议性质的计划，路程上完全凭借个人自己的主观意愿来决定骑行哪一条线路，是否要统一思想，待大家讨论决定。骑行具有一定的危险性，而且我们都仅仅是个人爱好一起出发（自助的形式），所以出发前，各自检查身体状况，购买好保险。测试阶段，仅仅是我和我表弟在家中测试我们自己的车的性能与设备能否正常工作，不具备统一性。</h3>
<p><strong>这份计划建议，主要是规划了行车路线点到点详细的路线图，以及在哪里停留，休整，补给，游玩。另外补充了补给内容与游玩内容的建议，最后总结了为什么要计划一次这么长途跨省的穿越。</strong></p>
<p><em>游玩路线，根据到达当地再做决定</em></p>
<h2 id="第一阶段，测试长途距离的车性与整车磨合度（我和我表弟）">第一阶段，测试长途距离的车性与整车磨合度（我和我表弟）</h2>
<p><strong>注明：这是一项测试。</strong></p>
<h4 id="第一天，洪江区">第一天，洪江区</h4>
<p>从鹤鸣洲，小姑姑家出发，沿着之前的怀黔公路，到达安江，中午到向昆家略停休整，全程大概52公里左右。要不要去大年溪爷爷家？看情况。如果去，则在安江休整一日。如果不去，则避开中午高温区间，走222省道，一直沿着沅江到达洪江老区，晚上在此休息，大概34.2公里，晚上到区政府借住。</p>
<p><em>全程大概86.2公里</em></p>
<h4 id="第二天，洪江区">第二天，洪江区</h4>
<p>第二天上午对水，干粮，进行补给（视情况而定对车配件进行补给与维护），中午走一走洪江古商城，考察一下，如果开辟骑行线路，有没有可行性，过深渡苗乡的时候，看看有没有可以利用的中间休整据点。（如果这条线路，可行，中间某个地方肯定需要一个补给点）</p>
<p><strong>已经被人忘记的中国第一古城，活化石。</strong></p>
<blockquote>
<p>洪江老区，主要是古商城</p>
</blockquote>
<p>游玩看情况而定一天或者两天</p>
<h4 id="第三天，洪江市">第三天，洪江市</h4>
<p>洪江在当地会指三个地方，新建的黔城镇，洪江老区，安江镇，我们从老家过来，最后到达新城黔城。</p>
<p>选择方案一：沿着沅江向西北方向骑行，一直到达209国道进入黔城。</p>
<p><em>全程大概24.3公里</em></p>
<p>选择方案二：清早起床，坐船去黔城。</p>
<p>晚上在黔城休整一天，去洪江军区老干所外公家里住一晚。</p>
<p><strong>黔城也是一个旅游风景区，是否游玩看情况而定。</strong></p>
<blockquote>
<p>芙蓉楼</p>
</blockquote>
<p>返回鹤鸣洲，对车进行一次长期的修检，补给与休整三日。</p>
<p><em>全程大概42.2公里</em></p>
<p><strong>测试阶段，主要是为了车自身况与零配件的磨合程度，人与人之间长距离的磨合，协调，以及其他电子设备是否在非正常环境中能够正常工作，其他装备的磨合程度。时间计算大概在五天或者七天之间，全程大概为：157.8公里，不会超过200公里的路程。</strong></p>
<h2 id="测试项">测试项</h2>
<p>短期长距离的抗压测试的好处，是能了解整个系统在这样的非正常环境下能否正常的工作，能否维护与维修，路上大家的协调能力，以及身体素质方面的测试。</p>
<p>变速器是否工作正常，刹车系统是否工作正常，传动系统是否能工作正常，越野轮胎的耐压性，整车抗压性。</p>
<p>车载测速仪是否工作正常，车载摄像仪是否工作正常，单反相机能否工作正常，地图导航方面是否精准。</p>
<p>身体抗压能力，路上行车的反应能力</p>
<h2 id="第二阶段，怀-昆（天数另外计算，这里只规划路线_出发阶段）">第二阶段，怀-昆（天数另外计算，这里只规划路线 出发阶段）</h2>
<p><strong>注明：不去凤凰，直接走芷江，新晃，穿过贵州到达昆明。另外路途之上，我会用车载摄像仪进行全程录像，不游玩，只过路，一直到达贵阳，昆明两个节点。</strong></p>
<h4 id="目标_，新晃">目标 ，新晃</h4>
<p>中午到达芷江，大概41.6公里，一直沿着320国道走，休息一两小时。下午继续沿着320国道，到达新晃，大概64.8公里。</p>
<blockquote>
<p>沿途大部分是沿着舞水河，一直到达新晃，晚上吃侗族菜，去看侗族歌舞。 </p>
<p>到达芷江后，是否去抗日纪念馆，天后宫，中国侗文化城，龙津风雨桥</p>
<p>到达新晃后，是否去夜郎古乐城，夜郎大峡谷，龙溪古镇</p>
</blockquote>
<p><em>全程大概106.4公里</em></p>
<p><strong>从进入贵州开始，路都不太好走了，因为不是国道，所以行车时一定要注意安全，保持对路况的了解。第二天的行程，可能会延误，如果天黑之前到达不了镇远，去附近的某个苗族村借住一晚。</strong></p>
<h4 id="目标，镇远">目标，镇远</h4>
<p>早晨出新晃，就进入贵州境了，一直到达岑巩，大概46.6公里，休息一两小时，下午沿着S306省道，到达镇远，大概52.4公里。晚上主要是进行补给与检查车的状况，注意休息与保暖，另外去吃苗族菜。</p>
<p><em>全程大概99公里</em></p>
<blockquote>
<p>镇远，我建议游玩一下，中国最美的十大古城之一，据称。</p>
<p>镇远城，青龙洞，舞阳河等等</p>
</blockquote>
<h4 id="目标，黄平">目标，黄平</h4>
<p>到达黄平大概有71公里左右，因为都是山路，另外从镇远到黄平中间，大部分都是森林和山，需要准备干粮，中间会经过一个小县城。晚上就在黄平休息，晚上吃贵州火锅，看苗族歌舞。</p>
<p>全程大概71公里</p>
<blockquote>
<p>浪洞温泉</p>
</blockquote>
<h3 id="目标，贵定">目标，贵定</h3>
<p>从黄平到贵定，中间没有任何城市，而且全是森林与山，需要准备干粮，全程大概有120公里左右，晚上在贵定休息。</p>
<p>全程大概120公里</p>
<blockquote>
<p>黄龙山高原草场景区</p>
</blockquote>
<h3 id="目标，贵阳">目标，贵阳</h3>
<p>从贵定直接到贵阳，路程79公里左右，在贵阳休息三天。 </p>
<p><em>全程大概79公里</em></p>
<h2 id="贵阳游玩（待更详细）">贵阳游玩（待更详细）</h2>
<blockquote>
<p>青岩古镇，黔灵山，黄果树，晚上逛夜市，弘福寺 酸汤鱼、辣子鸡、丝娃娃、花江狗肉、肠旺面、牛肉粉</p>
</blockquote>
<h1 id="只规划贵阳之前的游玩大概，之后的在路上再决定。">只规划贵阳之前的游玩大概，之后的在路上再决定。</h1>
<h4 id="目标，镇宁">目标，镇宁</h4>
<p>到达平坝全程58.4公里，中午在此休息，晚间到达镇宁，大概70.7公里，这里看情况，如果可以就走完全程，中间没有可以停留的县城，如果不行就在平坝休息，第二天走镇宁。</p>
<p><em>全程大概130公里</em></p>
<blockquote>
<p>夜郎洞风景区，以及民俗</p>
</blockquote>
<h4 id="目标，兴仁">目标，兴仁</h4>
<p>从贵州进入云南，只有一个县城兴仁，相距大概161.2公里，全程都是森林，山路。</p>
<p><em>全程大概161.2公里</em></p>
<h4 id="目标，罗平">目标，罗平</h4>
<p>从这里开始就进入云南了，到达罗平141公里，这里中间考虑在兴义休息一天，还是直接进入云南。</p>
<p><em>全程大概141公里</em></p>
<blockquote>
<p>腊山湖，九龙瀑布群，多依河景区</p>
</blockquote>
<h4 id="目标，石林">目标，石林</h4>
<p>这里已经接近昆明了，到达石林，大概157.6公里。</p>
<p><em>全程大概157.6公里</em></p>
<blockquote>
<p>云南石林世界地质公园</p>
</blockquote>
<h3 id="目标，昆明">目标，昆明</h3>
<p>到达昆明大概91.7公里</p>
<h2 id="昆明游玩（待更详细）">昆明游玩（待更详细）</h2>
<p>计划在昆明游玩三天或五天，主要是吃，风景游玩等等，另外看看能不能找到北上德钦的骑行队伍，如果有则跟随大队伍出发，没有则按如下第三阶段出发。 </p>
<h2 id="第三阶段：昆-德">第三阶段：昆-德</h2>
<p><strong>从这里开始，就要进入青藏高原地区了，这边是属于边缘部分了，需要准备御寒的衣物。另外第三阶段的细节问题，待到云南昆明后再做筹备，这里只做一个大概的规划。</strong></p>
<h3 id="目标，大理">目标，大理</h3>
<p><em>全程407.1公里，</em>这里可以计划分批次跑完全程，在大理待的天数，看当时情况而定。</p>
<h3 id="目标，丽江（最后可能到达的最终地点或者到香格里拉）">目标，丽江（最后可能到达的最终地点或者到香格里拉）</h3>
<p><em>全程182.5公里，</em>这里依然可以计划分批次跑完全程，在丽江待的天数，看当时的情况而定</p>
<h3 id="目标，德钦（这边已经是高原了，需要穿过一个雪山去不去，看情况）">目标，德钦（这边已经是高原了，需要穿过一个雪山去不去，看情况）</h3>
<p><em>全程370.9公里，</em>这里依然是计划分批次跑完全程，在德钦待的天数，看当时的情况而定。</p>
<h2 id="第四阶段：回程_||_进藏（拉萨）">第四阶段：回程 || 进藏（拉萨）</h2>
<p>对于第四阶段的描述，为看当时大家的情况而定，是否是从德钦开始回程，还是从滇藏南线进入西藏，最后到拉萨，在拉萨游玩一周，从拉萨坐火车，或者飞机回到长沙。</p>
<p><strong>这一阶段的情况，是一个可选的建议，看当时的情况而定。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://websources.qiniudn.com/img/wow.jpg" alt="回忆是一幅风景"></p>
<h2 id="装备预算">装备预算</h2>
<p><strong>骑行必备装预算，计算总价为最低档。</strong></p>
<p>如果选择捷安特的整车，如XTC750,XTC790的话，预算分别为3300，5300</p>
<p>如果是自己配置的话，尽量选择高性能的车架，轮胎，以及变速器，预算也在2500-3000左右。</p>
<p>魔术头巾，大概6-15元</p>
<p>头盔 120-160元</p>
<p><em>头盔要选择轻量的，通风口越多的头盔。</em></p>
<p>骑行太阳镜 100-130元</p>
<p><em>骑行眼镜要选择对光线处理的比较好的</em></p>
<p>水壶，水壶架，前后置灯光</p>
<p>40元  20元  58元</p>
<p><em>建议是来穿衣要穿白色或五颜六色的衣服，目标比较醒目。</em></p>
<p>捷安特750，魔术头巾，头盔，骑行太阳眼镜，水壶，水壶架，前后置灯光</p>
<p>总价：3708元</p>
<p><strong>不可选项，但为整个车队携带</strong></p>
<p>山地车维修工具</p>
<p><em>注明：一个车队带一套即可，配件为三份</em></p>
<p>山地车链条（3）</p>
<p>山地刹车（2）</p>
<p>山地车轮胎（1）</p>
<p><strong>轮胎的价格大概50-80，刹车如果带一个碟刹，大概400-600，一个V刹车200-300，链条比较便宜，几十块。维护工具选择了一个专业的工具套装大概300元左右，维修工具由某个人单独购买吧，不计入预算。</strong></p>
<p>总价：740-1070元</p>
<p>外伤医疗包</p>
<p>感冒药以及一些必备药品<br>]]>
    
    </summary>
    
      <category term="骑行 户外" scheme="http://lcepy.github.io/tags/%E9%AA%91%E8%A1%8C-%E6%88%B7%E5%A4%96/"/>
    
  </entry>
  
</feed>
