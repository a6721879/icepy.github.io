<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[icepy]]></title>
  <subtitle><![CDATA[曾记否，到中流击水，浪遏飞舟!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://icepy.github.io/"/>
  <updated>2015-03-28T06:47:12.409Z</updated>
  <id>http://icepy.github.io/</id>
  
  <author>
    <name><![CDATA[icepy]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[陀螺]]></title>
    <link href="http://icepy.github.io/2015/03/19/%E9%99%80%E8%9E%BA/"/>
    <id>http://icepy.github.io/2015/03/19/陀螺/</id>
    <published>2015-03-19T08:25:26.000Z</published>
    <updated>2015-03-28T06:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>最近在生活中遇到了很多挫折，一个无所事事的状态，其实非常的糟糕，为什么这么说，因为人一旦无所谓，就会无所畏惧，就会混乱。也许走入社会一直以来，都非常的顺利，没有经历这些挫折，根本无法了解这个社会的残酷。</p>
<p>最近一直喜欢听李健的歌，特别是这首《陀螺》，很真实的写照。人，应该要学会陀螺的心态，把一些负面的情绪，心态，全部转走。为什么？因为只有这样，才能调整好自己，用一个很轻松的状态去面对自己。陀螺，其实它一直在旋转，就好比，它会面对很多不断接触的东西，喜怒哀乐，而且一直停不下来。它要在沉默中转，在孤独中转，在欢笑中转，在泪水中转。</p>
<p>如果我能陀螺的心，那该多好，但我还是我，一个非常任性的人。喜欢了，特别的喜欢。不喜欢了，特别的不喜欢。这样的对错是非观念非常强烈的一个人，在社会中，摸爬滚打，是非常不利的。我的情绪都表现在脸上，无形中，或许得罪或者让别人感觉到难堪。但是，如果我有一个陀螺的心，我能很从容，荣辱不惊的面对这些，迟早要转过这一页，不是么？</p>
<p>李健不愧是一个用诗唱歌的人，这样的情绪，直透人心。是非曲折，道理谁都会明白，但是往往处理起来，却又很意想不到。时至今日，我该有一个陀螺的心了，不能再像以前那样，如此任性。虽然这些年里，欢笑，泪水相交织，度过了人生，很重要的一个时刻。从一个平平无奇的过路人，到了一个人爱编程，分享，写作的程序员，其实背后的付出，真的是，可以用‘心酸’二字。真正的摸爬滚打的真谛，我还未触及，因为这一路，有人帮助，有人提携，有人教授。于是，有了一次，比较真正的面对自我的过程。来到北京，去面试，去找工作。</p>
<p>人是一个非常复杂的情绪化的动物，人也是一个很有欲望的动物。但是，为什么说，欲望能促进进步呢？很可能，欲望会转化为动力，动力就能推动人自身的进步。我有欲望吗？其实是有的，但是这样的欲望，又有些不切实际。时间，就像是一把锁，已经把过去的锁住了。我们没法改变时间，也没法去打开这把锁。而我欲望，这看来，确实很傻逼。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在生活中遇到了很多挫折，一个无所事事的状态，其实非常的糟糕，为什么这么说，因为人一旦无所谓，就会无所畏惧，就会混乱。也许走入社会一直以来，都非常的顺利，没有经历这些挫折，根本无法了解这个社会的残酷。</p>
<p>最近一直喜欢听李健的歌，特别是这首《陀螺》，很真实的写照]]>
    </summary>
    
      <category term="生活" scheme="http://icepy.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Native与H5交互的原理]]></title>
    <link href="http://icepy.github.io/2015/03/14/Native%E4%B8%8EH5%E4%BA%A4%E4%BA%92%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://icepy.github.io/2015/03/14/Native与H5交互的原理/</id>
    <published>2015-03-14T04:14:50.000Z</published>
    <updated>2015-03-20T12:05:46.000Z</updated>
    <content type="html"><![CDATA[<p>在做混合应用时，H5与Native通信的重要性，我想每一个H5开发者都非常的清楚。通过它，我们可以很好的借用Native API的优势来实现自己想做的事情，业界有一个非常成熟的框架让大家选择，它就是PhoneGap。混合开发，并不是意味着什么App都可以做，它也有局限性。在写交互原理之前，我想先写写自己的体会。</p>
<ul>
<li>混合开发使用的语言是JavaScript由于系统分配的资源始终有限，在UIWebView这个容器中运行，效率跟原生的差距是非常明显的</li>
<li>应用需要解决首次加载白屏的问题，因为资源加载的速度始终有些慢</li>
<li>这玩意调试起来很痛苦，不像在web端有chrome的开发者工具，iOS有Xcode</li>
<li>iOS和android交互始终不一样，但是混合应用提供了一个统一的UI，目前不清楚用户是否能习惯交互</li>
<li>关于通信JavaScript到Native是一个异步的过程，而Native到JavaScript是一个同步的过程</li>
</ul>
<p>那么使用混合应用在什么场景下比较有优势呢？</p>
<ul>
<li>内容驱动型的应用</li>
<li>经常需要调整UI的应用</li>
<li>经常需要调整业务的应用</li>
<li>交互不复杂并且不需要大量计算的应用</li>
</ul>
<p>总结起来，比如携程的App，因为都是内容驱动，比如购买门票，旅游之类的，又比如淘宝的App，大量商品类的展示，以及一些如图书，查询，工具类的应用，混合开发在这些场景下，有很明显的优势。</p>
<p>言归正传，因为iOS并没有提供原生的调用API，所以当JavaScript跟Native进行通信时，就需要利用一些技巧了。UIWebView这个容器，除了可以加载请求之外，也可以加载本地资源，如果当一个页面发起请求时，是要经过UIWebView的，于是有人会想，我能知道这个URL么？不错，UIWebView可以拦截这个request，并且知道它的全部。那么UIWebView可以通知页面不，这个依然可以。利用这些原理技巧，于是两端通信的问题就解决了。</p>
<p>在UIWebView中实现UIWebViewDelegate协议，就可以拦截到页面端发送的request。</p>
<pre><code>-(<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(UIWebViewNavigationType)navigationType
{
    <span class="built_in">NSURL</span> *url = [request URL];
    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"test"</span>]) {
        [_webView stringByEvaluatingJavaScriptFromString:<span class="string">@"window.iOSPhoneName = 'iam lcepy'"</span>];
        <span class="keyword">return</span> <span class="literal">NO</span>;
    }
    <span class="keyword">return</span> <span class="literal">YES</span>;
}
</code></pre><p>返回YES表示执行浏览器的默认执行，返回NO表示不执行浏览器的默认执行</p>
<p>而从Native到JavaScript可以利用上stringByEvaluatingJavaScriptFromString方法，执行Js字符串，它就能在UIWebView中执行这一段Js代码。在客户端，我们知道全局的对象是window，如果在客户端需要获取结果，可以把Native执行的结果放到window上。</p>
<p>那么Js这一端如何实现呢？不错，利用的就是隐藏的iframe。</p>
<pre><code><span class="keyword">var</span> requ = $(<span class="string">'#requestToNative'</span>);
requ.bind(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);
    iframe.style.display = <span class="string">'none'</span>;
    iframe.src = <span class="string">'test://iOS/userInfo'</span>;
    <span class="keyword">var</span> requs = requ[<span class="number">0</span>];
    requs.appendChild(iframe);
    iframe = <span class="literal">null</span>;
    alert(<span class="built_in">window</span>.iOSPhoneName);
});
</code></pre><p>发送这个request让Native进行拦截，协议名可以随便取，当然这个名字要取的有意义。</p>
<p><a href="https://github.com/lcepy/geekObjective-C/tree/master/WebViewNativeToJavaScript" target="_blank" rel="external">例子查看</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在做混合应用时，H5与Native通信的重要性，我想每一个H5开发者都非常的清楚。通过它，我们可以很好的借用Native API的优势来实现自己想做的事情，业界有一个非常成熟的框架让大家选择，它就是PhoneGap。混合开发，并不是意味着什么App都可以做，它也有局限性。在]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015年面试之囧途]]></title>
    <link href="http://icepy.github.io/2015/03/13/2015%E5%B9%B4%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%9B%A7%E9%80%94/"/>
    <id>http://icepy.github.io/2015/03/13/2015年面试之囧途/</id>
    <published>2015-03-13T11:07:52.000Z</published>
    <updated>2015-03-28T06:41:31.000Z</updated>
    <content type="html"><![CDATA[<p>至去年从携程离职之后，就开启了一次新的面试囧途，面试这东西，主要可以了解自己所处的水平，写写它是想告诉自己一些事情，有事，人应该要了解和想清楚自己到底需要什么，到底适合什么样的工作，而不是为了生活，为了好的公司，为了高的薪水去妥协，在与兴趣之间平衡的坍塌，会造成很严重的后果，诱惑，是每一个人都会遇到的，如何面对这些诱惑，而明确自己所想，才是最重要的。</p>
<p>2015年面试了大概有七家公司，为什么会出现这样的状况，是我今天想要反思的主要目的。在去面试极客学院时，包括电话几轮的沟通，双方都非常满意，给出了17K的offer。其实这，是一个很心动的数字，毕竟比上一份work多出了3K。有时候，选择，往往很意外。</p>
<p>我是一个非常直接的人，我很忍受不了忽悠和欺骗。明明在面试时，就已经沟通过，我能做什么，以及我根本不考虑做什么，为什么入职之后往往的工作就要偏离呢？这个问题，其实我一直很思考不明白，最后的结局是我只能离职走人，浪费了时间，精力，当然还有金钱。</p>
<p>下面要写的事情，都非常琐碎，两周的时间内发生的事情。在过年之前，我来到北京，寻找机会，老乡给我推荐了聚美优品，面试时的一些沟通，包括自己的情况，想法，以及能做的事情，都很明白的说了。从1月4号面试到了1月14号，经历了四轮，然后就没有消息了。</p>
<p>大家都明白没有消息意味着什么，抱着挂了的心态，1月20号回到湖南。在和淳敏沟通了之后，我答应了在27号之前，去上海他那边工作。过完年后买了高铁票，去了上海，可是下午北京聚美优品又通知我，审批过了，如果我来北京，立马就发聚美的offer。其实，这里我就犯了一个很严重的错误，<strong>没有能抵制住诱惑</strong>。当天，我纠结郁闷了很久，淳敏也和我说了很多，包括聚美的工作气氛，研发团队，以及未来可以学习的东西到底有多少。也许当时我被这样的惊喜冲昏了头脑，一发热，连夜买了去北京的火车票，当我坐上火车时，我又接到了通知，还需要在继续面试。</p>
<p>当时在心里，真是一万只草泥马奔腾而过，这不是逗我玩么？如果，能让时光倒流，告诉我是来北京面试的话，我想大家应该都可以知道，自己会选择什么。用一句现在的话说，会来的是<strong>傻逼</strong>，于是我傻逼了。可是，时间没法回滚，发生了就要自己面对这些。其实当时的心里状态是很后悔的，后悔没听淳敏的话，后悔跑来北京。如果这边的工作黄了，接下来怎么办。自己没有任何想法，那只能继续面试，继续找工作了。</p>
<p>3月2日上午去了JD，我只能说我的简历写的很清楚。如果你需要正规军，就不应该来找我。JD的男HR真的是屌的一逼。下午去了一家创业公司，我大呼伤不起，各种奇葩要求。比如你能不能做服务，对不起，我不能。那你能不能写移动客户端，对不起，我不能。我简历写的是，移动前端好吧？未必，汉字这么难理解？那一天，我对后面的面试安排，已经不抱任何想去的态度了，但是朋友推荐的，还是去了。</p>
<p>3月3日下午的时候接到了聚美HR的电话，通知我她们人事搞错对象了，把别人的结果拿去审批了，而我是不需要面试了，在跟我确定了一下薪水之后，语重的告诉我，不过还是需要审批。如果老板审批不通过，她也没有办法，只能和我说声对不起。当时，我心里只是呵呵的，反正是有了不信任感。</p>
<p>3月4日去联想研究院面试，结果很理想，包括聊了很多关于移动H5的一些开发心得，中午面试的大哥还请我吃了一顿午饭，反正是心情很愉悦，唯一可惜的是联想研究院的HC计划需要等待到3月底，当时面试大哥的领导就询问我，是否愿意等待，告诉我如果公司的HC一开，优先联系我，只要我愿意。</p>
<p>吃过午饭的时候接到了聚美HR的电话，告诉我审批通过了，让我耐性等待offer。下午时聚美的offer发到了我的邮箱里，通知我3月10号入职。但是我没注意查收邮箱，其实，这也很狗血，我在想着，唉，工作哪里不是做，只要自己踏踏实实，本本份份的做好工作，管他呢。</p>
<p>3月5日去每日优鲜面试，本来经历了2号奇葩的面试之后，后面的一些网投的面试邀请，我都不打算去了。那天，接到个超美小姑娘的电话，而且还是个性感HR负责人，啧啧，来吧来吧，过来聊一聊。抱着想调戏调戏HR妹纸的心态，下午4点半搭地铁去望京那边，最后愣没找到地方。我在想，反正也就是聊会天，心中不快跟陌生人吐一吐，也许能减轻心理的压抑感。去了之后，跟技术，跟其他人聊的还挺愉快。反正HR的美色，没有让我失望，我在感谢老天，终于遇上了一家正常的公司。</p>
<p>第二天上午又跑去了每日优鲜，跟她们的CEO大哥聊聊，挺对味的。只是我还答应了朋友要去面试，所以没有急着答应他。当天下午还去百度面试了，上来做了三个题目，解析URL，实现深浅拷贝，对数字字符串进行以每四个一组的分隔。只是后面问到的一些问题，比如盒子模型，我知道它是由高宽内边距外边距线组成的，可是它在浏览器中的渲染顺序，我是真心不知道，这些问题有些变态了。后来，我朋友帮我去问，他告诉我百度对毕业证有要求，必须要统招，虽然面试了一个下午，但是没有然后了。于是，我能想到是什么。</p>
<p>最后我还是没有能抵制住”好公司”的诱惑，选择了去聚美优品，本来我朋友说，你别去聚美，你看看你面试的那个经历，太不靠谱了，让人感觉就像是把你吊着，他们一直在找人，只不过没找到合适的，最后才选择你。至于，是不是这样，我不清楚，但是从面试到发offer，确实让我有不信任的感受。</p>
<p>说起来，人嘛，都有头脑发热的时候，也很难抵制的了诱惑。没有办法，选择去了，那只能继续往前走，不然还能怎么办？入职聚美之后，第二天Leader告诉我还需要签署一份补充的协议，虽然我去签了，但是我发现一同来的那几个人都没签补充协议，就我一个人签了，为什么？这是有甄别的对待么？如果试用期的一些考核，不通过，立马开掉，那就呵呵了。我朋友说，我真蠢，这种开人协议也签，我也只能呵呵了。而我的试用期两项任务，都是切图，写CSS和静态页面。</p>
<p>确实，在我提交离职申请的时候，Leader跟我说，我是第一个签了这种补充协议的人。本来工作，就应当是有一个安心的氛围，我是没法安心。这对我来说有风险的，任何一个平常的人，都会这么想。如果一切都是看表现，安排一个没有切过图，没写过CSS的人去做这些事情，这可以看出他的表现吗？我想不能。而且，最重要的是，在和Leader沟通毕业证的时候，他要我自己去和HR协商，这让我更加的产生了危机感。如果6月不能顺利转正，是否意味着我还要接着找工作，然后又是三个月的试用期，到那个时候就已经10月，11月了，这一年又废了。这样的情况，如何能让人安心工作，我想，任何一个人都不能。</p>
<p>今天我办了离职手续，跟聚美负责技术的总监，Leader最后沟通了一下。也许在你们看来，这是一个很不负责的表现。如果换位思考一下，从面试到发offer，入职到第一个签到这种补充协议，如何能让感觉到是被信任的，是能安心工作的。其实很反感Leader最后说的一句话，有些威胁的味道，至于他想表述的本意是不是这样，我不清楚，但是让我感觉到威胁的味道是实在的。他说：<strong>互联网圈子这么小，基本上每个公司的技术人员我都认识。你能来聚美，我找携程的同事打听过你的事情，正因为你比较实在，所以才招你来。就你这样的，如果有人问起来，你觉得我该怎么说？只怕会影响你今后的发展。</strong></p>
<p>在坐地铁回来的路上，我自己又想了很多。一开始，从上海跑来北京，就是一个错误的选择。我没有听淳敏的建议，一腔热血的往前冲，后来我发现我冲到坑里了。这样的原因是什么？</p>
<ul>
<li>没有了解好自己真正的需求，擅长什么，对什么有兴趣</li>
<li>没有想好自己可以真正发展的城市，北京上海来回跑，什么意义都没有</li>
<li>内心不够强大，不能抵挡诱惑，比如有名的公司，较高的薪水</li>
<li>没有坚定自己发展的方向，PC移动都有前端，我没选择好方向</li>
<li>没有想好自己是否可以独自上路</li>
<li>没有选择好正确的公司</li>
</ul>
<p>以后我该怎么办？经历了这些之后，我才明白了一个道理，在做一项决定的时候，一定要考虑清楚了自己是否合适，这是不是我想要的。挫折，每个人都要面对，唯一不同的是，我如何从挫折中吸取教训，总结教训，未来能正确的行在路上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>至去年从携程离职之后，就开启了一次新的面试囧途，面试这东西，主要可以了解自己所处的水平，写写它是想告诉自己一些事情，有事，人应该要了解和想清楚自己到底需要什么，到底适合什么样的工作，而不是为了生活，为了好的公司，为了高的薪水去妥协，在与兴趣之间平衡的坍塌，会造成很严重的后果]]>
    </summary>
    
      <category term="生活" scheme="http://icepy.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多线程GCD的使用]]></title>
    <link href="http://icepy.github.io/2015/03/07/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://icepy.github.io/2015/03/07/iOS多线程GCD的使用/</id>
    <published>2015-03-07T09:07:36.000Z</published>
    <updated>2015-03-08T04:43:57.000Z</updated>
    <content type="html"><![CDATA[<p>在做iOS开发的时候线程的使用场景还是蛮多的，比如网络请求，比如大的数据处理等等。因为iOS只有一个主线程，而且这个主线程是让UIKit来使用的，如果我们不想让UI界面因为某些操作而出现卡顿，那么就必须把一些需要时间等待的操作，分配给其他的线程去处理，并且保证主线程不让UIKit之外的程序来使用。</p>
<p>在UIKit中某些对象是可以在其他线程中正常工作的，比如UIImage，UIColor等。但是UIKit的大部分只能在主线程中正常工作的，明白这一点非常的重要。</p>
<p>iOS中实现多任务编程，主要使用三种方式，1、NSThread 2、NSOperation 3、GCD；个人感觉GCD比较好使用，它主要是与block来配合使用的。比如在网络活动时，我想在<a href="http://wow.163.com" target="_blank" rel="external">http://wow.163.com</a>下载一张图片显示在UIImageView，但是下载的过程，如果不使用其他线程来下载图片数据，UI界面就会出现卡顿的感觉，用户体验非常不好。</p>
<p>GCD主要可以使用的函数有几个：</p>
<ul>
<li>dispatch_queue_create(“name”,NULL) </li>
<li>dispatch_async(dispatch_queue_t queue,^{})</li>
<li>dispatch_get_main_queue</li>
<li>dispatch_sync</li>
<li>dispatch_get_global_queue</li>
</ul>
<p>dispatch_get_main_queue顾名思义，运行在主线程的Main queue，可以通过dispatch_get_main_queue获取。</p>
<p>dispatch_async用于异步操作</p>
<p>dispatch_sync用于同步操作</p>
<p>dispatch_queue_create一般用来创建串行queue，而且只可能创建一个线程，顺序执行</p>
<p>dispatch_get_global_queue 添加到主queue的可能会并行执行，也就意味着创建了多个线程</p>
<p>回到例子上来说，如果我有两个界面，从其中一个界面点击一个按钮到另外一个界面中显示一张图片，而这个图片需要在网络上下载。如果这里不使用多线程，在视觉上得到的反馈，就有可能在第一个界面中出现卡顿，因为网络下载把主线程阻塞了。</p>
<p>例子：</p>
<pre><code>    <span class="comment">//创建一个请求</span>
    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:<span class="keyword">self</span><span class="variable">.imageURL</span>];
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(<span class="built_in">NSURL</span> *location, NSURLResponse *response, <span class="built_in">NSError</span> *error) {
        <span class="keyword">if</span> (!error) {
            <span class="keyword">if</span> ([request<span class="variable">.URL</span> isEqual:<span class="keyword">self</span><span class="variable">.imageURL</span>]) {
                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:[NSData dataWithContentsOfURL:location]];
                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
                    <span class="keyword">self</span><span class="variable">.image</span> = image;
                });
            }
        }
    }];
    [task resume];    
</code></pre><p>在这个例子中主要是利用了NSURLSession临时会话，NSURLSessionDownloadTask任务，NSURLSessionConfiguration配置与dispatch_async相结合的方式来处理的多线程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在做iOS开发的时候线程的使用场景还是蛮多的，比如网络请求，比如大的数据处理等等。因为iOS只有一个主线程，而且这个主线程是让UIKit来使用的，如果我们不想让UI界面因为某些操作而出现卡顿，那么就必须把一些需要时间等待的操作，分配给其他的线程去处理，并且保证主线程不让UI]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS自动布局的理解]]></title>
    <link href="http://icepy.github.io/2015/03/07/iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://icepy.github.io/2015/03/07/iOS自动布局的理解/</id>
    <published>2015-03-07T03:47:44.000Z</published>
    <updated>2015-03-20T11:55:23.000Z</updated>
    <content type="html"><![CDATA[<p>一般情况下iOS的自动布局可以在Xcode中利用图形化的工具来操作完成，当然也可以使用代码的方式来完成，这些工作主要是对视图定义一些规则和约束，在容器变化的时候，视图可以遵守这些约束。</p>
<p>实现约束的三种方式：</p>
<ul>
<li>比如拖动一个Label在storyboard中，会出现蓝色的辅助线，放定好位置时，在下方的小按钮中点击Reset to Suggested Constraints，系统会帮助我们选择最佳的自动布局方式</li>
<li>拖动一个Label到storyboard中，依然是点击下方小按钮，有add，手动添加。</li>
<li>拖动一个Label到storyboard中按住control键，拖动到想放的位置上，这里有一个前提，是有一个参照视图，放开的时候会弹出一个小框来让你选择约束</li>
</ul>
<p>比如要查看效果，可以右边的属性栏中选择Orientation中的Landscape，就变成了横屏。如果想删除约束，可以在左侧的文档大纲中进行删除，假设一个视图没有约束，也可以在文档大纲中来add约束。</p>
<p>如果想要查看一个约束，可以在Show the size inspector中查看constraints。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般情况下iOS的自动布局可以在Xcode中利用图形化的工具来操作完成，当然也可以使用代码的方式来完成，这些工作主要是对视图定义一些规则和约束，在容器变化的时候，视图可以遵守这些约束。</p>
<p>实现约束的三种方式：</p>
<ul>
<li>比如拖动一个Label在s]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript解析URL字符串]]></title>
    <link href="http://icepy.github.io/2015/03/06/JavaScript%E8%A7%A3%E6%9E%90URL%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://icepy.github.io/2015/03/06/JavaScript解析URL字符串/</id>
    <published>2015-03-06T06:38:32.000Z</published>
    <updated>2015-03-06T06:56:33.000Z</updated>
    <content type="html"><![CDATA[<p>说到解析URL思路应该有多种多样的，比如一点一点的分解，先indexOf(‘?’)判断是否有参数，完了之后split(‘?’)一下，后面的参数继续split(‘&amp;’)成一个数组然后循环再split(‘=’)组装成一个一个key和vaule的键值对对象。前面那一部分也可以继续分解，把端口，协议，路径等等分解出来。或者用正则表达式，一个一个的分解。除了上述的思路，其实还有一个更简单的办法，利用a标签。</p>
<pre><code><span class="keyword">var</span> parseURL = function(url){
    <span class="keyword">var</span> temp =  document.createElement('a');
    temp.href = url;
    <span class="keyword">var</span> <span class="literal">result</span> = {
        <span class="string">"port"</span>:temp.port,
        <span class="string">"protocol"</span>:temp.protocol.replace(':',''),
        <span class="string">"hash"</span>:temp.hash.replace('<span class="comment">#',''),</span>
        <span class="string">"host"</span>:temp.host,
        <span class="string">"href"</span>:temp.href,
        <span class="string">"hostname"</span>:temp.hostname,
        <span class="string">"pathname"</span>:temp.pathname,
        <span class="string">"search"</span>:temp.search,
        <span class="string">"query"</span>:{}
    }
    <span class="keyword">var</span> seg = <span class="literal">result</span>.search.replace(/^\?/,'').split('&amp;'),
        leng = seg.length,
        i = <span class="number">0</span>,
        target;
    <span class="keyword">for</span>(;i&lt;leng;i++){
        <span class="keyword">if</span>(!seg[i])<span class="keyword">continue</span>;
        target = seg[i].split('=');
        <span class="literal">result</span>.query[target[<span class="number">0</span>]] = target[<span class="number">1</span>];
    }
    temp = null;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
<span class="keyword">var</span> url = 'https://github.com:<span class="number">8989</span>?key=value&amp;hub=<span class="number">123</span>ASFDGGR<span class="comment">#github';</span>
parseURL(url);
</code></pre><p>最后使用完了，把对象的引用设置为null，等待内存回收。</p>
<p>说到URL就不得不提一下编码和解码的函数，Js里提供了三组，其中最常用的一组是encodeURIComponent和decodeURIComponent。</p>
<p>通过对三个函数的分析，我们可以知道：escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到解析URL思路应该有多种多样的，比如一点一点的分解，先indexOf(‘?’)判断是否有参数，完了之后split(‘?’)一下，后面的参数继续split(‘&amp;’)成一个数组然后循环再split(‘=’)组装成一个一个key和vaule的键值对对象。前面那一部分也]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript中的深拷贝与浅拷贝]]></title>
    <link href="http://icepy.github.io/2015/03/04/JavaScript%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://icepy.github.io/2015/03/04/JavaScript中的深拷贝与浅拷贝/</id>
    <published>2015-03-04T12:56:49.000Z</published>
    <updated>2015-03-05T03:27:31.000Z</updated>
    <content type="html"><![CDATA[<p>关于拷贝的问题，主要分为深拷贝和浅拷贝，但是如果从空间分配上来说JavaScript的拷贝不应该算是深拷贝，比如：</p>
<pre><code><span class="keyword">var</span> d = {};
<span class="keyword">for</span>(k <span class="keyword">in</span> a){
    d[k] = a[k];
}
<span class="keyword">return</span> d;
</code></pre><p>今天突然想到了这么一个问题，在C语言中，所谓的拷贝，就是分两种情况，一种是把指针地址拷贝给另外一个变量，虽然也开辟的了一个内存空间，在栈上也存在着一个地址，我对这个变量进行修改，同一个指针是会改变其值的，这种拷贝叫浅拷贝。另外一种情况，直接开辟一个新空间，把需要复制的值都复制在这个新的空间中，这种拷贝叫中深拷贝。</p>
<p>如果看到上述的一段Js代码，很多人说它是浅拷贝，假设传入一个a对象，拷贝完成之后返回一个d，当我修改返回对象的值时并不能同时修改a对象，于是，在这里我有一个很大的疑问，在Js中到底什么是浅拷贝，什么是深拷贝的问题？</p>
<p>这一点上感觉Js真的很奇葩，如果在开发iOS中，不可变对象copy一下，依然是不可变，所以是浅拷贝，拷贝了指针变量中存储的地址值。如果是可变对象copy一下，到不可变，空间变化了，包括不可变mutableCopy到不可变，空间依然变化了，所以是深拷贝。但是JavaScript中对于这一点要考虑一种情况，值类型，和引用类型，这个基础知识，我相信大家都非常清楚。数字，字符串等都是值类型，object，array等都是引用类型。</p>
<pre><code><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="keyword">var</span> b = a;

b.push(<span class="number">4</span>);
<span class="built_in">console</span>.log(a); <span class="comment">//[1,2,3,4]</span>

<span class="keyword">var</span> numb = <span class="number">123</span>;
<span class="keyword">var</span> _numb = numb;
_numb = <span class="number">567</span>;

<span class="built_in">console</span>.log(numb); <span class="comment">//123</span>
</code></pre><p>从这个例子中可以看的出来，它们使用的都是＝符号，而数组a发生了变化，numb数字却没有发生变化。那么从这里，可以有一个总结，所谓了深拷贝，浅拷贝的问题，应该针对的是有多个嵌套发生的情况。不然假设是这样的情况，还能叫浅拷贝么？</p>
<pre><code><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> = </span>{<span class="string">"de"</span>:<span class="number">123</span>};
<span class="keyword">var</span> o = copy(<span class="keyword">object</span>);

o.de = <span class="number">456</span>;

console.log(<span class="keyword">object</span>) <span class="comment">//{"de":123}</span>
</code></pre><p>明显对象o中的de属性修改并没有影响到原始对象，一个对象中的属性是一个字符串，如果从内存空间的角度上来说，这里明显是开辟了新的空间，还能说是浅拷贝么？那么针对另外一种情况。</p>
<pre><code><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> = </span>{
    <span class="string">"de"</span>:{
        <span class="string">"d"</span>:<span class="number">123</span>
    }
}

<span class="keyword">var</span> o = deepCopy(<span class="keyword">object</span>);
o.de.d = <span class="string">"asd"</span>;
</code></pre><p>如果一个对象中的第一层属性，不是值类型，只单层循环，这样来看的话确实是一个浅拷贝，因为在Js中引用类型用＝赋值，实际上是引用，这样说的通。所以，深拷贝，还需要做一些处理，把object，array等引用类型识别出来，深层递归到最后一层，一个一个的拷贝。</p>
<pre><code><span class="keyword">var</span> deepCopy = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span>{
    <span class="keyword">var</span> target = {};
    <span class="keyword">if</span>(<span class="keyword">typeof</span> o !== <span class="string">'object'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(o)){
        <span class="keyword">return</span> o;
    }
    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o){
        target[k] = deepCopy(o[k]);
    }
    <span class="keyword">return</span> target;
}
</code></pre><p>思路是如此，这个例子只考虑了两种情况，对象和数组，为了验证这样的思路，最后的结果与预期是一样的。</p>
<pre><code><span class="keyword">var</span> _copy = {
    <span class="string">'object'</span>:{
        <span class="string">'name'</span>:<span class="string">'wen'</span>
    },
    <span class="string">'array'</span>:[<span class="number">1</span>,<span class="number">2</span>]

}
<span class="keyword">var</span> h = deepCopy(_copy);
h.object.name = <span class="string">'lcepy'</span>;
h.array[<span class="number">1</span>] = <span class="number">8</span>;
<span class="built_in">console</span>.log(h);
<span class="built_in">console</span>.log(_copy);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>关于拷贝的问题，主要分为深拷贝和浅拷贝，但是如果从空间分配上来说JavaScript的拷贝不应该算是深拷贝，比如：</p>
<pre><code><span class="keyword">var</span> d = {};
<span class="keyword">f]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有趣味的iOS动画实现]]></title>
    <link href="http://icepy.github.io/2015/03/03/%E6%9C%89%E8%B6%A3%E5%91%B3%E7%9A%84iOS%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://icepy.github.io/2015/03/03/有趣味的iOS动画实现/</id>
    <published>2015-03-03T01:40:21.000Z</published>
    <updated>2015-03-04T12:37:16.000Z</updated>
    <content type="html"><![CDATA[<p>在做iOS应用时，真的为它提供的动画框架感到折服，理解简单，而且可以有多种选择，既可以从底层开始描绘动画，也可以使用高级API，甚至apple还提供了模拟物理世界的动画与交互系统，强大牛逼的一塌糊涂。</p>
<p>想要学习这些动画，需要具备一个点，理解iOS中的坐标系统，也就是几个属性。</p>
<pre><code>dropview.frame;
dropview.<span class="keyword">center</span>;
dropview.bounds;
dropview.transform
</code></pre><p>动画，是顾名思义的，在平面或者多维度的移动，frame中记录了当前视图相对于父视图左上角顶点的左边，而center则是中心原点，transform则代表了比如旋转等等矩阵的改变属性。</p>
<p>最简单的动画，就是操作这些属性，改变其值，使用的是UIView的类方法，比如：</p>
<pre><code>[UIView animateWithDuration:<span class="number">1.0</span> animations:^{

} completion:^(BOOL finished) {

}]
</code></pre><p>其实我最近研究了一下UIDynamicAnimator，它提供了一个模拟真实物理世界的动画与交互系统，比如可以定义一些行为，重力行为，碰撞行为等等。</p>
<pre><code>-(<span class="constant">UIDynamicAnimator</span> *)animator
{
    <span class="keyword">if</span> (!_animator) {
        _animator = [[<span class="constant">UIDynamicAnimator</span> alloc] <span class="symbol">initWithReferenceView:</span><span class="keyword">self</span>.gameview];
    }
    <span class="keyword">return</span> _animator;
}
</code></pre><p>UIDynamicAnimator需要一个通用的视图，而动画则是在这个视图上发生，所以init的时候添加了一个通用视图上去。然后可以去实现其他的物理类，比如重力，把它add到UIDynamicAnimator中。</p>
<pre><code>-(<span class="type">UIGravityBehavior</span> *)gravit
{
    <span class="keyword">if</span> (!_gravit) {
        _gravit = [[<span class="type">UIGravityBehavior</span> alloc] <span class="keyword">init</span>];
        _gravit.magnitude = <span class="number">0.9</span>;
        [<span class="keyword">self</span>.animator addBehavior:_gravit];
    }
    <span class="keyword">return</span> _gravit;
}
</code></pre><p>最后一步是要把需要被实现物理动画的视图，添加到重力系统中去。</p>
<pre><code><span class="title">[self.gravit addItem:dropview]</span><span class="comment">;</span>
</code></pre><p>从技术实现的角度上来说，iOS平台实现这些动画，包括绘制，物理交互，都非常的简单，主要是要注意一些细节的处理，比如当前动画停止之后处理什么，在动画执行过程中，可能会出现一些情况，然后处理，或者是几个动画的连接延迟等等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在做iOS应用时，真的为它提供的动画框架感到折服，理解简单，而且可以有多种选择，既可以从底层开始描绘动画，也可以使用高级API，甚至apple还提供了模拟物理世界的动画与交互系统，强大牛逼的一塌糊涂。</p>
<p>想要学习这些动画，需要具备一个点，理解iOS中的坐标系统，]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[向文文的简历]]></title>
    <link href="http://icepy.github.io/2015/03/01/myresume/"/>
    <id>http://icepy.github.io/2015/03/01/myresume/</id>
    <published>2015-03-01T15:35:20.000Z</published>
    <updated>2015-03-23T07:17:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="个人信息：">个人信息：</h2>
<p>向文文 xiangwenwe@foxmail.com / (+86) 18574532867 </p>
<p>技术博客 <a href="http://lcepy.github.io/" target="_blank" rel="external">http://lcepy.github.io/</a></p>
<p>Github <a href="https://github.com/lcepy" target="_blank" rel="external">https://github.com/lcepy</a></p>
<p>中南林业科技大学/大专</p>
<p>Skill set：JavaScript NodeJs iOS Python</p>
<h2 id="工作经验：">工作经验：</h2>
<p><em>上海携程旅行网   软件开发工程师</em></p>
<p>任职时间：2014年2月12日-12月31日</p>
<p>工作职责：负责H5，Hybrid App的开发工作</p>
<p>App下载，可以在各大app市场下载，apple需要在appstore中下载</p>
<p>项目网站：<a href="http://m.ctrip.com/webapp/cruise/index.html#index" target="_blank" rel="external">http://m.ctrip.com/webapp/cruise/index.html#index</a></p>
<p><em>远光软件股份有限公司    SMB软件部任职开发工程师</em></p>
<p>任职时间：2012年5月-2013年8月</p>
<p>工作职责：在部门中所担负的角色，主要在基于web的企业级应用开发与平台框架，并培训部门内部开发人员的前端开发技术，并提供解决方案供部门领导参考。</p>
<p>公司网站：<a href="http://www.ygsoft.com/Home/" target="_blank" rel="external">http://www.ygsoft.com/Home/</a></p>
<p><em>湖南华声在线有限公司    UI组任职前端工程师</em></p>
<p>任职时间：2011年8月-2012年4月</p>
<p>工作职责：负责教育产品，社交空间的前端开发，培训组内的前端技术，并提供教育系列产品的前端解决方案，并负责一定的服务端开发工作，主要是基于php技术。</p>
<p>公司网站：<a href="http://www.voc.com.cn/" target="_blank" rel="external">http://www.voc.com.cn/</a> </p>
<h2 id="项目经验：(提供最近一年内的项目)">项目经验：(提供最近一年内的项目)</h2>
<h3 id="携程（公司）">携程（公司）</h3>
<h5 id="2014年11月20日到2014年12月31日_H5_Hybrid_6-1（邮轮）">2014年11月20日到2014年12月31日 H5 Hybrid 6.1（邮轮）</h5>
<p>主要负责详情页板块的改造，新增我的收藏，用户浏览历史，降价提醒功能。降价提醒这个功能很棒，让我用户可以提出他们的需求，以及有一个邮轮费用的计算器让用户使用。</p>
<h5 id="2014年10月15日到2014年11月18日_H5_Hybrid_6-0（邮轮）">2014年10月15日到2014年11月18日 H5 Hybrid 6.0（邮轮）</h5>
<p>主要负责邮轮产品详情页，邮轮岸上游详情页，修复H5跳Hybrid，增加在搜索页定位图标，增加常见问题页FAQ。迁移首页，列表，搜索页三个页面到新版2.1框架，支持首页，列表页的SEO</p>
<h5 id="2014年9月15日到2014年10月9日_H5_Hybrid_5-10（邮轮）">2014年9月15日到2014年10月9日 H5 Hybrid 5.10（邮轮）</h5>
<p>主要负责把搜索与筛选的业务逻辑全部修改为联调机制，并且在搜索中，增加途径国家，增加多级的搜索，列表页需要支持URL参数并且支持SEO，修改首页的地理位置定位与默认参数的逻辑，制作一个新的营销CR页面。</p>
<p><em>让用户从之前的单个搜索，筛选，变更为在同一个view中进行搜索与筛选，不切换view在体检上就不会感觉到很麻烦。</em></p>
<h5 id="2014年8月9日到9月11日_H5_Hybrid_5-9（邮轮）">2014年8月9日到9月11日 H5 Hybrid 5.9（邮轮）</h5>
<p>主要负责重构邮轮首页，列表页，搜索页以及筛选的业务逻辑，中间修改了广告营销，预定咨询页，修复5.8bug以及新增需求。</p>
<p><em>帮助同事进行源代码重构，分享一些过往的开发经验。</em></p>
<h5 id="2014年7月7日到2014年8月5日_H5_Hybrid_5-8（邮轮）">2014年7月7日到2014年8月5日 H5 Hybrid 5.8（邮轮）</h5>
<p>主要是新接手同事的列表，搜索排序，筛选排序，新做了订单意向单，邮轮详情页中的行程介绍，岸上游详情介绍，修复5.7bug以及新增需求。</p>
<h5 id="2014年5月21日到2014年6月27日_H5_Hybrid_5-7（邮轮）">2014年5月21日到2014年6月27日 H5 Hybrid 5.7（邮轮）</h5>
<p>主要是负责邮轮的整个订单部分，分为订单第一步，选择班期。订单第二步，选择房型。订单第三步，填写常用联系人，并核算消费明细等。配套的有，常用旅客的选择，编辑，新增，另外两项功能性选择，为保险多选选择，岸上游单选选择，并且提交支付。</p>
<p><em>中间的逻辑（不复述了）解决了携程邮轮在无线端下订单从无到有的开始。</em></p>
<h5 id="2014年4月25日到2014年5月19日_H5_Hybrid_5-6（邮轮）编写了两个工具">2014年4月25日到2014年5月19日 H5 Hybrid 5.6（邮轮）编写了两个工具</h5>
<p>主要是负责了第一版邮轮的订单意向单，预定须知，签证签出。</p>
<p>在当时的开发环境下为其他开发人员编写了两个工具，一个工具是HTTP代理服务器用来模拟数据（nodejs）这个已经提交在个人github中，项目名为glob-proxy，另外一个是给组长编写的excels导入工具（python）</p>
<p><em>解决了当时开发团队在开发方式上的困难，因为前后不同步的原因，需要经常在模型层中修改请求地址，或是在本地自己模拟假数据。这个工具的出现，则统一由代理服务器去切换请求地址或者在本地生成mock数据。另外一项任务，是帮助当时的开发经理从项目日志中，导出excels表。</em></p>
<h5 id="2014年3月10日到4月11日_门票_H5_Hybrid_5-5">2014年3月10日到4月11日 门票 H5 Hybrid 5.5</h5>
<p>当时主要是负责了门票详情页，预定须知，点评，地图交互，景点介绍。</p>
<h5 id="2014年2月12日到3月3日_机票_H5_Hybrid_5-5_编写了一个工具">2014年2月12日到3月3日  机票 H5 Hybrid 5.5  编写了一个工具</h5>
<p>当时主要是负责从用户订取机票的时间与航空公司的上下班时间中分析出一个合理的时间区间数组来。</p>
<p>打包工具主要是根据SOAP协议来调取webapp包地址，多线程下载完成之后重新打包。现工具已经在提交在个人github上，项目名为downloadZIP</p>
<p><em>关于时间区间的分析，根据航空公司上下班时间与用户自己期望的时间分析出一个合理的时间数组，让用户可以清晰的了解到取票的时间范围。</em></p>
<h2 id="经历表述：">经历表述：</h2>
<p><a href="http://lcepy.github.io/2014/11/14/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" target="_blank" rel="external">我的项目经历-详细版</a></p>
<p>在软件工程，前端领域已经工作近四年之久，对于编程的思考，解决问题的思路都已形成了自己比较独特的思维，语言只是解决问题的一个工具，最关键的还是在于人，如何去规划问题，思考问题，并解决问题。</p>
<p>我比较擅长JavaScript，近几年比较流行的Nodejs，HTML5 API CSS3也有一些自己总结的经验.三年多的工作经验集中在客户端技术，包括SPA MVC客户端，Hybrid app客户端，移动浏览器H5应用，有过一年左右的python网络编程，对请求，一些服务端，客户端框架，比如zepto underscore  django，应用在客户端，服务端上的MVC开发模式，HTML5 API都非常的了解和掌握。</p>
<p>平时，也掌握了基本的nodejs，主要是使用express来写博客等学习，如果需要，我相信自己能在很短的时间内掌握它。</p>
<p>目前个人开发iOS应用已经有一年左右的时间，对基础的c，Objective-C，xcode工具等都比较熟练的掌握了，</p>
<h2 id="致谢">致谢</h2>
<p>感谢您抽出宝贵的时间，阅读完我的简历，谢谢～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="个人信息：">个人信息：</h2>
<p>向文文 xiangwenwe@foxmail.com / (+86) 18574532867 </p>
<p>技术博客 <a href="http://lcepy.github.io/" target="_blank" r]]>
    </summary>
    
      <category term="简历" scheme="http://icepy.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIViewController的生命周期]]></title>
    <link href="http://icepy.github.io/2015/02/16/UIViewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://icepy.github.io/2015/02/16/UIViewController的生命周期/</id>
    <published>2015-02-16T13:54:06.000Z</published>
    <updated>2015-03-20T11:55:51.000Z</updated>
    <content type="html"><![CDATA[<p>关于生命周期的问题，主要是在某些情况上必须要使用它，以及一些一系列的管理。比如在视图准备呈现在屏幕之前，我可能要做某些事情。在视图准备消失在屏幕之前，需要做某些事情。当内存不足的时候，需要做某些事情等等。而UIViewController的生命周期，就是来负责这些问题的处理。</p>
<p><strong>呈现视图的顺序</strong></p>
<p>它内部的顺序是这样的，先走init方法，如果有自定义视图，则走自定义视图。如果没有，则走xib或storyborad，如果这个也没有则走loadView方法，loadView方法系统调用，也可以重载它。当我们重载它时，可以[super loadView] 父类帮助我们创建一个空的view，如果不调用父类，那么就要自己创建一个UIView，并且self.view = UIView。</p>
<p>如果在调用loadView时不调用父类，也不创建，如果使用self.view的getter method并且view等于nil，会发生自我循环调用。一般情况下，不要在初始化时做view相当的动作。在viewDiload中调用一些网络访问的动作，可以在初始化方法中做一些关于模型数据的准备工作。</p>
<p>如果覆盖了loadView，则必须创建UIViewController的view属性。如果没有覆盖该方法，UIViewController会默认调用initWithNibName方法来初始化并加载view。</p>
<p><strong>生命周期</strong></p>
<p>一般来说我们需要知道应用程序什么时候在屏幕上，什么时候从屏幕上消失，这个就是生命周期了。初始化的方法可以在viewDidLoad，这个方法在生命周期中只会调用一次，当然不要忘记了调用它的父类的viewDidLoad方法，[super viewDidLoad]。在调用这个方法时，实际上视图并没有在屏幕上确定下来，于是一般来说，如果视图的几何操作，不要放在这个方法中执行。</p>
<p>viewWillAppear，这个方法会被多次调用，一般来说一次性的初始化不要放在这个方法中实现，但是如果是基于模型的动态初始化，可以放置在这个方法中实现。这个方法会在视图即将要在屏幕上呈现之前调用。</p>
<p>当视图从屏幕上消失时，也会得到通知，viewWillDisappear方法。这个方法是在视图将要从屏幕消失之前调用。</p>
<p>viewDidAppear视图已经呈现在屏幕上调用 viewDidDisappear视图已经从屏幕上消失调用。</p>
<p>viewWillLayoutSubviews  viewDidLayoutSubviews 这两个方法可以在，比如从竖屏到横屏，系统会自动元素的位置，第一个方法是在移动之前调用，第二个方法是在移动完成之后调用，需要设置Autorotation属性。</p>
<p>didReceiveMemoryWarning 当内存不足时，系统会调用这个方法，发送警告。 </p>
<h2 id="顺序">顺序</h2>
<p>viewDidLoad -&gt; viewWillAppear -&gt; viewDidAppear -&gt; viewWillDisappear -&gt; viewDidDisappear</p>
<p>关于layout的顺序</p>
<p>viewWillLayoutSubviews -&gt; viewDidLayoutSubviews</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于生命周期的问题，主要是在某些情况上必须要使用它，以及一些一系列的管理。比如在视图准备呈现在屏幕之前，我可能要做某些事情。在视图准备消失在屏幕之前，需要做某些事情。当内存不足的时候，需要做某些事情等等。而UIViewController的生命周期，就是来负责这些问题的处理]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读部分zepto源代码]]></title>
    <link href="http://icepy.github.io/2015/02/15/%E9%98%85%E8%AF%BB%E9%83%A8%E5%88%86zepto%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://icepy.github.io/2015/02/15/阅读部分zepto源代码/</id>
    <published>2015-02-15T06:11:30.000Z</published>
    <updated>2015-03-27T16:49:41.000Z</updated>
    <content type="html"><![CDATA[<p>zepto初始化时，是$符号来获取元素对象，如果是空则会返回一个数组，从源代码上面来看，是这样的：</p>
<pre><code>$ = <span class="function"><span class="keyword">function</span><span class="params">(selector, context)</span></span>{
    <span class="keyword">return</span> zepto.init(selector, context)
  }
</code></pre><p>可以传入两个参数，一个selector，一个context，在这个函数内部会调用zepto.init方法。</p>
<pre><code>zepto.init = <span class="function"><span class="keyword">function</span><span class="params">(selector, context)</span> </span>{
<span class="keyword">var</span> dom
<span class="comment">// If nothing given, return an empty Zepto collection</span>
<span class="keyword">if</span> (!selector) <span class="keyword">return</span> zepto.Z()
<span class="comment">// Optimize for string selectors</span>
<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'string'</span>) {
  selector = selector.trim()
  <span class="comment">// If it's a html fragment, create nodes from it</span>
  <span class="comment">// Note: In both Chrome 21 and Firefox 15, DOM error 12</span>
  <span class="comment">// is thrown if the fragment doesn't begin with &lt;</span>
  <span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))
    dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span>
  <span class="comment">// If there's a context, create a collection on that context first, and select</span>
  <span class="comment">// nodes from there</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)
  <span class="comment">// If it's a CSS selector, use it to select nodes.</span>
  <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)
}
<span class="comment">// If a function is given, call it when the DOM is ready</span>
<span class="keyword">else</span> <span class="keyword">if</span> (isFunction(selector)) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(selector)
<span class="comment">// If a Zepto collection is given, just return it</span>
<span class="keyword">else</span> <span class="keyword">if</span> (zepto.isZ(selector)) <span class="keyword">return</span> selector
<span class="keyword">else</span> {
  <span class="comment">// normalize array if an array of nodes is given</span>
  <span class="keyword">if</span> (isArray(selector)) dom = compact(selector)
  <span class="comment">// Wrap DOM nodes.```</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))
    dom = [selector], selector = <span class="literal">null</span>
  <span class="comment">// If it's a html fragment, create nodes from it</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))
    dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span>
  <span class="comment">// If there's a context, create a collection on that context first, and select</span>
  <span class="comment">// nodes from there</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)
  <span class="comment">// And last but no least, if it's a CSS selector, use it to select nodes.</span>
  <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)
}
<span class="comment">// create a new Zepto collection from the nodes found</span>
<span class="keyword">return</span> zepto.Z(dom, selector)

  }

zepto.Z = <span class="function"><span class="keyword">function</span><span class="params">(dom, selector)</span> </span>{
    dom = dom || []
    dom.__proto__ = $.fn
    dom.selector = selector || <span class="string">''</span>
    <span class="keyword">return</span> dom
  }
</code></pre><p>如果什么都不传入，它在init内部会调用Z，并且返回一个空的数组，这个数组的原型会指向$.fn，$.fn是一个字面量的对象，全部是zepto的一些其他方法。</p>
<p>如果context有值，它会指定一个上下文，也就是范围$(context).find(selector)，如果context没有值，则会对selector的值进行检索，如果selector是一个标签字符串，则调用zepto.fragment方法来获取dom对象。如果selector不是标签字符串，则调用zepto.qsa方法，得到DOM对象，在qsa方法中会检查#，.也就是id和class，如果id有返回的是从getElementById中获取的dom对象，如果是class则调用数组的slice方法call一下比如querySelectorAll等，在获取dom对象时，就已经进行了装载，最后调用zepto.Z方法，返回这个数组。</p>
<pre><code>zepto.qsa = <span class="function"><span class="keyword">function</span><span class="params">(element, selector)</span></span>{
<span class="keyword">var</span> found,
    maybeID = selector[<span class="number">0</span>] == <span class="string">'#'</span>,
    maybeClass = !maybeID &amp;&amp; selector[<span class="number">0</span>] == <span class="string">'.'</span>,
    nameOnly = maybeID || maybeClass ? selector.slice(<span class="number">1</span>) : selector, <span class="comment">// Ensure that a 1 char tag name still gets checked</span>
    isSimple = simpleSelectorRE.test(nameOnly)
<span class="keyword">return</span> (isDocument(element) &amp;&amp; isSimple &amp;&amp; maybeID) ?
  ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :
  (element.nodeType !== <span class="number">1</span> &amp;&amp; element.nodeType !== <span class="number">9</span>) ? [] :
  slice.call(
    isSimple &amp;&amp; !maybeID ?
      maybeClass ? element.getElementsByClassName(nameOnly) : <span class="comment">// If it's simple, it could be a class</span>
      element.getElementsByTagName(selector) : <span class="comment">// Or a tag</span>
      element.querySelectorAll(selector) <span class="comment">// Or it's not simple, and we need to query all</span>
  )
  }

  zepto.fragment = <span class="function"><span class="keyword">function</span><span class="params">(html, name, properties)</span> </span>{
<span class="keyword">var</span> dom, nodes, container

<span class="comment">// A special case optimization for a single tag</span>
<span class="keyword">if</span> (singleTagRE.test(html)) dom = $(<span class="built_in">document</span>.createElement(<span class="built_in">RegExp</span>.$<span class="number">1</span>))

<span class="keyword">if</span> (!dom) {
  <span class="keyword">if</span> (html.replace) html = html.replace(tagExpanderRE, <span class="string">"&lt;$1&gt;&lt;/$2&gt;"</span>)
  <span class="keyword">if</span> (name === <span class="literal">undefined</span>) name = fragmentRE.test(html) &amp;&amp; <span class="built_in">RegExp</span>.$<span class="number">1</span>
  <span class="keyword">if</span> (!(name <span class="keyword">in</span> containers)) name = <span class="string">'*'</span>

  container = containers[name]
  container.innerHTML = <span class="string">''</span> + html
  dom = $.each(slice.call(container.childNodes), <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    container.removeChild(<span class="keyword">this</span>)
  })
}

<span class="keyword">if</span> (isPlainObject(properties)) {
  nodes = $(dom)
  $.each(properties, <span class="function"><span class="keyword">function</span><span class="params">(key, value)</span> </span>{
    <span class="keyword">if</span> (methodAttributes.indexOf(key) &gt; -<span class="number">1</span>) nodes[key](value)
    <span class="keyword">else</span> nodes.attr(key, value)
  })
}

<span class="keyword">return</span> dom
  }
</code></pre><p>其实这个数组，就是我们使用到的真正的东西了，在Z方法内部，主要就是两个动作，把dom的原型指向$.fn，把dom的selector属性指向selector，这样就可以使用到zepto中的其他可以使用的方法了。</p>
<p>而平时的开发中对于类型的判断是使用的很多的东西，我们可能需要对数据的类型进行检查，以满足预期的结果，而zepto中也提供了一揽子的解决方案，用于类型的判断，函数，字符串，对象，数组等。</p>
<pre><code>$.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>),    <span class="function"><span class="keyword">function</span><span class="params">(i, name)</span> </span>{
class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase()
  })
</code></pre><p>其实从这里就可以看的出来zepto使用的是什么方式来检索数据类型，借用的就是Object对象的toString方法把全类型字符串打印出来，然后再根据这些字符串来分别处理。在zepto的源代码中，它没有这么写，Object.prototype.toString.call(obj)，而是直接toString.call(obj)，这是因为这个toString是一个内置对象，作用域我想我们都明白，在客户端它是如何搜索的。</p>
<p>在得到了全类型的字符串后，可以去class2type的map中取出值来进行比对，来返回正确的类型。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">isObject</span><span class="params">(obj)</span>     </span>{ <span class="keyword">return</span> type(obj) == <span class="string">"object"</span> }
<span class="function"><span class="keyword">function</span> <span class="title">isFunction</span><span class="params">(value)</span> </span>{ <span class="keyword">return</span> type(value) == <span class="string">"function"</span> }
<span class="function"><span class="keyword">function</span> <span class="title">type</span><span class="params">(obj)</span> </span>{
<span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :
  class2type[toString.call(obj)] || <span class="string">"object"</span>
  }
</code></pre><p>数组zepto使用的最新的API，Array提供的isArray方法。</p>
<pre><code>isArray = <span class="built_in">Array</span>.isArray ||
  <span class="function"><span class="keyword">function</span><span class="params">(object)</span></span>{ <span class="keyword">return</span> object <span class="keyword">instanceof</span> <span class="built_in">Array</span> }
</code></pre><p>zepto还提供了检测document，window等。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span><span class="params">(obj)</span>     </span>{ <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj == obj.window }
  <span class="function"><span class="keyword">function</span> <span class="title">isDocument</span><span class="params">(obj)</span>   </span>{ <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE }
  <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span><span class="params">(obj)</span> </span>{
 <span class="comment">//getPrototypeOf 返回一个对象的原型 ，这里是不是跟Object.prototype相等</span>
 <span class="keyword">return</span> isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; <span class="built_in">Object</span>.getPrototypeOf(obj) == <span class="built_in">Object</span>.prototype
}
</code></pre><p>each顾名思义是用来遍历的</p>
<pre><code>$.each = <span class="function"><span class="keyword">function</span><span class="params">(elements, callback)</span></span>{
<span class="keyword">var</span> i, key
<span class="keyword">if</span> (likeArray(elements)) {
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)
    <span class="comment">//函数的默认返回值是undefined ，那么什么情况下会成 false  ?</span>
    <span class="keyword">if</span> (<span class="keyword">callback</span>.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements
} <span class="keyword">else</span> {
  <span class="keyword">for</span> (key <span class="keyword">in</span> elements)
    <span class="keyword">if</span> (<span class="keyword">callback</span>.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements
}

<span class="keyword">return</span> elements
  } 
</code></pre><p>唯一有个问题，看看有其他朋友知晓不，什么情况下callback.call会等于false？按道理来说，如果检查typeof callback === ‘function’，这样的情况，我认为可以理解。毕竟函数的默认返回值就是undefined，但是它也不是“强类型”相等的，所以我不明白它的意义何在？</p>
<p>在学习map函数之前，先学习几个比较有用的方法，比如判断一个对象是否是空对象，给字符串两边去空白等。判断空对象，主要是利用了in语法，它可以遍历对象的属性，如果是空对象for循环会直接跳过。</p>
<pre><code>$.isEmptyObject = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
    <span class="keyword">var</span> name
    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) <span class="keyword">return</span> <span class="literal">false</span>
    <span class="keyword">return</span> <span class="literal">true</span>
  }
</code></pre><p>判断一个元素是否在数组中，借用了在最上面申明的一个空数组的indexOf。</p>
<pre><code>$.inArray = <span class="function"><span class="keyword">function</span><span class="params">(elem, array, i)</span></span>{
    <span class="keyword">return</span> emptyArray.indexOf.call(array, elem, i)
  }
</code></pre><p>给字符串左右两边去空白，这个是借用了String包装对象的trim方法。</p>
<pre><code>$.trim = <span class="function"><span class="keyword">function</span><span class="params">(str)</span> </span>{
    <span class="keyword">return</span> str == <span class="literal">null</span> ? <span class="string">""</span> : <span class="built_in">String</span>.prototype.trim.call(str)
  }
</code></pre><p>map函数是一个很有意思很有用的函数，它可以帮助开发者进行映射到每一个元素上，新版的数组也提供了map方法，考虑到某些浏览器没有实现这个，所以zepto帮助我们实现了它。</p>
<pre><code>$.map = <span class="function"><span class="keyword">function</span>(<span class="title">elements</span>, <span class="title">callback</span>){</span>
var <span class="built_in">value</span>, values = [], i, key
<span class="keyword">if</span> (likeArray(elements))
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.<span class="built_in">length</span>; i++) {
    <span class="built_in">value</span> = callback(elements[i], i)
    <span class="keyword">if</span> (<span class="built_in">value</span> != <span class="constant">null</span>) values.push(<span class="built_in">value</span>)
  }
<span class="keyword">else</span>
      <span class="keyword">for</span> (key <span class="operator">in</span> elements) {
        <span class="built_in">value</span> = callback(elements[key], key)
        <span class="keyword">if</span> (<span class="built_in">value</span> != <span class="constant">null</span>) values.push(<span class="built_in">value</span>)
      }
    <span class="constant">return</span> flatten(values)
  }
</code></pre><p>likeArray是判断了下length属性是不是number，如果是，遍历，然后装载到values数组中，如果是对象就用for in，最后的flatten是借用一下concat，copy一个副本出来返回。</p>
<p>read函数，是在开发中非常有用的函数，主要是用来当DOM文档准备好之后，再加载或直接某些Js片段。就是怕，某些情况下，比如Js片段已经写好了，这里面要获取某个DOM节点，实际上这里会是null，然后执行其他操作就抛错误了，因为在浏览器中，这个节点还不存在。</p>
<pre><code><span class="comment">//读取readyState状态</span>
  <span class="keyword">if</span> (readyRE.test(<span class="built_in">document</span>.readyState) &amp;&amp; <span class="built_in">document</span>.body) callback($)
<span class="comment">//监听DOMContentLoaded事件</span>
  <span class="keyword">else</span> <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ callback($) }, <span class="literal">false</span>)
  <span class="keyword">return</span>  <span class="keyword">this</span>
</code></pre><p>zepto因为是移动端的开发，所以它监听的是DOMContentLoaded事件，这个事件是一个原生方法，新版API中提供了这个，而对IE10兼容，则是判断document的readyState属性，保证它是complete|loaded|interactive，这也意味着已经准备好了，并且还要判断body是否存在，才执行callback函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>zepto初始化时，是$符号来获取元素对象，如果是空则会返回一个数组，从源代码上面来看，是这样的：</p>
<pre><code>$ = <span class="function"><span class="keyword">function</span><span cl]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解UITableView]]></title>
    <link href="http://icepy.github.io/2015/02/06/%E7%90%86%E8%A7%A3UITableView/"/>
    <id>http://icepy.github.io/2015/02/06/理解UITableView/</id>
    <published>2015-02-06T13:06:07.000Z</published>
    <updated>2015-02-08T11:27:19.000Z</updated>
    <content type="html"><![CDATA[<p>UITableView是在iOS开发中使用非常频繁的一个控件，比如QQ的消息人列表，淘宝的商品，微信等等都会使用到它，对于它的理解有一个前提，那就是要理解iOS MVC的设计思路。</p>
<p>创建一个UITableView可以使用代码的方式，也可以使用xib或者storyboard。</p>
<pre><code><span class="built_in">UITableView</span> *tableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:[[UIScreen mainScreen] applicationFrame]];
</code></pre><p>在MVC的设计思想中控制器控制着要从模型中拿数据，然后把数据装载给视图。在UITableView中模型主要是实现在UITableViewDataSource数据源中，也就是UITableView有几行，分组么，然后每一行装载什么？数据源的目的就是想问开发者这些问题。</p>
<pre><code><span class="pp">-<span class="params">(<span class="variable">NSInteger</span>)</span>numberOfSectionsInTableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView
{

}</span>
</code></pre><p>这个方法如果存在有分组，系统就会询问，有几个分组？如果不是分组的，可以不实现这个方法，系统默认是1。</p>
<p>有了分组之后，然后系统会询问会有几行？</p>
<pre><code><span class="pp">-<span class="params">(<span class="variable">NSInteger</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView numberOfRowsInSection:<span class="params">(<span class="variable">NSInteger</span>)</span>section
{

}</span>
</code></pre><p>section跟分组有关</p>
<p>最后系统询问，每一行实现什么？</p>
<pre><code><span class="pp">-<span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath
{

}</span>
</code></pre><p>这个方法的实现可以说是核心的核心，在UITableView中每一行是要求实现一个cell，可以想象每一个cell相当于就是一个容器，这个容器里面装载着很多其他UI对象，当然cell也可以自定义。</p>
<p>考虑到性能，其实每一个cell可以从缓存中读取</p>
<pre><code><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];
<span class="keyword">if</span> (!cell) {
    cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:UITableViewStylePlain reuseIdentifier:<span class="string">@"cell"</span>];
}

<span class="comment">//do</span>
</code></pre><p>indexPath是一个类，看看头文件就可以明白，它这个里面装载着row，section等，这些数值非常有意义，在从模型里获取数据的时候。数据源还有一些其他的方法可以实现，比如编辑模式，这个东西一般用于删除每一条消息，从右向左滑动的时候。</p>
<pre><code><span class="pp">-<span class="params">(void)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView commitEditingStyle:<span class="params">(<span class="variable">UITableViewCellEditingStyle</span>)</span>editingStyle forRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath
{

}</span>
</code></pre><p>排序</p>
<pre><code><span class="pp">-<span class="params">(void)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView moveRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>sourceIndexPath toIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>destinationIndexPath
{

}</span>
</code></pre><p>有了数据源，当然也会存在一些代理，这些代理就是一些动作，比如实现了某些代理方法之后，系统会询问，你点了？一个手指按下不动了？等等，然后再doing什么，就是写在这些代理的方法中，主要是实现UITableViewDelegate。</p>
<p>常用的比如按下的时候，放开的时候：</p>
<p>点击了每一行时做的动作</p>
<pre><code><span class="pp">-<span class="params">(void)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView didSelectRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath
{

}</span>
</code></pre><p>放开每一行时做的动作</p>
<pre><code><span class="pp">-<span class="params">(void)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView didDeselectRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath
{

}</span>
</code></pre><p>协议中有很多在某些情况下会非常有用，细节就要慢慢在学习中积累了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>UITableView是在iOS开发中使用非常频繁的一个控件，比如QQ的消息人列表，淘宝的商品，微信等等都会使用到它，对于它的理解有一个前提，那就是要理解iOS MVC的设计思路。</p>
<p>创建一个UITableView可以使用代码的方式，也可以使用xib或者stor]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript十二之理解作用域]]></title>
    <link href="http://icepy.github.io/2015/02/05/%E5%A4%8D%E4%B9%A0JavaScript%E5%8D%81%E4%BA%8C%E4%B9%8B%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://icepy.github.io/2015/02/05/复习JavaScript十二之理解作用域/</id>
    <published>2015-02-05T10:17:09.000Z</published>
    <updated>2015-02-24T11:47:42.000Z</updated>
    <content type="html"><![CDATA[<p>理解作用域链是Js编程中一个必须要具备的，作用域决定了变量和函数有权力访问哪些数据。在Web浏览器中，全局执行环境是window对象，这也意味着所有的全局变量或者方法都是window对象的属性或方法。当个函数在被调用的时候都会创建自己的执行环境，而这个函数中所写的代码就开始进入这个函数的执行环境，于是由变量对象构建起了一个作用域链。</p>
<pre><code><span class="keyword">var</span> wow = <span class="string">'魔兽世界'</span>;
<span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> _wow = <span class="string">'123'</span>;
}
</code></pre><p>在这个例子中全局环境中包含了两个对象（全局环境的变量对象不算），window.wow和window.message，而这个message函数中又包含了两个对象，它自己的变量对象（其中定义了arguments对象）和全局环境的变量对象。当这个函数开始执行时，message自己的变量对象中定义了_wow，而它的全局环境的变量对象有wow，假设在message中alert一下wow，实际上是message中包含的全局环境的变量对象.wow，于是可以访问。</p>
<pre><code><span class="keyword">var</span> wow = <span class="string">'123'</span>;
<span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> wow = <span class="string">'456'</span>;
}
</code></pre><p>如果执行message函数alert一下wow，它的作用域是这样开始搜索的，先搜索message自己的变量对象中是否存在wow，如果有就访问并且立马停止搜索，如果没有则继续往上访问它，有wow，则访问并且立马停止搜索，以此类推一直搜索到全局环境上的变量对象，如果这里都没，恭喜你，这里要抛错了。</p>
<pre><code><span class="keyword">var</span> c = <span class="string">'123'</span>;
<span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> g = <span class="string">'123'</span>;
    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> d = <span class="string">'123'</span>;
    }
}
</code></pre><p>在这个例子中包含有三个执行环境，全局环境，message的环境，a的环境。从这里可以看出message自身包含两个对象，自己的变量对象和全局环境中的变量对象，而函数a则包含了三个，自身的变量对象，message的变量对象和全局变量对象。</p>
<p>当开始执行这函数时，在函数a中可以访问到变量g，那是因为函数a包含了message的变量对象，于是在自身没有开始搜索上一级的变量对象时发现了，于是可以访问。那么访问c的原理也是如此，当自身和上一级的message的变量对象都没有，但是全局变量对象中存在，于是访问成功。</p>
<p>了解这个作用域，对于Js编程是至关重要的，不然可能会出现，明明想要的预期结果是123，但是变成了456，为什么？那就是因为一级一级的搜索，可能会存在覆盖，或者搜索到别的地方就立即停止搜索了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>理解作用域链是Js编程中一个必须要具备的，作用域决定了变量和函数有权力访问哪些数据。在Web浏览器中，全局执行环境是window对象，这也意味着所有的全局变量或者方法都是window对象的属性或方法。当个函数在被调用的时候都会创建自己的执行环境，而这个函数中所写的代码就开始]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS的copy语法]]></title>
    <link href="http://icepy.github.io/2015/02/05/iOS%E7%9A%84copy%E8%AF%AD%E6%B3%95/"/>
    <id>http://icepy.github.io/2015/02/05/iOS的copy语法/</id>
    <published>2015-02-05T10:01:43.000Z</published>
    <updated>2015-03-20T11:55:35.000Z</updated>
    <content type="html"><![CDATA[<p>这是一个关于深拷贝和浅拷贝的问题，OC设计这个语法的目的就是创建一个副本，修改副本的时候不会改变原来的对象。</p>
<blockquote>
<p>对于这两个问题可以这么理解，浅拷贝也就是把指针赋值，大家用的都是地址。而深拷贝，则是创建了一个新的空间，虽然内容可能是一样的，但是大家使用的空间，地址都是不同的。</p>
</blockquote>
<p>在OC中可以使用copy或者mutableCopy语法来实现深拷贝和浅拷贝，要求实现NSCopying或者NSMutableCopying协议。</p>
<p>copy和mutableCopy是有区别的，区别在于NSString和NSMutableString的区别，如果使用NSString调用copy创建出来的新对象那就是NSString，如果是使用NSString的mutableCopy创建出来的新对象那就是NSMutableString。前者是不可变的，后者是可变的，它的空间不是固定的。</p>
<pre><code>NSString *<span class="typename">string</span> = [[NSString alloc] initWithFormat:@<span class="string">"123"</span>,<span class="number">10</span>];

NSMutableString *str = [<span class="typename">string</span> mutableCopy];

[<span class="typename">string</span> <span class="keyword">release</span>];
[str <span class="keyword">release</span>];
</code></pre><p>遵守上面所说的创建一个副本，修改副本的时候不会改变原来的对象，其实这里可以看内存地址就可以看出来，它们是不同的。</p>
<pre><code><span class="attr_selector">[str appendString:@"123"]</span>;

<span class="function">NSlog</span>(<span class="at_rule">@<span class="string">"%@"</span>,string);</span>
<span class="function">NSlog</span>(<span class="at_rule">@<span class="string">"%@"</span>,str);</span>
</code></pre><p>从打印的结果可以很明显的看的出来，从内存的角度上来看，因为是新对象，所以它的引用计数是加1的，所以copy或者mutableCopy都需要release。</p>
<p>如果使用copy语法，因为有一个机制不可变的元素，所以OC就直接把原来的对象返回，并且引用计数加1，于是这就是浅拷贝了，而mutableCopy就是深拷贝了。</p>
<p>如果在OC中反过来又是什么样的情况呢？比如使用NSMutableString调用它的copy方法，会产生什么样的情况呢？</p>
<pre><code>NSMutableString *<span class="built_in">string</span> = [[NSMutableString alloc]stringWithForma<span class="variable">t:</span>@<span class="string">"123"</span>,<span class="number">10</span>];
NSString *str = [<span class="built_in">string</span> <span class="built_in">copy</span>];
</code></pre><p>如果从可变成不可变使用的copy却是一个深拷贝，产生一个新的对象，它的引用计数为1。如果可变的使用mutableCopy产生一个对象，它也是深拷贝，产生一个新对象，引用计数为1，所以都需要release。</p>
<blockquote>
<p>总结一下，只有一种情况是浅拷贝，不可变对象调用它的copy方法为浅拷贝，再原对象上计数加1.而其他的不管是调用copy还是mutableCopy都是深拷贝，产生一个新的对象，计数为1。</p>
</blockquote>
<h3 id="如何自定义的类提供copy或者mutableCopy">如何自定义的类提供copy或者mutableCopy</h3>
<p>如果要自己实现自定义对象的copy或者mutableCopy语法，首先要实现NSCopying或者NSMutableCopying协议，它们的原理都是一样的，按NSCopying来讲解一个例子。</p>
<pre><code>-(<span class="property">id</span>)copyWithZone:(NSZone *)zone
{
    Pser *<span class="keyword">copy</span> = [[[self <span class="type">class</span>] allocWithZone:zone] init];
    <span class="keyword">copy</span>.<span class="property">name</span> = _name;
<span class="command">    return</span> <span class="keyword">copy</span>;
}
</code></pre><p>主要是实现copyWithZone方法，系统会为copy分配一个空间，以存储创建出来的副本。它不要求在copyWithZone内部进行内存管理，因为外部还需要使用。一般来说，使用copy还需要注意一些问题，也就是父子的问题。假设父类有实现copyWithZone方法，一般来说在子类中需要覆盖一下，然后调用它的父类的copyWithZone。而且在需要使用self class来实例对象，谁使用self就是谁，这样才能说子类调用之后，接收的还是子类，而不是父类。</p>
<pre><code> <span class="title">[super copyWithZone:zone]</span><span class="comment">;</span>
</code></pre><p>然后再进一步的操作。</p>
<p>NSMutableCopying的操作步骤是一模一样的，注意的问题也是如同。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是一个关于深拷贝和浅拷贝的问题，OC设计这个语法的目的就是创建一个副本，修改副本的时候不会改变原来的对象。</p>
<blockquote>
<p>对于这两个问题可以这么理解，浅拷贝也就是把指针赋值，大家用的都是地址。而深拷贝，则是创建了一个新的空间，虽然内容可能是一样的]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS的内存管理]]></title>
    <link href="http://icepy.github.io/2015/02/04/iOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://icepy.github.io/2015/02/04/iOS的内存管理/</id>
    <published>2015-02-04T15:00:33.000Z</published>
    <updated>2015-02-06T11:56:21.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS开发中使用的是引用计数的方式来管理内存，也就是跟踪记录每个值被引用的次数。当声明一个变量来接收一个指针对象，引用次数就＋1，如果指针对象被添加到数组，字典，或者被其他指针对象所使用又＋1.如果使用完毕之后对它进行－1，一直到0，系统会立马释放这段内存。</p>
<blockquote>
<p>如果开启了ARC机制，编译器会帮助我们在代码中添加上内存管理的代码，而且在Xcode中比如retain这些都是不可以使用的</p>
</blockquote>
<p>在OC中可以使用retainCount来查看指针对象的引用次数。</p>
<pre><code><span class="variable">Wower</span> *wower = [[<span class="variable">Wower</span> alloc] init<span class="variable">WithName</span>:@<span class="string">"lcepy"</span> <span class="keyword">and</span><span class="variable">T</span>:@<span class="string">"魔兽世界"</span>];
<span class="variable">NSLog</span>(@<span class="string">"%zi"</span>,[wower retain<span class="variable">Count</span>]);
</code></pre><p>一般来说如果在代码中使用了alloc，copy，retain，引用计数都是加一，而release则是引用计数减一，又比如把指针对象添加到数组，字典，内部的引用计数也会加一，但是这个的话，系统是会来管理的。又比如一些静态方法，也会由系统来管理，内部是会加一的。还有一种叫做自动释放池的玩意，autorelease，它的功能是整个执行过程结束，系统来管理释放的工作。</p>
<p>一般来说基本类型的数据也就是C语言的如int这样的，直接赋值即可不用管理，在iOS中主要是对OC指针对象进行内存管理。在使用@property的时候，根据参数retain，copy，编译器会帮助我们生成getter，setter方法，而且还会帮助我们进行一下内存管理，比如：</p>
<pre><code><span class="pp">-<span class="params">(void)</span>setterFound:<span class="params">(<span class="variable">Found</span> *)</span>found
{
    if <span class="params">(<span class="variable">_</span>found != found)</span> {
        [_found release];
        _found = found;
        [_found retain];
    }
}</span>
</code></pre><p>有一点要注意的是如果是retain，copy一般来说接收的都是OC对象，基本类型可以用assign。</p>
<p>实例：</p>
<pre><code><span class="comment">//.h文件</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Found</span> : <span class="title">NSObject</span></span>

<span class="keyword">@end</span>


<span class="class"><span class="keyword">@interface</span> <span class="title">Wower</span> : <span class="title">NSObject</span></span>
{
    Found *_found;
}

<span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;
<span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *game;

-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andT:(<span class="built_in">NSString</span> *)game;
-(<span class="keyword">void</span>)setterFound:(Found *)found;

<span class="keyword">@end</span>
<span class="comment">//.m文件</span>
<span class="class"><span class="keyword">@implementation</span> <span class="title">Wower</span></span>

-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andT:(<span class="built_in">NSString</span> *)game
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _name = name;
        _game = game;
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}


-(<span class="keyword">void</span>)dealloc
{

    <span class="built_in">NSLog</span>(<span class="string">@"Found的引用计数%zi"</span>,[_found retainCount]);
    [_found release];
    <span class="built_in">NSLog</span>(<span class="string">@"Found的引用计数%zi"</span>,[_found retainCount]);
    [<span class="keyword">super</span> dealloc];

}

-(<span class="keyword">void</span>)showMessage
{

    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,_name);
    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,_game);
}

-(<span class="keyword">void</span>)setterFound:(Found *)found
{
    <span class="keyword">if</span> (_found != found) {
        [_found release];
        _found = found;
        [_found retain];
    }
}
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Found</span></span>

-(<span class="keyword">void</span>)dealloc
{
    [<span class="keyword">super</span> dealloc];
    <span class="built_in">NSLog</span>(<span class="string">@"释放"</span>);
}

<span class="keyword">@end</span>

<span class="comment">//main文件</span>

<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        Wower *wower = [[Wower alloc] initWithName:<span class="string">@"lcepy"</span> andT:<span class="string">@"魔兽世界"</span>];
        <span class="built_in">NSLog</span>(<span class="string">@"%zi"</span>,[wower retainCount]);
        Found *f = [[Found alloc] init];
        [wower setterFound:f];
        [wower release];
        [f release];
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>dealloc是OC对象释放之后，系统会自动调用，这里一般都是来释放一些其他对象。在Wower类的dealloc中只释放了_found，而copy的那个却没有释放，那是因为@””快速创建的，一般来说这些都不需要自己来管理而是系统。</p>
<blockquote>
<p>关于OC的内存管理，其实有一个原则，就是谁创建谁释放，谁使用谁释放。在之前，创建了wower,f对象，于是它们要在外部释放，而我使用了setFound方法来把f对象设置到成员变量中，于是这里就成了wower对象的_found成员变量在使用，于是它有责任在dealloc的时候来把f对象的引用计数减1。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS开发中使用的是引用计数的方式来管理内存，也就是跟踪记录每个值被引用的次数。当声明一个变量来接收一个指针对象，引用次数就＋1，如果指针对象被添加到数组，字典，或者被其他指针对象所使用又＋1.如果使用完毕之后对它进行－1，一直到0，系统会立马释放这段内存。</p>
<b]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript十一之理解内存管理]]></title>
    <link href="http://icepy.github.io/2015/02/04/%E5%A4%8D%E4%B9%A0JavaScript%E5%8D%81%E4%B8%80%E4%B9%8B%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://icepy.github.io/2015/02/04/复习JavaScript十一之理解内存管理/</id>
    <published>2015-02-04T10:53:09.000Z</published>
    <updated>2015-02-24T11:47:32.000Z</updated>
    <content type="html"><![CDATA[<p>一般来说内存管理主要有这么几种方式，引用计数和标记，而JavaScript采用的就是标记管理的方式。Js的内存管理是自动的，但是并不是说执行完后立马销毁，而是有时间周期性，相隔一段时间执行一下垃圾回收，把没有引用的内存全部销毁。</p>
<p>OC中采用的是引用计数来手动管理内存，这样的方式比较好，可以让开发者自己来管理。当然也有不好的地方，如果遗忘了释放，很可能引起应用的崩溃。</p>
<p>总体来看在IE中因为COM组件的原因，可能会发生循环引用的问题，这个问题在引用计数的内存管理都会遇见。所谓的循环引用是指在对象A中包含了一个指向B的指针，然后再对象B中包含一个指向A的指针，于是悲剧了。</p>
<pre><code>var element = document.getElementById(<span class="string">'doc'</span>);
var <span class="keyword">my</span> = {};
<span class="keyword">my</span>.element = element;
element.<span class="keyword">my</span> = <span class="keyword">my</span>;
</code></pre><p>大家都引用，于是，可想而知。要避免这种问题，一定要在不使用的时候my.element = null，把它断开。</p>
<p>那么，其他浏览器呢？还是标记清理的机制，比如一个函数的变量，在进入环境时标记上“进入环境”，执行完之后标记上“离开环境”，然后等待系统来释放。</p>
<p>IE有一个手动释放的方法，window.CollectGarbage，调用它就立马释放已经标记离开环境的变量，不过很多文章都不建议这样做。</p>
<p>那么一般都这样做，引用类型的释放</p>
<pre><code><span class="keyword">var</span> my = {};
<span class="comment">//使用完毕之后</span>
my = <span class="literal">null</span>;
</code></pre><p>让my脱离执行环境，标记上已经离开环境，然后等待系统执行垃圾回收，释放内存。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般来说内存管理主要有这么几种方式，引用计数和标记，而JavaScript采用的就是标记管理的方式。Js的内存管理是自动的，但是并不是说执行完后立马销毁，而是有时间周期性，相隔一段时间执行一下垃圾回收，把没有引用的内存全部销毁。</p>
<p>OC中采用的是引用计数来手动管]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript十之理解引用类型和匿名函数闭包]]></title>
    <link href="http://icepy.github.io/2015/02/03/%E5%A4%8D%E4%B9%A0JavaScript%E5%8D%81%E4%B9%8B%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85/"/>
    <id>http://icepy.github.io/2015/02/03/复习JavaScript十之理解引用类型和匿名函数闭包/</id>
    <published>2015-02-03T11:02:01.000Z</published>
    <updated>2015-03-04T12:45:41.000Z</updated>
    <content type="html"><![CDATA[<p>引用类型虽然看起来和类很相似，但是它们却是不同的概念，引用类型的值，也就是对象是引用类型的一个实例。在Js中引用类型主要有Object，Array，Date，正则，Function等。</p>
<p>Object之前已经复习过了，Array是用的非常频繁的一个引用类型。</p>
<p><strong>Array</strong></p>
<p>在Js中数组可以存储任意的数据，而且它的大小是可以动态调整的类似于OC中的NSMutableArray。创建数组可以使用构造函数的方式也可以使用字面量的形式，另外可以使用concat从一个数组中复制一个副本出来。数组本身提供了很多方法让开发者使用来操作数组。</p>
<ul>
<li>length 数组的长度</li>
<li>toString  可以返回一个以，拼接的字符串，相当于是调用了下join(‘,’)</li>
<li>join 可以用一个分割符来拼接成一个字符串</li>
<li>push 添加一个数据到数组的末端</li>
<li>pop 删除数组中的最后一项，有返回值</li>
<li>shift 删除数组的第一项，有返回值</li>
<li>unshift 添加一个数据到数组的首端</li>
<li>reverse 倒序</li>
<li>sort 可以传入一个排序的函数</li>
<li>slice 可以基于当前数组返回一个新的数组，接收两个参数，返回项的起始位置和结束位置</li>
<li>splice 可以传入N个参数，第一个参数表示要删除，插入或则替换的位置，第二个参数表示要删除的项数，第三个到第N个表示要插入或则替换的数据</li>
</ul>
<p><strong>Date</strong></p>
<p>时间对象也是使用非常多的玩意，它是使用GMT时间来描述，而且时间对象是可以直接比对大小的。</p>
<pre><code><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">2</span>);
<span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">10</span>);

date1 &lt; date2  
</code></pre><p>常用的方法</p>
<ul>
<li>getTime 获取时间对象的毫秒数</li>
<li>setTime 设置时间对象的毫秒数，会改变日期</li>
<li>getFullYear 获取时间对象的年（2015）</li>
<li>getMonth 获取时间对象的月（需要加1）</li>
<li>getDay 获取日期的星期几（0-6）星期天到星期六</li>
<li>getDate 获取日期的天数</li>
<li>getHours 获取当前日期的小时</li>
<li>getMinutes 获取当前日期的分钟数</li>
<li>getSeconds 获取当然日期的秒数</li>
</ul>
<p>上面看起来都是获取，当然也有设置，只是相应的get置换成set即可。</p>
<p><strong>正则表达式</strong></p>
<p>在Js里正则表达式是用RegExp类型来支持的，关于正则可以看看之前写的一篇文章，用python来描述的如何读懂正则。</p>
<p>Js也支持三种模式，gim，表示全局，不区分大小写，多行。</p>
<p>一般来说很少有人这么使用var xxx = new RegExp()，而是用字面量的方式，比如var xx = /[bc]/gi;像用的比较多的方法有exec用于捕获包含第一个匹配项的数组，没有则返回null。test，用于判断，如果匹配返回true，不匹配返回false。</p>
<p><strong>Function</strong></p>
<p>说起来Js的核心是什么？那就是函数了。对于函数主要是理解它的几个概念，它可以当值来传递，没有重栽。而且声明的时候，比如function a(){} var a = function(){} 执行时会有区别。函数内部的参数arguments包含了传入的所有参数，this，表示在这个函数内的作用域，以及prototype。</p>
<p><strong>处理字符串</strong></p>
<p>在Js中还有一种叫做包装类型的玩意，正因为此所以处理一些基本数据类型，比如字符串时，有很多方法可以使用。</p>
<ul>
<li>concat 可以将一个或者多个字符串拼接起来，返回一个新的字符串</li>
<li>slice 接收两个参数，起始位置和结束位置，返回一个新的字符串</li>
<li>substr和substring和slice一样，唯一的不同是substr第二个参数是返回字符串的个数</li>
<li>indexOf 从头开始查询字符串，存在会返回它所在的位置，没有返回－1</li>
<li>lastIndexOf 从最后开始查询字符串</li>
<li>toUpperCase 转大写</li>
<li>toLowerCase 转小写</li>
<li>match 正则表达式使用跟exec一样</li>
<li>search 正则表达式使用，查询到返回一个位置，没有返回－1</li>
<li>replace 替换，第一个参数可以是正则表达式也可以是字符串，第二个参数是要替换的字符串</li>
<li>localeCompare比较字符串，如果字符串相等返回0，如果字符串的字母排在参数字符串之前，返回负数，如果是之后，返回正数。</li>
</ul>
<h3 id="理解匿名函数和闭包">理解匿名函数和闭包</h3>
<p>匿名函数又叫拉姆达函数，主要是在把函数当值传递的时候用，或者是把函数当返回值，比如：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">d</span><span class="params">(callback)</span></span>{
    <span class="keyword">callback</span>();
}
d(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="string">'123'</span>)
});

<span class="comment">//或者</span>

<span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="string">'123'</span>);
    }
}
<span class="keyword">var</span> g = b();
g();
</code></pre><p>其实第二种方式跟闭包的意义一样了，所谓的闭包书面的解释是可以访问另一个函数作用域内变量的函数，稍微改写一下可能会更明显。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span>{
    <span class="keyword">var</span> name = <span class="string">'123'</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(name);
    }
}
<span class="keyword">var</span> g = b();
g();
</code></pre><p>从这里可以看出来return的函数可以访问到name，而外部却不行，这个返回值的函数就可以理解为闭包。理解闭包还可以看一个经典的求值的例子。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">save_i</span><span class="params">()</span></span>{
    <span class="keyword">var</span> a = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
        a[i] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> i;
        }
    }
    <span class="keyword">return</span> a;    
}

<span class="keyword">var</span> c = save_i();
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
    alert(c[i]());
}
</code></pre><p>从这个例子上来看，我们想得到的结果是10次循环a[i]保存着一个闭包，然后alert出从0到10，但是结果很出人意料，全部是10，为什么？哪里理解的不对呢？a[i]明明是内部函数，然后让它访问另外一个函数作用域内的变量i。</p>
<p>个人觉得可以这样去分析问题，在客户端执行Js时有一个全局执行环境，指向的是window对象。而所谓的对象也就是引用类型，实际上在后台执行环境中，它就是一个指针。</p>
<p>回到Js当代码在执行的时候，会创建变量对象并且构建一个作用域链，而这个对象保存着当前函数可以访问的对象。</p>
<pre><code>window
    -<span class="ruby">&gt;save_i
</span>        -<span class="ruby">&gt;this|argument
</span>        -<span class="ruby">&gt;a
</span>        -<span class="ruby">&gt;i
</span>        -<span class="ruby">&gt;看不见的a[<span class="number">0</span>]-a[<span class="number">10</span>]
</span>        -<span class="ruby">&gt;a[<span class="number">0</span>]function(){}
</span>            -<span class="ruby">&gt;i
</span>    -<span class="ruby">&gt;c</span>
</code></pre><p>上述的i和a[0]里的i是同一个i，那么结果就是10。</p>
<p>进一步处理</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">save_i</span><span class="params">()</span></span>{
    <span class="keyword">var</span> a = [];
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
        a[i] = <span class="function"><span class="keyword">function</span><span class="params">(k)</span></span>{
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
                <span class="keyword">return</span> k;
            };
        }(i)
    }
    <span class="keyword">return</span> a;    
}

<span class="keyword">var</span> c = save_i();
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
    <span class="built_in">console</span>.log(c[i]());
}
</code></pre><p>接着按上面的节奏来分析</p>
<pre><code>window
    -<span class="ruby">&gt;save_i
</span>        -<span class="ruby">&gt;this|argument
</span>        -<span class="ruby">&gt;a
</span>        -<span class="ruby">&gt;i
</span>        -<span class="ruby">&gt;看不见的a[<span class="number">0</span>]-a[<span class="number">10</span>]
</span>        -<span class="ruby">&gt;a[<span class="number">0</span>]function(){}
</span>            -<span class="ruby">&gt;k
</span>            -<span class="ruby">&gt;function(){}
</span>                -<span class="ruby">&gt;k
</span>
    -<span class="ruby">&gt;c</span>
</code></pre><p>什么是传参？按值传递，相当于是在那个立即执行的函数中创建了一个新的地址和空间，虽然值是一样的，但是每一个k又是不同的，所以得到的结果正好满足了我们的预期。</p>
<p>本来正常情况下save_i执行完毕后就要销毁，但是内部的闭包被包含在这个作用域内了，所以save_i没法销毁，从这里可以看的出来闭包会带来内存的问题，因为用完之后没法销毁，如果不注意的话。</p>
<p>那么用完之后只能设置为null来解除引用，等着自动销毁把内存回收。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>引用类型虽然看起来和类很相似，但是它们却是不同的概念，引用类型的值，也就是对象是引用类型的一个实例。在Js中引用类型主要有Object，Array，Date，正则，Function等。</p>
<p>Object之前已经复习过了，Array是用的非常频繁的一个引用类型。</]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript九之客户端存储方案]]></title>
    <link href="http://icepy.github.io/2015/02/03/%E5%A4%8D%E4%B9%A0JavaScript%E4%B9%9D%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
    <id>http://icepy.github.io/2015/02/03/复习JavaScript九之客户端存储方案/</id>
    <published>2015-02-03T09:43:48.000Z</published>
    <updated>2015-02-24T11:47:03.000Z</updated>
    <content type="html"><![CDATA[<p>随着Web应用越来越复杂，总是有很多需求需要在客户端存储一些特定的信息，用来描述访问者或者跟访问者相关的信息。于是，就有了这些客户端存储的方案，供开发者选择以及使用。</p>
<h3 id="cookie">cookie</h3>
<p>说起来cookie的出现是非常早的，用于在客户端存储会话信息，它要求服务器对任意的HTTP请求发送Set-Cookie HTTP头作为响应的一部分，例如：</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">200</span> OK</span>
<span class="attribute">Content-Type</span>: <span class="string">text/html</span>
<span class="attribute">Set-Cookie</span>: <span class="string">name=value</span>
</code></pre><p>cookie虽然好用，但是它在客户端上有很多限制，而去获取也不是很容易。最重要的是关于请求的性能，cookie是对任意HTTP设置，所以也会发送给服务器，这些额外信息有时候不是必需的。</p>
<ul>
<li>cookie是跟特定的域有关系的，也就意味着存储在cookie中的信息只能让特定的域来访问</li>
<li>cookie的条数是有限制的，大体上来说各浏览器不会超过50个，除了safair chrome</li>
<li>cookie在客户端只有一个方法可以用document.cookie</li>
<li>cookie的大小在客户端上也有限制，大体不会超过1MB</li>
<li>如果在客户端设置了cookie，是没法删除的，只能在同一个cookie上设置name=空字符串或者设置失效时间</li>
<li>如果设置了secure，cookie只能在SSL链接才能传输</li>
</ul>
<p>cookie在浏览器上的保存是由几个方面组成的，理解这个对于使用Js操作cookie是一个必备条件，它由名称也就是每一项的key，每一项的值value，域名的限制，路径对于哪一个页面起作用，时间，以及安全标识secure。</p>
<p>在客户端主要是使用document.cookie来进行操作，获取和设置都是这一个。而去获取是一个全的字符串，还需要进一步的处理才能得到值。如果是设置，也是需要设置一个全的字符串。对于这个，最好都要encodeURIComponent一下，获取的时候decodeURIComponent一下。</p>
<pre><code><span class="keyword">var</span> setCookie = <span class="function"><span class="keyword">function</span><span class="params">(name,value,expires,path,domain,secure)</span></span>{
    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name)+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(value);

    <span class="comment">//各项的拼接</span>
    <span class="built_in">document</span>.cookie = cookieText;
}
</code></pre><p>聪明的开发者为了绕开浏览器上对于条数的限制，研究出了一个方式，把真实的值设置在子cookie上。</p>
<pre><code><span class="variable">name=</span><span class="variable">name=</span>value
</code></pre><h3 id="IE上的客户端存储userData">IE上的客户端存储userData</h3>
<p>在IE中引入了一个userData的方案来存储客户端数据，允许每个文档最多128KB，每个域1MB的数据量。想使用它首选在那个元素上应用一个css。</p>
<pre><code>&lt;<span class="keyword">div</span> style=<span class="string">"behavior:url(#default#userData)"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>使用的时候跟设置dom属性一样，唯一有一个不同的地方是最后要调用save方法，告诉它存储在哪个数据仓库上。</p>
<pre><code><span class="keyword">var</span> dataStore = <span class="built_in">document</span>.getElementById(<span class="string">'dataStore'</span>);
dataStore.setAttribute(<span class="string">'name'</span>,<span class="string">'lcepy'</span>);
dataStore.save(<span class="string">'MyNameInfo'</span>);
</code></pre><p>获取</p>
<pre><code>dataStore.<span class="built_in">load</span>(<span class="string">'MyNameInfo'</span>);
dataStore.getAttribute(<span class="string">'name'</span>);
</code></pre><h3 id="HTML5的客户端存储方案">HTML5的客户端存储方案</h3>
<blockquote>
<p>支持度以及使用比较广泛的是Web Storage API，当然客户端还有本地数据IndexDB等等，这些也是可以存储客户端数据，但是它们支持的很少。在做移动端开发时，localStorage的使用是非常频繁的，还要注意一点是个别比如safair浏览器有隐私模式，本地缓存是不起作用的，无法读取，所以要做一些额外的处理。</p>
</blockquote>
<p>主要的是两个sessionStorage和localStorage两套API来应用，它们是有区别的，前者只在浏览器运行时存在，也可以跨页面，前提是页面不能关闭。后者是永久存在的，如果用户不删除，那么它永远不会删除。它们的使用方式都是一样的，包括API。至于分配的空间，要看各浏览器的态度的，一般情况下是5MB，还有一点它是跟域走的。</p>
<pre><code><span class="title">interface</span> Storage{
    <span class="title">readonly</span> attribute unsigned long legth;
    <span class="title">getter</span> DOMString key();
    <span class="title">getter</span> any getItem();
    <span class="title">setter</span> creator void setItem();
    <span class="title">deleter</span> void removeItem();
    <span class="title">viod</span> clear();
}
</code></pre><ul>
<li>length 描述Storage对象中存储的key=value数量</li>
<li>key 方法允许获取一个指定位置的键</li>
<li>getItem方法根据指定的key返回一个value</li>
<li>setItem方法将数据value存入指定的位置key</li>
<li>removeItem根据指定的key来删除数据</li>
<li>clear 删除全部的数据</li>
</ul>
<p>使用：</p>
<pre><code><span class="transposed_variable">localStorage.</span>setItem(<span class="string">'name'</span>,<span class="string">'lcepy'</span>);
<span class="transposed_variable">localStorage.</span>getItem(<span class="string">'name'</span>);
<span class="transposed_variable">localStorage.</span>key(<span class="number">0</span>);
<span class="transposed_variable">localStorage.</span><span class="built_in">length</span>;
<span class="transposed_variable">localStorage.</span>removeItem(<span class="string">'name'</span>);
<span class="transposed_variable">localStorage.</span><span class="keyword">clear</span>();
</code></pre><p>另外API中还有一套事件用于本地存储发生改变时的通知</p>
<pre><code><span class="built_in">window</span>.addEventLister(<span class="string">'storage'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{},<span class="literal">true</span>);
</code></pre><p>event对象中包含有</p>
<ul>
<li>key 存储了被更新或者删除的键</li>
<li>oldValue 包含了更新之前的数据</li>
<li>url Storage事件发生的源</li>
<li>newValue 包含了更新之后的数据</li>
<li>storageArea 包含一个引用，指向发生改变之前的localStorage或者sessionStorage</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着Web应用越来越复杂，总是有很多需求需要在客户端存储一些特定的信息，用来描述访问者或者跟访问者相关的信息。于是，就有了这些客户端存储的方案，供开发者选择以及使用。</p>
<h3 id="cookie">cookie</h3>
<p>说起来cookie的出现是非常早的，]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[复习JavaScript八之操作XML]]></title>
    <link href="http://icepy.github.io/2015/02/02/%E5%A4%8D%E4%B9%A0JavaScript%E5%85%AB%E4%B9%8B%E6%93%8D%E4%BD%9CXML/"/>
    <id>http://icepy.github.io/2015/02/02/复习JavaScript八之操作XML/</id>
    <published>2015-02-02T09:50:14.000Z</published>
    <updated>2015-02-24T11:47:17.000Z</updated>
    <content type="html"><![CDATA[<p>在以前XML是存储和传输数据的事实标准（客户端没有出现JSON之前），那个时候浏览器还不支持解析XML，于是很多开发者需要自己写一个XML解析器。原理，就是把XML也转化成DOM文档，然后通过DOM API来获取。</p>
<p>而现在，在客户端（浏览器）编程中几乎很少会使用到XML，数据的交换都应用在JSON上了，了解这个有一个好处，就是在做服务端编程，比如SAOP协议时就会用到，还有桌面的客户端，或者是移动客户端上，比如iOS，它把一些数据，比如NSArray写入到本地，实际上就是一个XML文本，当然在代码层面上，是看不出来有解析的，如果读取这个文件，是直接转成NSArray对象的。</p>
<blockquote>
<p>IE有它自己的实现对XML的支持，下面说的两个类型，在IE中都不支持</p>
</blockquote>
<p>将XML字符串序列化成DOM文档，主要是使用DOMparser类来实现，其他的用法跟获取DOM节点一样。</p>
<pre><code><span class="keyword">var</span> parser = <span class="keyword">new</span> DOMparser();
<span class="keyword">var</span> xmlDomObject = parser.parserFromString(<span class="string">'&lt;root&gt;&lt;child/&gt;&lt;/root&gt;'</span>,<span class="string">'text/xml'</span>);

xmlDomObject.getElementsByTagName(<span class="string">'child'</span>);
</code></pre><p>将DOM文档反序列化成XML字符串，主要是使用XMLSerializer类型，使用上述的xmlDomObject对象。</p>
<pre><code><span class="built_in">var</span> serializer <span class="subst">=</span> <span class="literal">new</span> XMLSerializer();
<span class="built_in">var</span> <span class="built_in">xml</span> <span class="subst">=</span> serializer<span class="built_in">.</span>serializeToString(xmlDomObject);
</code></pre><p>如果XML解析有错误都会返回一个parsererror标签，获取的时候就可以判断是否有这个标签来决定解析是否有错误。</p>
<p>据说DOM3版本的XML操作只有一个浏览器实现了，所以当资料了解就好。</p>
<h3 id="IE版本">IE版本</h3>
<blockquote>
<p>IE版本的XML解析主要是使用它的ActiveXObject类型来实现</p>
</blockquote>
<p>在IE中想要解析XML就必须先创建一个空的DOM文档，然后通过这个文档来获取。</p>
<pre><code>var xmldom = createDocument();
xmldom.loadXML(<span class="comment">'<span class="xmlDocTag">&lt;root&gt;</span><span class="xmlDocTag">&lt;child/&gt;</span><span class="xmlDocTag">&lt;/root&gt;</span>');</span>

xmldom.getElementsByTagName(<span class="comment">'child');</span>
</code></pre><p>如果解析有错误，可以检查parseError对象。</p>
<pre><code><span class="keyword">if</span>(xmldom.parseError !== <span class="number">0</span>){
    //<span class="keyword">do</span> 
}
</code></pre><p>在IE中进行序列化非常的方便，因为它都内置在了DOM文档中，每一个DOM节点都有一个xml属性，它就保存着XML字符串。</p>
<pre><code>xmldom<span class="built_in">.</span><span class="built_in">xml</span>
</code></pre><p>最后IE还提供了一个可以加载远程XML文件的方法load，它就接收一个参数，远程XML的URL地址。当然，也可以使用async属性来设置同步还是异步，默认是异步（true）。</p>
<pre><code><span class="keyword">var</span> xmldom = createDocument();
xmldom.<span class="keyword">async</span> = <span class="keyword">false</span>;
xmldom.load(<span class="string">'http://xxx.sss.xml'</span>);
</code></pre><p>如果是异步还要监听一下onreadystatechange事件，判断readystate状态，这个跟Ajax的使用是一样的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在以前XML是存储和传输数据的事实标准（客户端没有出现JSON之前），那个时候浏览器还不支持解析XML，于是很多开发者需要自己写一个XML解析器。原理，就是把XML也转化成DOM文档，然后通过DOM API来获取。</p>
<p>而现在，在客户端（浏览器）编程中几乎很少会使]]>
    </summary>
    
      <category term="JavaScript" scheme="http://icepy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UINavigationController的理解]]></title>
    <link href="http://icepy.github.io/2015/02/01/UINavigationController%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://icepy.github.io/2015/02/01/UINavigationController的理解/</id>
    <published>2015-02-01T11:23:41.000Z</published>
    <updated>2015-03-20T12:05:52.000Z</updated>
    <content type="html"><![CDATA[<p>在做iOS开发的时候，<strong>UINavigationController</strong>可以说使用跟那个UITableView一样非常的常见。在学习这个之前，需要了解一下在iOS开发中的层级关系。</p>
<p>我把它想象成一本书，虽然这么描述非常的不精准，但是却很像。每一个UIViewController就像书页，最外面的一个是封页，当然它就是我们的启动UI界面了，而目录就相当于是UINavigationController，通过它可以精准的翻到每一页。在iOS应用中，这样的层级关系就像书页一页。</p>
<blockquote>
<p>实际上这里可能描述的有些错误，但是我只能这么想象了，当我翻到某一页时，这一页（UIViewController）就是在顶端的，而其他页（UIViewController）是在下面的。当然，对于导航控制，它想要控制每一页（对于书来说是人在控制）就必需在每一个视图控制器的根部。</p>
</blockquote>
<p>UINavigationController是一个栈结构，所谓的栈结构也就是一个顺序（先进后出的顺序），因为当前的书页我们要看见，它永远都必须在第一的位置，我们才能看见，也就决定了它是我们人看完之后才能出去的顺序。</p>
<p>如何创建一个UINavigationController？</p>
<pre><code> ViewController *<span class="variable">view =</span> [[ViewController alloc] init];
UINavigationController *<span class="variable">navigation =</span> [[UINavigationController alloc]
initWithRootViewController:view];
self.window.<span class="variable">rootViewController =</span> navigation;
</code></pre><p>这里会要求加入一个根视图控制器，也就是初始化时我们看见的那一页。</p>
<p>从官方的.h文件中可以看的出来用来进行导航的就四个方法，协议的不算。</p>
<pre><code>- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated; <span class="comment">// Uses a horizontal slide transition. Has no effect if the view controller is already in the stack.</span>

- (<span class="built_in">UIViewController</span> *)popViewControllerAnimated:(<span class="built_in">BOOL</span>)animated; <span class="comment">// Returns the popped controller.</span>
- (<span class="built_in">NSArray</span> *)popToViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated; <span class="comment">// Pops view controllers until the one specified is on top. Returns the popped controllers.</span>
- (<span class="built_in">NSArray</span> *)popToRootViewControllerAnimated:(<span class="built_in">BOOL</span>)animated; <span class="comment">// Pops until there's only a single view controller left on the stack. Returns the popped controllers.</span>
</code></pre><p>分别是添加到视图控制器入栈，移出最后一个视图控制器，移出到跟视图控制器上，移出到任意位置上的视图控制器。</p>
<p>除了上述的方法外，还有几个属性需要掌握，在写到这个之前，还需要理解导航控制上的一些概念问题。对于管理多个内容视图的push和pop，导航控制器自身提供了视图切换的动画效果。一般来说一个app中的内容区域就相当于视图控制器，而这个框就是导航控制器，当然这个框又是在另一个框上的，比如window。假设一下，当我们切换了内容后，有些app是上部的一个工具条不会变中间的内容变，也有可能中间和上部都会变。从这里，其实可以看的出来，导航控制存在着这些toolBar，也控制着视图控制器，但是这些toolBar的真正控制权是在每一个视图控制器上的。</p>
<p>总结起来</p>
<blockquote>
<p>一个navigationController对应一个navigationBar，一个navigationController包含多个UIViewController，每个UIViewController对应一个UINavigationItem，UINavigationItem控制着多个UIBarButtonItem，一个UINavigationController控制一个UIToolBar，UIToolBar中的UIBarButtonItem由当前视图控制器管理，而不是导航控制器来控制。需要注意的是，一个UINavigationItem不是由navigationbar或者是导航控制器来控制，而是由当前视图控制器来控制。</p>
</blockquote>
<p>对于生成一个系统自带的UIBarButtonItem，从代码上就可以看的出来它不是self.navigationController在控制，当然有系统的一般来说肯定有自定义的。</p>
<pre><code><span class="built_in">UIBarButtonItem</span> *leftbutton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemBookmarks target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(leftEvent)];
<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = leftbutton;

<span class="built_in">UIButton</span> *button1 = [<span class="built_in">UIButton</span> buttonWithType:UIButtonTypeRoundedRect];
[button1 setTitle:<span class="string">@"view"</span> forState:UIControlStateNormal];
[button1 setTitleColor:[<span class="built_in">UIColor</span> blackColor] forState:UIControlStateNormal];
[button1 setFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">40</span>)];
[button1 addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(customviews:) forControlEvents:UIControlEventTouchUpInside];
<span class="built_in">UIBarButtonItem</span> *right = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:button1];

<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItem</span> = right;
</code></pre><p>自定义一个button放到navigationItem的右边的bar中</p>
<pre><code><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:UIButtonTypeRoundedRect];
[button setTitle:<span class="string">@"Push"</span> forState:UIControlStateNormal];
[button setTitleColor:[<span class="built_in">UIColor</span> blackColor] forState:UIControlStateNormal];
[button setFrame:CGRectMake(<span class="number">90</span>, <span class="number">100</span>, <span class="number">140</span>, <span class="number">40</span>)];
[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pushview:) forControlEvents:UIControlEventTouchUpInside];
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:button];

-(<span class="keyword">void</span>)pushview:(<span class="built_in">UIButton</span> *)sender
{
    SecondViewController *secoundVC = [[SecondViewController alloc] init];
    [<span class="keyword">self</span><span class="variable">.navigationController</span> pushViewController:secoundVC animated:<span class="literal">YES</span>];
}
</code></pre><p>然后创建一个按钮，导航到第二个视图控制器上。</p>
<p><a href="https://github.com/lcepy/geekObjective-C/tree/master/NavigationControllerDemo" target="_blank" rel="external">源代码查看</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在做iOS开发的时候，<strong>UINavigationController</strong>可以说使用跟那个UITableView一样非常的常见。在学习这个之前，需要了解一下在iOS开发中的层级关系。</p>
<p>我把它想象成一本书，虽然这么描述非常的不精准，但是]]>
    </summary>
    
      <category term="iOS" scheme="http://icepy.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
